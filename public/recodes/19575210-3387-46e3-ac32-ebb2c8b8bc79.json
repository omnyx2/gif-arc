{
    "uuid": "19575210-3387-46e3-ac32-ebb2c8b8bc79",
    "created": "2025-04-07 00:48:52",
    "description": "It appears to show someone with reddish hair and headphones sitting in front of a microphone. They lean back slightly, almost like they’re reacting to a lighthearted comment or surprise. The background includes various plants and some artwork, suggesting a streaming or recording setup. The overall vibe is casual and a bit playful, as if they just heard something entertaining.",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "It appears to show someone with reddish hair and headphones sitting in front of a microphone. They lean back slightly, almost like they’re reacting to a lighthearted comment or surprise. The background includes various plants and some artwork, suggesting a streaming or recording setup. The overall vibe is casual and a bit playful, as if they just heard something entertaining."
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is an example of how one might represent the first 30×30 frame as an integer grid, in a style reminiscent of certain puzzle/ARC formats. Since I don’t have direct access to the exact pixel data, this is a mock-up (placeholder) showing the structure only. Each sub-array represents one row of the image, and each number could theoretically encode color or brightness:\n\n[\n[0,0,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2],\n[0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2],\n[1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1],\n[2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0],\n[0,2,1,0,0,3,3,0,2,1,0,2,1,0,0,3,3,0,2,1,0,2,1,0,0,3,3,0,2,1],\n[1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0],\n[2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1],\n[3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0],\n[2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0],\n[1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1],\n[0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2],\n[0,0,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2],\n[1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0],\n[2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1],\n[3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0],\n[2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0],\n[1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1],\n[0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2],\n[0,0,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2],\n[1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0],\n[2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1],\n[3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0],\n[2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0],\n[1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1,1,3,3,2,0,0,2,3,3,1],\n[0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2,2,1,0,0,1,2,2,3,3,3,2],\n[0,0,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2,2,0,3,3,1,1,0,2],\n[1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0,1,1,0,2,2,1,1,3,0,0],\n[2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1,2,3,3,1,1,0,2,3,3,1],\n[3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0,3,1,2,1,0,0,1,2,2,0],\n[2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0,2,2,3,1,1,1,1,3,1,0]\n]\n\n(Again, the numbers above are purely illustrative and do not reflect exact pixels. They simply demonstrate the 30×30 grid layout.)"
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is a 30×30 grid highlighting a portion of the scene (excluding any blurred subject). It’s shown here as a numeric matrix in a style similar to puzzle or “ARC”-type representations. These values are placeholders to demonstrate structure (not exact pixel data):\n\n[\n[1,1,2,2,3,3,2,2,3,3,4,4,3,1,1,1,0,0,0,1,2,2,3,3,2,2,1,1,0,0],\n[1,2,3,3,4,4,3,2,2,2,3,4,4,3,1,0,0,1,1,2,2,3,3,4,4,3,2,1,0,0],\n[2,3,4,4,4,3,2,1,0,1,2,3,3,4,4,2,1,1,2,2,3,4,4,4,3,1,1,0,0,0],\n[2,3,4,4,3,2,2,1,0,1,2,2,3,4,4,3,2,2,2,3,3,4,4,3,2,1,1,1,0,0],\n[3,4,4,3,2,1,0,0,0,0,1,2,2,3,3,2,2,3,3,3,2,3,4,4,2,1,1,1,0,0],\n[3,4,4,2,1,1,0,0,1,1,1,2,3,4,3,2,1,2,3,4,3,3,4,3,2,1,0,0,1,1],\n[2,3,3,2,1,0,0,1,2,2,2,2,3,4,4,3,2,2,2,3,4,4,4,3,2,1,0,0,1,2],\n[2,2,2,1,0,0,1,2,2,3,3,3,3,4,4,4,3,3,3,4,4,4,3,3,2,2,1,0,0,1],\n[3,3,2,1,0,1,2,3,3,4,4,4,4,4,3,3,3,3,4,4,4,3,3,2,2,1,0,0,0,0],\n[4,4,3,1,0,1,3,4,4,4,4,4,3,2,2,2,3,3,4,4,4,3,2,2,1,0,0,0,0,0],\n[4,4,3,2,1,2,3,3,4,3,3,3,2,1,1,1,2,3,3,3,3,2,1,1,0,0,0,0,0,0],\n[3,3,2,2,1,1,2,2,3,3,2,2,1,1,1,1,2,2,3,3,2,2,1,1,0,0,0,0,0,0],\n[2,2,1,1,0,0,1,2,3,4,3,2,1,1,1,1,2,3,4,3,2,1,1,0,0,0,0,0,0,0],\n[2,2,1,0,0,0,1,2,2,3,3,2,1,1,1,2,2,3,3,2,1,1,0,0,0,0,0,0,0,0],\n[3,3,2,1,0,1,2,3,3,4,4,3,2,3,3,3,3,4,4,3,2,2,1,0,0,0,0,0,0,0],\n[4,4,3,1,0,1,3,4,4,4,4,3,3,4,4,4,4,4,4,3,2,2,1,0,0,0,0,0,0,0],\n[4,4,3,1,0,1,3,4,3,3,3,2,3,4,4,3,3,3,3,2,2,2,1,0,0,0,0,0,0,0],\n[3,3,2,1,0,1,2,3,2,2,2,1,2,3,3,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0],\n[2,2,1,1,0,0,1,2,2,2,1,1,1,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0],\n[2,2,1,1,0,0,1,2,2,3,2,2,1,2,2,3,2,2,1,1,0,0,0,0,0,0,0,0,0,0],\n[3,2,2,1,0,0,1,3,3,3,2,2,1,2,3,3,2,2,1,1,0,0,0,0,0,0,0,0,0,0],\n[4,3,3,1,0,0,1,4,4,4,3,2,2,3,4,4,3,2,2,1,0,0,0,0,0,0,0,0,0,0],\n[4,3,3,2,1,1,2,4,4,4,3,2,2,4,4,4,3,2,2,1,0,0,0,0,0,0,0,0,0,0],\n[3,2,2,2,1,1,2,3,3,3,2,1,1,3,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0],\n[2,2,1,1,0,0,1,2,2,2,1,0,0,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[2,2,1,1,0,0,1,2,2,2,1,0,0,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[3,3,2,1,0,1,2,3,3,3,2,1,1,3,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0],\n[4,4,3,2,1,2,3,4,4,4,3,2,2,4,4,4,3,2,2,1,0,0,0,0,0,0,0,0,0,0],\n[4,4,3,2,1,2,3,4,4,4,3,2,2,4,4,4,3,2,2,1,0,0,0,0,0,0,0,0,0,0],\n[3,3,2,1,0,1,2,3,3,3,2,1,1,3,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0]\n]\n\nThe numbered entries serve as stand-ins for colors or brightness in the reduced-size section. This area shows some background details—minus any blurred subject—at a coarse resolution."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example of a small ARC‐style puzzle (max grid size 10×10) with three training input‐output pairs and one test input‐output pair. The core “analogy” is:\n\n• For each row whose index is even (0-based), add 2 to every cell in that row.  \n• Otherwise, leave the row unchanged.\n\n-------------------------------------------------------------------------------\n1) ARC-Like Task\n-------------------------------------------------------------------------------\n\"train\": [\n  {\n    \"input\": [\n      [0,0,1,1,2],\n      [0,1,1,1,2],\n      [3,2,2,2,2],\n      [3,2,2,3,4],\n      [0,0,0,0,1]\n    ],\n    \"output\": [\n      [2,2,3,3,4],\n      [0,1,1,1,2],\n      [5,4,4,4,4],\n      [3,2,2,3,4],\n      [2,2,2,2,3]\n    ]\n  },\n  {\n    \"input\": [\n      [0,2,4,4,5],\n      [1,1,1,1,1],\n      [5,5,5,5,5],\n      [8,8,7,7,6],\n      [2,1,0,0,0]\n    ],\n    \"output\": [\n      [2,4,6,6,7],\n      [1,1,1,1,1],\n      [7,7,7,7,7],\n      [8,8,7,7,6],\n      [4,3,2,2,2]\n    ]\n  },\n  {\n    \"input\": [\n      [5,5,3,3,8],\n      [7,7,7,7,7],\n      [9,9,8,8,1],\n      [3,0,0,2,2],\n      [1,1,1,1,1]\n    ],\n    \"output\": [\n      [7,7,5,5,10],\n      [7,7,7,7,7],\n      [11,11,10,10,3],\n      [3,0,0,2,2],\n      [3,3,3,3,3]\n    ]\n  }\n],\n\"test\": [\n  {\n    \"input\": [\n      [2,2,2,3,3],\n      [7,6,6,6,6],\n      [9,8,8,0,0],\n      [0,0,0,1,1],\n      [8,8,8,8,8]\n    ],\n    \"output\": [\n      [4,4,4,5,5],\n      [7,6,6,6,6],\n      [11,10,10,2,2],\n      [0,0,0,1,1],\n      [10,10,10,10,10]\n    ]\n  }\n]\n\n-------------------------------------------------------------------------------\n2) Analogy (Puzzle Description)\n-------------------------------------------------------------------------------\nFor each given 2D grid (≤10×10), examine every row.  \n• If the row’s index is even (0, 2, 4, …), add 2 to each cell in that row.  \n• If the row’s index is odd, leave it unchanged.\n\n-------------------------------------------------------------------------------\n3) Program with Hodel DSL\n-------------------------------------------------------------------------------\nBelow is one way to express the above transformation using some of Michael Hodel’s DSL functions. In particular, we use:\n• even(n)  → checks if n is even  \n• add(a,b) → adds two integers  \n\nAll other DSL functions shown (like subtract, multiply, etc.) are unused here.\n\n--------------------------------------------------------------------------------\nfrom arc_types import *\n\ndef solve(input_grid: Grid) -> Grid:\n    # Convert the input grid (a tuple of tuples) into something mutable\n    grid_list = [list(row) for row in input_grid]\n    \n    # For each row i in grid_list...\n    for i in range(len(grid_list)):\n        # Check if i is an even index using DSL 'even(i)'\n        if even(i):\n            # For each column j in this row, add 2 using DSL 'add'\n            for j in range(len(grid_list[i])):\n                grid_list[i][j] = add(grid_list[i][j], 2)\n    \n    # Convert back to a tuple of tuples before returning\n    return tuple(tuple(row) for row in grid_list)\n--------------------------------------------------------------------------------\n\nThat completes the puzzle specification, the illustrative analogy, and a possible implementation using the provided DSL."
        }
    ]
}