{
    "uuid": "26a48279-a420-44d0-9498-d6a9bb90e21e",
    "created": "2025-04-06 23:01:03",
    "description": "It shows three young women in a casual indoor setting. One is seated on the floor to the left, another is standing in the center wearing a flannel-style shirt, and the third is on the right wearing a black cardigan and braided hair. The woman in the center raises her arms and moves playfully, almost like sheâ€™s trying to tease or spook the woman on the right. The woman on the right reacts by turning away or laughing, while the seated woman watches. Overall, it comes across as a lighthearted, playful moment among the three.",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "It shows three young women in a casual indoor setting. One is seated on the floor to the left, another is standing in the center wearing a flannel-style shirt, and the third is on the right wearing a black cardigan and braided hair. The woman in the center raises her arms and moves playfully, almost like sheâ€™s trying to tease or spook the woman on the right. The woman on the right reacts by turning away or laughing, while the seated woman watches. Overall, it comes across as a lighthearted, playful moment among the three."
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is an illustrative (and very approximate) â€œARCâ€styleâ€ 30Ã—30 grid for just the first frame of the GIF.  \nI do NOT have pixelâ€level access to the GIF here, so Iâ€™m showing a madeâ€up example of how one might represent a downsampled image in a numeric grid.  \nIt uses integer â€œcolorâ€ codes (0â€“5) roughly indicating background (0), window (5), floor (1), and three â€œcharactersâ€ (2,3,4).  \nAgain, this is purely to demonstrate the format; it does not reflect the actual colors or shapes precisely.\n\n--------------------------------------------------------------------------------\nApproximate 30Ã—30 grid representation of â€œimage1â€:\n\nimage1 = [\n  # Rows 0 to 5: a â€˜windowâ€™ area on the left (code 5), then background (0)\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n\n  # Rows 6 to 17: all background (0)\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n\n  # Rows 18 and 19: â€˜standing personâ€™ columns 12..14 => 3\n  [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n\n  # Rows 20 and 21: standing person (3) & a right-side person (4)\n  [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,4,4,4,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,4,4,4,0,0,0,0],\n\n  # Rows 22 to 24: â€˜floorâ€™ (1) everywhere, override standing (3) & right person (4)\n  [1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1],\n\n  # Rows 25 to 27: floor (1), override columns 2..4 => 2 (a sitting person)\n  [1,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n\n  # Rows 28 and 29: all floor (1)\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n]\n\n--------------------------------------------------------------------------------\n\nIf you imagine each integer as a colored cell, this gives a rough idea of how one might â€œdownsampleâ€ or â€œabstractâ€ a frame into a 30Ã—30 grid. The important point is the format: you have 30 rows, each row is a list of 30 integers. This is akin to an ARCâ€style representation but without the usual â€œinput â†’ outputâ€ puzzle structure."
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is an example of how you might â€œhighlightâ€ (in a 30Ã—30 grid) the main people in the first GIF frame, using a special code (like 9) to mark the highlighted cells. This is still a toy/example matrix, not an actual downsample of the real GIF pixels. Iâ€™m simply reâ€using the previous 30Ã—30 layout, but anywhere I previously used â€œ3â€ or â€œ4â€ (those were the â€œcharactersâ€ in the scene), I now set them to â€œ9,â€ indicating a â€œhighlight.â€ Everything else remains the same.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nHighlighted 30Ã—30 grid for the first GIF frame (pseudoâ€downsample):\n\nimage1_highlighted = [\n  # Rows 0..5: window area (5), then background (0).\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  \n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n\n  # Rows 6..17: background (0).\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  \n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n\n  # Rows 18..19: highlighted â€œstanding personâ€ (9 instead of 3).\n  [0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n\n  # Rows 20..21: standing person (9) & right-side person (9 instead of 4).\n  [0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,0,0,0,0,0,0,0,0,9,9,9,0,0,0,0],\n  [0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,0,0,0,0,0,0,0,0,9,9,9,0,0,0,0],\n\n  # Rows 22..24: floor (1) with highlighted persons (9).\n  [1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1,1,1,9,9,9,1,1,1,1,1],\n\n  # Rows 25..27: floor (1), left-side sitting person highlighted (9 instead of 2).\n  [1,1,9,9,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,1,9,9,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,1,9,9,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n\n  # Rows 28..29: just floor (1).\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n]\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nIn this contrived example, all of the â€œpersonâ€ pixels (previously 3 or 4) are replaced by 9 so they stand outâ€”thatâ€™s the â€œhighlight.â€ You could similarly highlight just one character, or any subset of cells, by shifting them to a dedicated highlight code.  \n\nIf you wanted a literal rendered image from this grid, you could write a small script to map each integer to a color cell and render it (e.g., using Pythonâ€™s Pillow), but here Iâ€™m just providing the numeric matrix in plain text."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example â€œARCâ€likeâ€ puzzle (maximum 10Ã—10) with three training I/O pairs and one test I/O pair. The rule is:  \nâ€¢ Find the single nonâ€background object (color 1).  \nâ€¢ Shift that object one cell to the left.  \nâ€¢ Recolor all of its cells to color 2.  \n\nThen we paint that shifted, recolored object back onto the original grid (overwriting the old location). You can solve it using the provided Hodel DSL.  \n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1) ARCâ€like Task\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n{\n  \"train\": [\n    {\n      \"input\": [\n        [0,0,0,0,0],\n        [0,1,1,0,0],\n        [0,1,1,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ],\n      \"output\": [\n        [0,0,0,0,0],\n        [2,2,0,0,0],\n        [2,2,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ]\n    },\n    {\n      \"input\": [\n        [0,0,0,0,0,0],\n        [0,0,1,1,0,0],\n        [0,0,1,1,0,0],\n        [0,0,1,1,0,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0]\n      ],\n      \"output\": [\n        [0,0,2,2,0,0],\n        [0,0,2,2,0,0],\n        [0,0,2,2,0,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0]\n      ]\n    },\n    {\n      \"input\": [\n        [0,1,1,0],\n        [0,1,1,0],\n        [0,1,1,0],\n        [0,0,0,0]\n      ],\n      \"output\": [\n        [2,2,0,0],\n        [2,2,0,0],\n        [2,2,0,0],\n        [0,0,0,0]\n      ]\n    }\n  ],\n  \"test\": [\n    {\n      \"input\": [\n        [0,0,1,0,0],\n        [0,0,1,0,0],\n        [0,0,1,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ],\n      \"output\": [\n        [2,0,0,0,0],\n        [2,0,0,0,0],\n        [2,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ]\n    }\n  ]\n}\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n2) Analogy of the Task\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ€œLook for the single patch of color 1, remove it from the grid, shift it left by one column, recolor it to 2, then repaint it onto the grid.â€  \n\nIn all training and test examples, there is exactly one â€œforegroundâ€ patch of 1â€™s. The background is 0. We shift â€œ1â€™sâ€ left one unit, recolor them as 2, and place them back.  \n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n3) Example Program Using Michael Hodelâ€™s DSL\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nBelow is a minimal â€œsolutionâ€ function that implements the described transformation:\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfrom arc_types import *\n \ndef solve_puzzle(input_grid: Grid) -> Grid:\n    # 1) Identify foreground objects, ignoring the main background\n    #    We treat â€œgrid backgroundâ€ as the most common color, then skip it.\n    #    univalued=True, diagonal=True, without_bg=True => each distinct color forms its own object.\n    objset = objects(input_grid, True, True, True)\n    \n    # 2) Get the single object from the set\n    theobj = first(objset)\n    \n    # 3) Shift that object left by 1 (down=0, left=-1)\n    shifted_obj = shift(theobj, (0, -1))\n    \n    # 4) Recolor the object to color 2\n    recolored_obj = recolor(2, shifted_obj)\n    \n    # 5) â€œCoverâ€ the old objectâ€™s location with background\n    covered_grid = cover(input_grid, theobj)\n    \n    # 6) Paint the recolored object onto the covered grid\n    output_grid = paint(covered_grid, recolored_obj)\n    \n    return output_grid\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nExplanation of Key DSL Steps:  \nâ€¢ objects(input_grid, True, True, True) collects distinct patches of any color except the background.  \nâ€¢ first(objset) gets the unique patch (color 1).  \nâ€¢ shift(theobj, (0, â€1)) moves that patch left by 1 column.  \nâ€¢ recolor(2, â€¦) changes that entire patch to color 2.  \nâ€¢ cover(input_grid, theobj) â€œerasesâ€ the old location by filling it with the background color (mostcolor).  \nâ€¢ paint(covered_grid, recolored_obj) draws the newly shifted patch on top.  \n\nThis procedure solves all three training grids and yields the correct output. Applying it to the testâ€case grid yields the indicated output as well."
        }
    ]
}