{
    "uuid": "443b0316-0bb3-4821-95da-13eb36b525c5",
    "created": "2025-04-06 23:03:14",
    "description": "It shows someone enthusiastically pumping their arms while the words “YES YES YES” appear at the bottom. The motion and text convey excitement, approval, or celebration—often used as a reaction to good news or a triumphant moment.",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "It shows someone enthusiastically pumping their arms while the words “YES YES YES” appear at the bottom. The motion and text convey excitement, approval, or celebration—often used as a reaction to good news or a triumphant moment."
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is a purely illustrative 30×30 grid-style representation (in a format loosely inspired by ARC) of the first frame, using small integer “color codes.” This is an approximation, since I don’t have direct access to the exact pixel data. Each row in the array below has 30 entries:\n\n[\n[0,0,0,0,0,0,0,0,1,1,1,2,2,2,2,3,3,3,3,3,2,2,2,1,1,1,0,0,0,0],\n[0,0,0,0,0,0,0,0,1,1,1,2,2,2,2,3,3,4,3,3,2,2,2,1,1,1,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,2,2,2,2,3,3,4,4,4,3,2,2,2,1,1,0,0,0,0,0],\n[0,0,0,0,0,0,1,1,1,2,2,2,2,3,3,4,4,4,4,3,2,2,1,1,1,0,0,0,0,0],\n[0,0,0,0,0,1,1,1,2,2,2,2,3,3,4,4,4,4,4,3,2,2,1,1,1,0,0,0,0,0],\n[0,0,0,0,1,1,1,2,2,2,2,3,3,4,4,4,5,4,4,4,3,2,2,1,1,1,0,0,0,0],\n[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,4,4,4,3,2,2,2,1,1,0,0,0,0],\n[0,0,0,1,1,2,2,2,3,3,3,4,4,4,5,5,5,5,4,4,3,2,2,2,1,1,0,0,0,0],\n[0,0,1,1,2,2,2,3,3,3,4,4,4,5,5,5,5,5,4,4,3,3,2,2,1,1,0,0,0,0],\n[0,0,1,2,2,2,3,3,3,4,4,4,5,5,5,5,5,5,4,4,3,3,3,2,2,1,1,0,0,0],\n[0,0,1,2,2,3,3,3,4,4,4,5,5,5,5,6,5,5,4,4,3,3,3,2,2,1,1,0,0,0],\n[0,1,1,2,3,3,3,4,4,4,5,5,5,5,6,6,6,5,5,4,3,3,3,2,1,1,1,0,0,0],\n[0,1,2,2,3,3,4,4,4,5,5,5,5,6,6,6,6,6,5,4,4,3,2,2,1,1,1,0,0,0],\n[0,1,2,3,3,3,4,4,5,5,5,5,6,6,6,7,6,6,5,4,4,3,3,2,1,1,1,0,0,0],\n[0,1,2,3,3,4,4,5,5,5,5,6,6,6,7,7,7,6,5,4,4,3,3,2,1,1,0,0,0,0],\n[0,1,2,3,4,4,5,5,5,5,6,6,6,7,7,7,7,7,5,4,3,3,2,2,1,1,0,0,0,0],\n[0,1,2,3,4,5,5,5,5,6,6,6,7,7,7,7,7,7,6,4,3,2,2,2,1,1,0,0,0,0],\n[0,1,2,3,4,5,5,5,6,6,6,7,7,7,7,7,8,7,6,4,3,2,2,1,1,1,0,0,0,0],\n[0,1,2,4,4,5,5,6,6,6,7,7,7,7,8,8,8,7,6,4,3,2,2,1,1,1,0,0,0,0],\n[0,1,2,4,5,5,6,6,7,7,7,7,7,8,8,8,8,7,5,4,3,2,1,1,1,0,0,0,0,0],\n[0,1,2,4,5,5,6,6,7,7,7,7,8,8,8,8,8,7,5,4,3,2,1,1,1,0,0,0,0,0],\n[0,1,3,4,5,6,6,6,7,7,7,8,8,8,8,8,8,7,5,4,3,2,2,1,1,0,0,0,0,0],\n[0,1,3,4,5,6,6,7,7,7,7,8,8,9,8,8,8,7,5,4,3,2,2,1,1,0,0,0,0,0],\n[0,1,3,4,6,6,7,7,7,7,8,8,8,9,8,8,8,7,5,4,3,2,2,1,1,0,0,0,0,0],\n[0,1,3,4,6,6,7,7,8,8,8,8,9,9,9,8,7,7,5,4,3,2,1,1,1,0,0,0,0,0],\n[0,1,3,4,6,7,7,7,8,8,8,9,9,9,9,8,7,7,5,4,3,2,1,1,0,0,0,0,0,0],\n[0,1,2,4,6,7,7,8,8,8,9,9,9,9,9,8,7,7,5,4,3,2,1,1,0,0,0,0,0,0],\n[0,0,2,4,6,7,8,8,8,9,9,9,9,9,9,8,7,6,5,4,3,2,1,1,0,0,0,0,0,0],\n[0,0,2,4,6,8,8,8,9,9,9,9,9,9,9,8,7,6,4,4,3,2,1,0,0,0,0,0,0,0],\n[0,0,2,4,6,8,8,8,9,9,9,9,9,9,9,8,6,6,4,3,3,1,1,0,0,0,0,0,0,0]\n]\n\nAbove, each number is a placeholder color ID (not referencing any face), compressed down to 30×30. The larger or smaller any value, the lighter or darker (or possibly differently hued) that portion might be."
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is an approximate 30×30 grid focusing on a highlighted lower portion of the GIF (where the text “YES YES YES” appears). This numeric array is a simplified “pixel” map, using small integers for different color/shading levels. It doesn’t reference or include any blurred face:\n\n[\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  1\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  2\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  3\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  4\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  5\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  6\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  7\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  8\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  //  9\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 10\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 11\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 12\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 13\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 14\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 15\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 16\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 17\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 18\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 19\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 20\n[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],  // 21  (start of text area)\n[0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],  // 22  (middle of letters)\n[0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],  // 23\n[0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0],  // 24\n[0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 25\n[0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 26\n[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 27  (end of letters, rough outline)\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 28\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  // 29\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]   // 30\n]\n\n• 0 → Background  \n• 1 → Faint outline/shading  \n• 2 → Brighter “letter” pixels  \n\nThis is just a small highlight of the GIF’s lower region, showing where “YES YES YES” might appear in a stylized, grid-based format—omitting any blurred areas."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example of an ARC‐style problem, limited to 5×5 grids for clarity and sized well within the 10×10 maximum. The rule is: “Find the non‐background shape (color ≠ 0) and shift it so that its upper‐left corner becomes the grid’s upper‐left corner.” The puzzle has three training (input‐output) pairs plus one test pair.  \n\n────────────────────────────────────────────────────\n1) ARC‐LIKE TASK  \n────────────────────────────────────────────────────\n\n{\n  \"train\": [\n    {\n      \"input\": [\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,8,8,0],\n        [0,0,8,0,0]\n      ],\n      \"output\": [\n        [8,8,0,0,0],\n        [8,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ]\n    },\n    {\n      \"input\": [\n        [0,0,0,0,0],\n        [0,0,0,0,8],\n        [0,0,0,0,8],\n        [0,0,0,0,8],\n        [0,0,0,0,0]\n      ],\n      \"output\": [\n        [8,0,0,0,0],\n        [8,0,0,0,0],\n        [8,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ]\n    },\n    {\n      \"input\": [\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,8,8,8,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ],\n      \"output\": [\n        [8,8,8,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ]\n    }\n  ],\n  \"test\": [\n    {\n      \"input\": [\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [8,0,0,0,0],\n        [8,8,0,0,0]\n      ],\n      \"output\": [\n        [8,8,0,0,0],\n        [8,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0]\n      ]\n    }\n  ]\n}\n\n────────────────────────────────────────────────────\n2) ANALOGY / RULE EXPLANATION  \n────────────────────────────────────────────────────\n\nFor each 5×5 grid, exactly one shape (colored “8”) appears. The solution is to “normalize” that shape so that its uppermost and leftmost occupied cell coincide with the grid’s upper‐left corner (row = 0, column = 0). The rest of the grid becomes 0 (background).\n\nIn ARC terms:  \n• Identify the foreground object (all cells where value ≠ 0).  \n• Compute how far it is from the top‐left corner of the grid.  \n• Shift/“normalize” it so its own upper‐left corner becomes (0,0).  \n• Paint that normalized shape onto a blank 5×5 grid (color 0).  \n\n────────────────────────────────────────────────────\n3) ILLUSTRATIVE DSL PROGRAM  \n────────────────────────────────────────────────────\n\nBelow is a sketch in Michael Hodel’s DSL, following the above logic.  \nYou could adapt it if needed—this is just one possible approach (some calls are illustrative, not strictly required to run in a real ARC environment).\n\n--------------------------------------------------------------------------------\nfrom arc_types import *\n\ndef solve(grid: Grid) -> Grid:\n    # 1. Identify all non-background objects (univalued=True, diagonal=False, without_bg=True).\n    objset = objects(grid, True, False, True)\n    \n    # 2. Grab the first (and only) foreground shape.\n    shape = first(objset)\n    \n    # 3. Normalize shape so that its upper-left corner is (0,0).\n    normed_shape = normalize(shape)\n    \n    # 4. Create a blank 5x5 canvas of color 0.\n    blank_canvas = canvas(0, (5,5))\n    \n    # 5. Paint the normalized shape onto the blank canvas.  \n    output_grid = paint(blank_canvas, normed_shape)\n    \n    return output_grid\n--------------------------------------------------------------------------------\n\nExplanation of Steps:  \n• objects(grid, True, False, True) finds all connected patches (diagonal=False) that are not in the most common “background” color.  \n• first(...) just picks the single relevant shape.  \n• normalize(...) shifts that shape so its upper‐left cell is at (0,0).  \n• canvas(0, (5,5)) is a new 5×5 grid of zeros.  \n• paint(...) places the shape’s color‐indexed cells onto the new grid.  \n\nThis completes the sample ARC‐style puzzle, along with an illustrative DSL solution."
        }
    ]
}