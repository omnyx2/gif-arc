{
    "uuid": "62d4898c-43b5-478f-b690-0289f6ccc62e",
    "created": "2025-04-07 00:46:36",
    "description": "This GIF shows someone enthusiastically dancing while the words “YES YES YES” appear at the bottom. It’s commonly used as a fun, celebratory reaction to express excitement and agreement—almost like a victory dance to say “Absolutely!” or “I’m all in.”",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "This GIF shows someone enthusiastically dancing while the words “YES YES YES” appear at the bottom. It’s commonly used as a fun, celebratory reaction to express excitement and agreement—almost like a victory dance to say “Absolutely!” or “I’m all in.”"
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is a purely illustrative 30×30 grid-style array for the first frame, inspired by the Abstraction and Reasoning Corpus format. Because I don’t have direct pixel-level access to the actual GIF, this matrix is a synthetic (made-up) example to show how one might represent a 120×120 image downsampled to 30×30. Each entry could stand for a color or intensity value (0–9 in this example).\n\n[\n[8,4,1,9,2,0,9,4,4,2,1,6,8,2,9,7,2,3,0,1,1,6,7,3,3,8,8,7,1,2],\n[3,7,1,1,6,7,2,9,6,5,4,8,4,5,3,6,0,0,3,2,7,1,4,0,2,3,9,8,4,3],\n[5,6,1,9,0,6,4,3,0,2,3,3,9,8,1,7,8,2,5,1,5,1,0,7,6,9,8,4,1,6],\n[0,8,3,7,6,6,2,8,4,5,9,0,3,3,7,8,5,9,7,5,9,2,3,3,3,6,2,8,7,7],\n[9,9,2,6,4,2,2,0,8,1,4,8,1,7,9,4,3,2,5,8,0,9,9,2,4,4,8,6,6,3],\n[1,3,1,5,6,7,8,5,9,0,6,1,8,4,2,9,9,2,0,2,7,5,4,7,9,3,1,1,4,7],\n[2,2,4,4,7,4,6,3,0,2,4,9,2,8,6,5,6,9,7,4,4,5,3,1,3,0,9,0,8,9],\n[5,8,9,7,1,1,2,0,2,1,1,7,4,3,3,0,1,8,2,2,6,8,7,9,6,7,5,2,3,4],\n[2,4,3,0,0,6,5,9,8,4,8,2,5,7,2,4,4,9,6,1,8,2,2,9,1,7,5,3,0,0],\n[7,8,6,8,3,4,0,0,9,3,6,1,0,2,6,8,7,4,4,3,7,3,1,7,2,1,5,6,9,9],\n[9,2,4,5,4,8,2,1,6,6,1,1,8,9,7,9,2,0,8,8,3,2,5,2,9,5,0,1,7,4],\n[6,4,2,1,8,7,0,6,1,5,3,2,7,3,0,2,3,2,4,3,9,9,4,8,6,6,1,8,8,7],\n[3,7,3,7,1,3,3,2,5,1,5,0,3,7,0,6,9,0,4,7,7,3,5,4,4,9,5,7,8,3],\n[4,2,2,9,0,2,2,8,1,3,5,6,2,2,9,0,1,2,7,3,2,4,8,7,9,6,0,3,4,5],\n[0,3,9,4,7,2,1,6,7,7,8,5,4,2,2,1,1,6,5,4,6,5,0,8,4,3,2,2,0,6],\n[8,6,4,2,8,0,8,8,2,9,8,5,9,7,6,2,4,0,0,1,5,2,8,9,7,4,6,5,2,3],\n[7,0,1,3,6,9,5,1,9,3,0,2,5,2,3,6,1,7,0,2,3,9,6,1,9,1,0,6,3,4],\n[9,6,5,7,7,2,6,2,1,1,4,8,3,1,9,4,1,1,8,5,3,8,2,6,5,5,8,7,6,8],\n[1,8,1,4,0,9,0,9,5,6,2,6,2,1,1,3,3,5,6,2,6,2,3,4,0,6,3,8,9,1],\n[2,9,8,0,2,3,4,0,5,8,1,3,7,7,9,4,4,5,2,9,4,8,0,7,1,0,5,4,2,0],\n[6,8,4,1,9,4,2,5,5,9,0,1,8,6,3,3,6,5,7,2,2,2,7,1,3,8,8,0,0,4],\n[6,4,2,8,8,2,2,1,4,5,2,2,9,7,6,9,8,1,1,4,8,4,0,5,6,2,2,6,3,2],\n[8,7,9,7,4,3,6,0,0,8,0,3,5,3,4,6,6,3,5,9,7,8,2,3,9,1,1,0,2,5],\n[5,3,5,0,1,8,4,8,8,4,4,5,9,7,7,5,2,1,6,3,0,2,5,6,5,9,2,9,8,6],\n[4,8,0,2,5,4,6,2,7,9,1,1,0,4,4,7,0,0,2,2,5,0,3,9,8,5,5,0,6,4],\n[3,2,4,9,7,1,2,3,1,9,4,0,6,0,3,8,8,6,4,7,3,1,0,1,7,2,4,5,9,7],\n[7,9,1,6,2,9,8,4,0,5,6,7,3,0,1,2,8,7,9,9,8,3,6,4,5,8,4,1,2,1],\n[8,2,0,0,0,4,2,4,2,9,8,6,0,0,8,2,3,6,7,1,1,6,2,5,3,3,5,2,4,3],\n[9,7,3,2,5,3,0,8,8,4,1,1,1,4,8,6,2,0,7,2,3,9,0,0,3,2,6,9,8,0],\n[1,6,3,4,9,4,2,7,6,8,1,2,3,5,3,9,9,0,7,5,6,8,2,3,0,1,6,2,9,9]\n]\n\n┈┈┈\n• Each sub-array is one row of pixels.  \n• Numbers are placeholders (0–9) for color/intensity values.  \n• This does not represent the true pixels of the GIF; it’s just a hypothetical downsampled layout example."
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is a purely illustrative 30×30 grid that represents a “highlight” segment of the GIF at a much coarser resolution (similar to an ARC-style grid). As before, these numbers are arbitrary placeholders (0–9) for color or intensity values; they do not map to the real pixels of the original GIF. The idea is just to show how one might encode a small region (the part with text or visible motion) in a 30×30 matrix.\n\n30×30 Highlight Matrix (synthetic example):\n\n[\n[0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,2,2,2,2,2,0,0,0,8,8,8,0,0,0],\n[0,0,0,0,1,1,0,2,3,3,3,3,3,2,0,0,2,2,3,3,2,0,0,8,8,8,8,0,0,0],\n[0,0,1,1,3,3,3,3,4,4,4,4,4,3,3,2,2,3,4,3,3,1,8,8,8,9,8,0,0,0],\n[0,0,1,3,3,4,4,4,4,4,4,4,4,4,3,3,3,4,4,3,1,3,8,8,9,9,9,8,0,0],\n[0,1,3,3,4,4,7,7,4,4,4,4,7,4,4,4,4,4,3,3,3,2,8,8,9,9,8,8,0,0],\n[0,2,3,4,4,7,7,7,7,7,7,7,7,7,4,4,4,3,3,2,2,2,8,8,8,9,9,8,0,0],\n[2,3,4,4,7,7,7,9,9,9,7,7,7,7,7,4,4,3,3,3,2,8,8,8,9,9,9,8,0,0],\n[3,3,4,7,7,9,9,9,9,9,9,9,7,7,7,4,4,4,3,3,3,8,8,9,9,9,8,8,2,0],\n[4,4,7,7,9,9,9,9,9,9,9,9,9,7,7,7,4,4,3,3,2,8,9,9,9,8,8,2,2,0],\n[4,7,7,9,9,9,9,9,9,9,9,9,9,9,7,7,4,3,3,3,8,8,9,9,8,8,2,2,1,0],\n[4,7,9,9,9,9,9,9,9,9,9,9,9,9,9,7,4,3,3,8,8,9,9,9,8,2,2,1,1,0],\n[4,7,9,9,9,9,9,9,9,9,9,9,9,9,9,7,4,3,8,8,9,9,8,2,2,1,1,1,0,0],\n[4,7,7,9,9,9,9,9,9,9,9,9,9,9,7,7,4,2,8,9,9,8,2,2,1,1,1,0,0,0],\n[3,4,7,7,9,9,9,9,9,9,9,9,9,7,7,4,4,2,8,8,8,2,2,1,1,1,0,0,0,0],\n[3,3,4,7,7,9,9,9,9,9,9,9,7,7,4,4,3,2,2,8,2,2,1,1,1,0,0,0,0,0],\n[2,3,3,4,4,7,7,7,9,9,9,7,7,4,4,3,3,2,2,2,2,1,1,1,0,0,0,0,0,0],\n[2,2,3,3,3,4,7,7,7,7,7,7,4,4,3,3,2,2,2,1,1,1,0,0,0,0,0,0,0,0],\n[0,2,2,3,3,4,4,4,7,7,7,4,4,3,3,3,2,2,1,1,1,0,0,0,0,0,0,0,0,0],\n[0,0,2,2,3,3,3,4,4,4,4,3,3,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,2,2,3,3,3,3,3,3,2,2,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,2,2,2,3,3,2,2,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n]\n\nKey points:\n• Each row is 30 elements wide, for a total of 30 rows.\n• Numerical values (0–9) are placeholder intensities or colors hinting at a region with noticeable text or action.\n• Because this is a synthetic matrix, it’s just to illustrate how you might represent the “highlight” region in a coarse grid—this does not reflect any actual pixel values from the GIF."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example of an ARC-style task (with 3 training pairs and 1 test pair), an explanation (“analogy”), and a minimal solution program in Michael Hodel’s DSL. Each grid is at most 10×10 in size.\n\n────────────────────────────────────────────────────────\n1) ARC-STYLE TASK\n────────────────────────────────────────────────────────\n\nWe have four Input→Output pairs (three for training, one as a test).  \nThe goal is to learn the transformation that takes each Input grid to its corresponding Output grid.\n\n────────────────────────────────────────────────────────\nTRAIN #1\n────────────────────────────────────────────────────────\nInput (3×3):\n[\n  [0, 0, 1],\n  [2, 2, 2],\n  [1, 0, 0]\n]\n\nOutput (3×3):\n[\n  [1, 0, 0],\n  [2, 2, 2],\n  [0, 0, 1]\n]\n\n────────────────────────────────────────────────────────\nTRAIN #2\n────────────────────────────────────────────────────────\nInput (3×3):\n[\n  [3, 9, 1],\n  [0, 0, 1],\n  [5, 5, 5]\n]\n\nOutput (3×3):\n[\n  [1, 9, 3],\n  [1, 0, 0],\n  [5, 5, 5]\n]\n\n────────────────────────────────────────────────────────\nTRAIN #3\n────────────────────────────────────────────────────────\nInput (3×4):\n[\n  [1, 1, 2, 2],\n  [9, 0, 0, 9],\n  [3, 3, 7, 2]\n]\n\nOutput (3×4):\n[\n  [2, 2, 1, 1],\n  [9, 0, 0, 9],\n  [2, 7, 3, 3]\n]\n\n────────────────────────────────────────────────────────\nTEST #1\n────────────────────────────────────────────────────────\nInput (2×4):\n[\n  [1, 0, 5, 9],\n  [9, 0, 0, 1]\n]\n\nOutput (2×4):\n[\n  [9, 5, 0, 1],\n  [1, 0, 0, 9]\n]\n\n────────────────────────────────────────────────────────\n2) ANALOGY (EXPLANATION)\n────────────────────────────────────────────────────────\n\nObserving the examples, the solution is to take each row of the input grid and reverse it left-to-right. In ARC terminology, this is known as a “vertical mirror” because we reflect along a vertical axis through the center of each row.\n\n────────────────────────────────────────────────────────\n3) SOLUTION PROGRAM (Hodel DSL)\n────────────────────────────────────────────────────────\n\nBelow is a minimal DSL-based function that takes a grid and returns its vertically mirrored version. It uses the “vmirror” function provided in the DSL:\n\n--------------------------------------------------------------------------------\nfrom arc_types import *\n# … plus the rest of the DSL definitions as given …\n\ndef solve(grid: Grid) -> Grid:\n    \"\"\"\n    Mirror the grid along its vertical axis, i.e., \n    reverse left and right columns in every row.\n    \"\"\"\n    return vmirror(grid)\n--------------------------------------------------------------------------------\n\nExplanation of the code:  \n• vmirror(grid) flips each row of the grid from left to right.  \n• The same rule (vmirror) applies consistently to all input grids in this ARC-like task, producing each correct output."
        }
    ]
}