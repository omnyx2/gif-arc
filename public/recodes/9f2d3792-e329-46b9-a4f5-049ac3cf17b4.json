{
    "uuid": "9f2d3792-e329-46b9-a4f5-049ac3cf17b4",
    "created": "2025-04-06 23:24:27",
    "description": "It’s a short, looping birthday greeting. The main feature is a smiling party emoji wearing a red cone hat. Confetti pieces move around it, and there’s text above and below that reads “HAPPY BIRTHDAY STACEY!” and “HAVE AN AWESOME DAY.” Essentially, it’s just a playful animated way to wish someone named Stacey a happy birthday.",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "It’s a short, looping birthday greeting. The main feature is a smiling party emoji wearing a red cone hat. Confetti pieces move around it, and there’s text above and below that reads “HAPPY BIRTHDAY STACEY!” and “HAVE AN AWESOME DAY.” Essentially, it’s just a playful animated way to wish someone named Stacey a happy birthday."
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is an approximate “30×30” downsample‐style grid for the first frame, represented as a list of 30 strings. Each string is exactly 30 characters wide. Legend (roughly):  \n• '.' = background  \n• 'C' = confetti or corner decoration  \n• 'R' = party hat region  \n• 'Y' = yellow face  \n• 'E' = eye  \n• 'M' = mouth  \n\nThis is purely illustrative (not exact pixel data) but shows how one might encode a 30×30 version of the first GIF frame:\n\n[\n\"CCC............................CCC\",  # Row 0\n\"CCC............................CCC\",  # Row 1\n\"CCC............................CCC\",  # Row 2\n\"C..............................C\",    # Row 3\n\"C..............................C\",    # Row 4\n\"C..............................C\",    # Row 5\n\"C..............................C\",    # Row 6\n\"C............RRRRR............C\",    # Row 7\n\"C............RRRRR............C\",    # Row 8\n\"C............RRRRR............C\",    # Row 9\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 10\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 11\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 12\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 13\n\"C....YYYYYEYYYYYYYYYEYYYY....C\",      # Row 14 (eyes in the middle)\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 15\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 16\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 17\n\"C....YYYYYMMMMMMMMMMMYYYY....C\",      # Row 18 (mouth in the middle)\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 19\n\"C....YYYYYYYYYYYYYYYYYYYY....C\",      # Row 20\n\"C..............................C\",    # Row 21\n\"C..............................C\",    # Row 22\n\"C..............................C\",    # Row 23\n\"C..............................C\",    # Row 24\n\"C..............................C\",    # Row 25\n\"C..............................C\",    # Row 26\n\"CCC............................CCC\",  # Row 27\n\"CCC............................CCC\",  # Row 28\n\"CCC............................CCC\"   # Row 29\n]\n\nAll together, that forms a notional 30×30 “undersized” version of the GIF’s first frame."
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is an example of how you might “highlight” certain parts of the same 30×30 grid. Let’s assume we want to emphasize:  \n• The party hat (rows ~7–9)  \n• The face (rows ~10–20)  \n• Confetti at the corners (rows ~0–2, columns ~0–2 or ~27–29, etc.)\n\nI’ll use “H” where we want highlights, and “.” for everything else. This is just artistic interpretation—feel free to tweak it:\n\n--------------------------------------------------------------------------------\n1) Matrix (as a list of 30 strings, each 30 characters):\n\nhighlight_matrix = [\n\"HHH............................HHH\",  # Row 0 (confetti)\n\"HHH............................HHH\",  # Row 1 (confetti)\n\"HHH............................HHH\",  # Row 2 (confetti)\n\"H..............................H\",    # Row 3\n\"H..............................H\",    # Row 4\n\"H..............................H\",    # Row 5\n\"H..............................H\",    # Row 6\n\"H............HHHHH............H\",    # Row 7 (party hat)\n\"H............HHHHH............H\",    # Row 8 (party hat)\n\"H............HHHHH............H\",    # Row 9 (party hat)\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 10 (face region)\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 11\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 12\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 13\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 14\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 15\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 16\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 17\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 18\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 19\n\"H....HHHHHHHHHHHHHHHHHHHH....H\",      # Row 20\n\"H..............................H\",    # Row 21\n\"H..............................H\",    # Row 22\n\"H..............................H\",    # Row 23\n\"H..............................H\",    # Row 24\n\"H..............................H\",    # Row 25\n\"H..............................H\",    # Row 26\n\"HHH............................HHH\",  # Row 27\n\"HHH............................HHH\",  # Row 28\n\"HHH............................HHH\"   # Row 29\n]\n\n--------------------------------------------------------------------------------\n2) Simple ASCII “image” preview:\n\nBelow is just the 30 lines printed out. You’ll see “H” in the highlighted regions and “.” for everything else:\n\nHHH............................HHH\nHHH............................HHH\nHHH............................HHH\nH..............................H\nH..............................H\nH..............................H\nH..............................H\nH............HHHHH............H\nH............HHHHH............H\nH............HHHHH............H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH....HHHHHHHHHHHHHHHHHHHH....H\nH..............................H\nH..............................H\nH..............................H\nH..............................H\nH..............................H\nH..............................H\nHHH............................HHH\nHHH............................HHH\nHHH............................HHH\n\n--------------------------------------------------------------------------------\nThis layout conceptually highlights the “important” or “festive” parts of the GIF (the corners/confetti, the party hat, and face). Of course, the actual downsampled data would differ depending on the image processing method (nearest neighbor, bilinear, etc.), but this shows a notional approach."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example ARC‐style puzzle, capped at 4×4 grids for simplicity. The rule is: “Replace all zeros in the input grid with the value 5.”\n\n────────────────────────────────────────────────────────\n1) ARC‐like Task Definition (3 training pairs + 1 test)\n\n{\n  \"train\": [\n    {\n      \"input\": [\n        [0, 1, 0, 2],\n        [2, 2, 0, 1],\n        [0, 3, 3, 0],\n        [1, 0, 2, 0]\n      ],\n      \"output\": [\n        [5, 1, 5, 2],\n        [2, 2, 5, 1],\n        [5, 3, 3, 5],\n        [1, 5, 2, 5]\n      ]\n    },\n    {\n      \"input\": [\n        [0, 0, 1, 1],\n        [1, 2, 2, 0],\n        [0, 1, 2, 0],\n        [2, 0, 1, 3]\n      ],\n      \"output\": [\n        [5, 5, 1, 1],\n        [1, 2, 2, 5],\n        [5, 1, 2, 5],\n        [2, 5, 1, 3]\n      ]\n    },\n    {\n      \"input\": [\n        [1, 3, 0, 0],\n        [2, 1, 1, 0],\n        [0, 2, 3, 1],\n        [0, 1, 2, 0]\n      ],\n      \"output\": [\n        [1, 3, 5, 5],\n        [2, 1, 1, 5],\n        [5, 2, 3, 1],\n        [5, 1, 2, 5]\n      ]\n    }\n  ],\n  \"test\": [\n    {\n      \"input\": [\n        [2, 0, 0, 1],\n        [0, 1, 3, 1],\n        [2, 0, 0, 0],\n        [1, 3, 1, 0]\n      ],\n      \"output\": [\n        [2, 5, 5, 1],\n        [5, 1, 3, 1],\n        [2, 5, 5, 5],\n        [1, 3, 1, 5]\n      ]\n    }\n  ]\n}\n\n────────────────────────────────────────────────────────\n2) Analogy / Explanation\n\nIn all training examples, every cell that was color “0” becomes color “5” in the output. Other numbers remain unchanged. The same transformation applies to the test pair.\n\n────────────────────────────────────────────────────────\n3) Hodel DSL Program\n\nBelow is a minimal “solution” function that uses one of the provided DSL utilities (replace) to convert 0 → 5:\n\n--------------------------------------------------------------------------------\nfrom arc_types import Grid\nfrom arc_types import replace\n\ndef solve(input_grid: Grid) -> Grid:\n    \"\"\"\n    Replace all 0's with 5 using the DSL function 'replace'.\n    \"\"\"\n    return replace(input_grid, 0, 5)\n--------------------------------------------------------------------------------\n\nThis completes the ARC‐style puzzle definition, its key insight (“all zeros become fives”), and a direct DSL‐based solution."
        }
    ]
}