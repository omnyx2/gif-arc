{
    "uuid": "a885eed8-88b7-4ef0-a224-629be473d8b8",
    "created": "2025-04-07 00:31:43",
    "description": "It’s a short, festive clip that displays the message “Welcome Haryana Happy Teej” amid bright, colorful imagery suggestive of celebration. “Happy Teej” refers to a festival observed in parts of India—particularly in places like Haryana—to welcome the monsoon season. People often share such cheerful graphics or GIFs as festive greetings to mark the occasion.",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,R0lGODlhRAB4AIcfAAMFAOm4qM+YiThGL9emkhIWCcSJdC84KKa4yO/FuI0qTrV4arLF2ElVN8XY6O/Kx/HWz65oU481UZQ4Z8qTe61FdPDp5ycnGE9XSlhmSuKrmExJMCk1G5BJNJFWSqlZS3Bnam12TtCorI+IjBsiE29XU/JHh/b08a6nq3E2TfBnmqY8bHJ3baooUrNUhuyIrFRHTW9JTG4pMHcoSrjO4W9XbKlHL7iFc5inudO2srzR5I92ck85Me2WttLj7iosJ5aVkK5ULvI1fPFWkHI4M2xINa6WllIoK1U3TeSxnfPh2WtXL8Z5bfN3ps2JhmpnTZFFTiYaEos4MI54LOemss+Yq7BzWpBHcvUqdpZkVK1pa6+Jj003F6tFTsVZi6o7LVJkOo1XcbObpI5obnJmMa5njMlnlJCXp6dnFrKWM+6pw3qEb5RUNY94hIeFdKMmG87Jx3iFV6s2VXJKbZCXaq0lLq+HL4lKFZSEMfU7gVNHGZhXFYqJUKpXa7O1scZpV+62yzRCG4x2U5yuwJ6wwk4lF6tVGc5ZK1Vnanh5MZFpg5OWT8xJLslIafproXiFlIppLLZNgrF6KMNyWtDFu+Zzms1yodaGpsaVMm0qGcdUSMlkMNHT0G4bLnc2GKt2k8Y4L8p3kOaUl1EXJW5UG44oMNBWd9G8w+WJk1xVZHZjHZdWgZNoGZiibJijjrmjNa6nTa+mlLrGuMs7a8l1GdChdu3b4T9SPUwTFlpMYnJJF6wdIsgpZcs6UNaEHN2xmx4tJD1IQDpXVHp6ioweQpMtHbMtYqhpLrhzHKmJQbaHoreUdKakd6WyicMsV8ZKS8arUMi0NysJE0sPGl8tRVVQHV9wRWNtgbmCHqiYUNBOH8xgGslma8mJWcm5UOVGfOJaGOVnFeiDFT8SIDg3QzptdnI9YH9VgJwvYIM+HZBwHoaPoJ+UOqceSLg5Hr2wPrnBkcAsLtdWH81voMl6Nc2SH8eaS924Zt3DO/QebuN5E+GSHOGWIfHQsgAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQBAwD+ACwAAAAARAB4AAAI/wABCBxIsGCUQqwKKFR4gWFDEgWOLLzwQ0YpG28y1qkDale8FnUOMWIUbl+HXXVWfJMBoFOFgjBjAmhYAMDCmxceFogShcQRGUBlfNGY8RkoUL1CMgIFTtzJFrNmHQGAa5RMAGS4yCx0wSbOniR+5OQRg8eFoEClvBma8YMAJoy+HNLGVN+XOnJmNZp6VSCXmjGLkCpAggTNC4XD/vgRQ4IUIkCP/JTyhW1GG0xEHpKnTdy2jS0aSehL+gIXUtgKXzhgGDFiHkRiE5HSodTjFJ2k2CiWca1ckeEMHfLlblcLZ6b4kpYZhQsXXRR/HJB+4AAHDkWkaJ8NmbsM7VKKVf+2oemQyE2GDH2u40yOJuXLYy4kcWD1gOobqsfoIJtI2cgyQCZFJsXYQN4hm9iwSRAdgLKRHDI8A198BClkGGGrHTDAhvdtUISHPBRRBA+S8QCbFGnZEIQmQSQYRBBdOAhhKY0UIlAUFAp0E30b/LUYBxpat2EDGGDQwIgmbhAif1IEoeKLm3QQBCPP3CXBWY3gGAVLFFpY2A+CsAGWffcByeEGDZSgZgwleFiEB1I6acMHkhyzSVxfdAFFFD/lWCFhhh3wRBENAElfdRpycOYSapbApocleODBMWwE8cEHdqRBjw1dfMBNB1HQNBCOy01UHQdkQLIEJBsMcF2QHBL/iUEJT0TaJg8lZJHFEh2w4QGmaWzSxSR/dGMHF1EUcMGEfc1H3QGrQktKmRrep+EGrWJQK5ttaruEiB1I4YEVknzwB7GS1DOFQjzlOF9OZd43QH7WyjtkAwNksMQGMCjJwwZPMPomGx1c+sEkTPwhCTZT5KSQuxbmVG0GDSh5wC2IaojvAA00kIG//jZAxrdLZLHAyVpEsEDCdrCxAQdmAVZqxKdeS4YuG8O68YYZhIBBdf828MQTQo8xRhgLaKHFAk5YUcQSHrjZUHw72vfqBiGQEcLLHA6AAcUdh+BGA0CHQEcIYIRwdAxhjOFBBH1oQQGr2F4Qm0QzW5hxdRms/0EHHw2QeS8YQsfRgHQ8hBCHNSyMUMPjNbR99AKTdLPvy1B8IIPMV+249wYssPB3Bj/vnK81IfARxwaLHeBxBjuMEUMMSPgXQwopaGGFFREkU/EHRyRLmufzusq36MyEQHHX+fYMBuGthyD2DjXAgAQSKcQgqQe6Z+EBJB17gNjDnWN4gZnWHfD1Gq3wEcLGHXPcM8UZ3PfDBmuEUD0SMdSwgxNME4AAqECAG0RtA2TIgsMWIhO9nc8618mX6NxnuPsQCV8YkN6GquO1nlmvBAsQAAEIIEBRaEADSQjADoqUhQjw4AA3kU/ELsCxroWAfaq7Yf1chwGOeYxsi8lgCP+eAAMQGkCASERiEhIQCyDsoAhs4AJNyFeQ+XAwA6QD2xNYYDY6rIEFGNyQkeb1M9fNDwYLMMANbmAAJ1BAhEnQQAASkAM/uCFgHIAIA2FiRQ2xoEhuYMEavmg2ZrCAYkXq4QanIx2PKQ+NbUyiCE+YAAhwghJAEMTL9AgRGQaKhkXKQOgEKUg6AMENWCRdkQYAA0T9gGPKwwAkRUhCJxjAABSgwC8goIQHMEOTHFBWqKioI0AFSUNfywAiQBA6N7jhlIIEAQhU2UoO5iuWMMiCAUh4g6UtwAoeYMMyKAGBBAhCEHxIxMhexjmvAIqG1vIYIjAgzR2M4J5AAMII2jD/gtAhgnTVuiAWjbiAGBChYBGIwNt+8QAIQEAQS8CDRCWRhlc07E/KemANv4aBVNSgnvgEghiMsE9pgkCRYsRXAwRhgCy8CU5vi0AHirCAHDwgAbWAxBRUwYqe2gEfaeBcASCoqI7JqoggeNwYjIACFIjhnvdsgzRXWcMh7cAACfUAFApGgQXwZwwESABO07BTVqABDXuwAx7Ip6xCRTB+wYDB40AwhjYYIQcOhYMYttCGHeygDVLt4So7lgE2fmBE+4kAAQzAuwgIQKy1sIMqVKEOSUDCYe1aSJBaxaEDyLUGJdiBAAIAAQuc4AQQeEAORLAFuo6hBhsokqxYwEaF/0oqAgbQAAHeOFqxzo0LepiCHezQAHbxwCaqOQAZptCq6SABBjCIgWhJa9rTntYCvUSBX1eI0luU4A+4NEAab5lCARxRjgGgwBKANIU02CEREIkCFPRGBg0tgQz19Wx0s2CEOZa2uta9rgj+elIO3WIJuKXACAWQRgGcMKEKTgIF9LCBJUzhwnrQY7IKsIFkRAMPDQjBFC7nIW0SwL8OdagSlGCBFp/AAlsoQYG7ps0jMjihCf3AAnRsgFosYwlLUEU1qnGdjCqkw5ioKDvwQAZsfcsDCzhxAALwgJtWuaEqPi0ESpDIW3DoCbf8ZgQ+EBvuYfUDuLTCOq9znQvEjP8NmXrFK9KQBjyQwk0lcCx6pzxHsV7ZodUVAXRh4DUiheAG37wUExagq5MtQGUUyELFrhOIQLS5IbTwRZKTnAYyULgIMcjCDU6cgD5f2c9Yrq4FdgDdr3ksDogecwSU5oEsaMF7UDYAGSwNpEq3WSG+4Acmhk3WOz8NhAJIIaobetMEVJmXqhZBCdQnPTDEIRa8+wAUYgCFbtdaUla4geHaPABfB5MEmSb2FDxd4QQqeI7PTm2V/exsJVjXAg/YwXMzEAe0xUEQYybCm/oQt1uq7AZryEBYLhCIjlk6J7RAhh0wodYl6EEPQLYCAZTNSyWkVqwgd3ZprasEFBA6Dq3/WITynjDmt2kbCrlewA3ONoDWDOB5L8sjGiQhCXtAAxoWp/ASRg1vh5662SBvKIApAYJguAIezXBFBlhe64R2oGBpXKPywMCaH7wOX9dZgh0oCg1YkMI5uKKAsum4WhQY4a5TBvmUH2Bv1LLaD7LIJxe910IcL22NBHhfCAawGDTFr0OQyFSd9eCcDXgg2QEQgQDFsNctbEEAIphjAHIgAMujgJxK2ELimkGJSwIB1y4fs8lG7YZ+T0dDWMwZkBrAB7Iyngs0PTEJMZ+D3ktehHz+Pe99D4MMRF0WnIiFQmfHfDaFkABwgAMQqlkCI+wgCzug1gBCYIescCFEat+9/whWK4Lyi2CEfc7BCEVQSdUSoAQswDscKMHgD/BH4LMTtQjtbYEcsCC6a3Qy+BJQfOB9PKBxAfALC3Z5RpBEYeVQAYBEmVdq7wcCsoBaEfhocBIbb5JGCvZfvWQEULYDUwcn8hMCi+B9RaB2AbB720VXMucEBEB3ShAAAORooxUAYzACJ+ADDsB5j2Z/V5c5DRZWpuVxDyB5y+AGC6AJjLABPYNyU4B7WbBx3ORXCzAC9mQEl0ddFpAADPZaIABlKjQCPuADOsAAi8U72/MBkCZCCWBaFvBxAaABTpAwmgCFXcRcNKVbv9CCtCSBvTVyFhCBAsCFWxBCJOWDaYgARv/waDiWUDcgQCLACXJIh3aIh3rIB4vAhzeAQn1GR8I3WilGcpxHiTlQaihwhg7AAAhACChwAziGgyIABw5wiTdVh3f4B3mYNqmzCIxCAXLkZ3Q4d1hWd6elBOonAkoHAXDAimnoijhwBiOwBW/HVAjgAD6QjJhoXgnjSHFAB8D4eMPobPGWYlY2ci/WYuzYYh7nADqgAzTAAPSIAAiAA/iIj4TAANq4jr00ZRpgXo8GjuK4BIJAAOglcikmb/51jHPIYu3ocWc4kQ7Qiq5oj/bIADpwhu2IbxQIQFrQAGkTjq3wBFZQCwmJZfJGR6RVTvDmcZXUcSv2X9Aoj/NIj/T/WJEcyY4noASlZohMsAG+GI6C8HzDeGXz1oJTJkBShldxt5AQYAtoiJM0UJVVyQA0UJE6uY0uBgEBQAVUUAVUIAAcAwZTNzSihX58tpYLZgBGM2oGpHumVmWc4Ir0qAPwaJVZqZVbyY4P8JUB6QQBgCZYNERPIFq0lEJsqXsL5gQiBHzoF3JwgAD8yJc2iZd8qY0+0GKpVYcCAEACgCZPgEVoOYm0dEK6RUKk9pNxh2URuHFx5weVaZmZyZc72Zm6JQBawA0iSZrSswM3wFu0tGDAZ47pOJMRqGDolY2ZGY/xqJXPuZGbOYd/mQQkpAV94Do/pC1rlEsC8EbgeUsn/3Z0KeZxASBeyhkAs6mVNPCc7MmPNHCbf9mCThAGMXAthOUG3ZlLuXRL4rVNkfeZTiAKkjeB6RUBTOBgOdCeltmee1mR89iKmkmdU8aFJdBKPoRFfKBG/emf4hWDjsYEIsoEBiCi24RVVqBgC1qVFememKmNEUqPFrCZHycCQGAEIEAvhIlFO8CfHtpVtgVlArBaqpUAu+WGjPV8p1CVeBmNENqiDjCPVzmdDpUDbjcC9aMoG2KWYMBSHYpLXeUBAgdCd4VX5HRTW0AEJ7NNSXCXFUmPDrqXeGmXaegAL+ZxvqcMiMA8ItmlwfmlAqkF2xNTJ4NEW6AFtwR8OWmRWP9plXMapfYYoe6oWiggAlUgVeU2JM9zaGDqn9/poU4QqqEaCo4ZqkiEkDlQmVTJpE2KlzSQkfRIpVYqeVpQBhHkQ2nDRj4KprwlXkxAqqggCsKKCg42QghJCa34ipSJkzgpj/KIkTnJinCwWk6gBYpAabESAh7qqZIkXn/wByPKBE6QmiOkAZQwjTgAq9AKp/OIkRlZkZwQfTmwBWEQBrd6c2mzrYl6qiTEBGN2KZNwRMZqrGfwCOnqrusajRdpj4SwrAwAB9LYBnMQQWCQCBYbAmvqoQ64e2q0psDXgsY6AgY7CPi4rneJkwgwCIMArQdrjwULAnqgIRZ7sSfDRtz/OpwIObBqGQDWSQBPNQw40LCwyqx2+aoIywBnkLTp+rJo0DEXhgdTgLEqM177mphguZZiNWXWKQAjMAwj0LLLirCU+aora4+DgLQiewYoMALShAyScGFTIFGJYAWQSLf+6Z0IqQFUgLU/OUIU0AbD8AhKK7ZHi7ArS42PsA4o8EcHEHFwG7d8UJQK5YZ0O15vVK57u5Z1WEtmUAaf0AZnULIISwgNu4+GywA4kLYoUAPTQQtoMAWQcClWkA03wDsEE1Mqc0uXq7dTlrm5KQCh4AVeYAZmsAUjELoIm4+UKbauSI3VeJ8/gFZswCmXQgFYNWZX54ayu2g2lrep+akG/9AHwmsGLhAKWzC4r0iyQbu8QpuR0jcCnzAGZnEBtKEbXXC/ctNYcNIBv3J1s1i14HtLXTC+FWAGoeACZbAFylAFlCcGKJCRKeuuD+tUigACPBAqBjInH9AFctAFBpdQBHN1IqzBKhOuJ0OiAgAFFRAJXlABw2sGFeACLmAG82AJlnAJVUCZhFC27osCZ9BXYXAEFyAnnHK/EtAHFHADbri/UhLCBuKGCUW3JIpLSfABK1ABWCy8XuACExDDxPvFlyACGKmyDYu6qasIZdBtRFzEEiABIWRAktIBNtArlmIglpJQUyyeCfABCoDFLuzCXjABV7zF5GsGNlwFKKC+6f9qxiMwBmksAS9iA5VhxBKAZgJwA2xAMHP8xFAcAeeSxwYwRx8gAQrQxS0svCswARPgApEgw8Nrw5egDCgguvg4AmHwCWEQBYbgJJWRJ3LQxguQS5jcxJycUJNwzCKaRlK2AKRcyi4AyBWgAH0cwytsyDZsBp+Ajw+Mj23QNimgy7xMGRzcxkj8RgYghHL8IpE4CQkVZXymBRMgzSsQCavcwgowA4LsxzJswGWQwDjQVP+sCG3TELvMy18gBRLQBcD8ndZrBfanIirSybglZUlQxdKsAFdsyvSMz118xTKMwDKcwACNA90cBgRd0AbyBQrQxgoABUhkveK1O5FoBUz/kJ4pRABQcNEZDcgrIM2q3MUx/NEI/Ali4AdOlVQx0BB7sAcF7SRtTARtrAW7B9P8WdW5BJtLmdMrjcUe3cKk/NP5LNT9XAZFzbZJBUN3wNQvEgRaJQEy0MYSIIMvLZwv7WB8lgQCQMoz0McrcMWtzMUSMAGB3cUT0AcyHAZlMNR8lVQfVQNLjQYFbX8IzdIVMLCSRJywWWoSptcSUAH5HNSercql/NNX4AKljcBl0AcVPFeKcFZntQfHwCAdANdtzAQ6e9sIqbkGIM0z0NkScMWg/dM+TdqnndgVcAU1kAoeNQeu7dohDAW07dLei5rUrZhau9szgM89DdStHAmp/ywBM5ACgq3KV3AFqyDDWHwFczAHMJALMGAIS70HaHUHV9fWcC3V3mvdmguQN5DdM9DXo43F6L0C4N3buBPYVxAG6H3cYVADtHMAdxDh8r0Hd+AJmSAF3UbbMoia+33XKNTfe53Kow3ckeDZBZ4C2Y07c4DGWDwBM3AF/cwDP3AHuhDhEZ4OnmDhb03bfYCQ+r3fqGkA2d3HpBzYfb3CoZ3iKZ4CK74KWLzSV6AIl1ADP+AJz2HjIiwFhbDj0O3SHa65QQ7evj3cwF0BqTwD10MN4c3kqxAG5W0Oc1ADbVAGslMIyVIIHUDfIpwJWw4FRqwFfMaaaxlHJ2QA4N3H8f882p995imABGgeXZFT3lfQ6Ld83BJQCIVQE4WgG1nO5zIABX1QAV2Qg5oH5nKUBE4A3oQtzYMtyH09AbhzPdcT55EzBy4+A3MQBhKQ0zOR6QVw4V8gwp4gA5Lh5xIA6HEnd5qL16TcB6Hw6q3e16kc67KeC4+jCDWA4kyeAldAygIhAwpADAFiA73QAi2gHW59BLs+6smu7HftBOauAC0gzbOw3arc1+Ut68+VC6kAAnOACDUQ3updA1egAAKhAGoi786QAkBQAvOeAtJ8BN2G7CHXD4KOCi1QAvk0ArEgBjFgDC0A1j9d7R5VA4gAA4hwDWg+B+dQA6twBQAwCin/IAIv4ApugARA0AQi8AMsIAIsoAClkAIrEBqVYAao0LsBIKx72wggUAUmYAI9MARNsAZ73QLSLu3oMAFWfwVycMUIXsrmje0pAADEAAIqMAS2oAKccAkmMALAIAImYAQ8kAItkAKBJAO3owBycNF6jwqmUAJUgAVobwIiICgoAAJ7DfHgHQMywAIlkAJ+BfkgIGN7jdFQMBUKAARQ3wR58ABCAAgigAKXoAKywMAsgAIq0ATkR1IiMAKVygISYAIzLwQ9gAI2NX4qAAEOPH5V4Aci4AcvQAV+UAlNAAcvoAY031QoUAIGHwUKYARC8AKCrwIqUAVY0ASV0AM9IARN/2ABJtAEKgAIJoAFjgAIWNADKoAFIhADLZDzWPACPWD8jtAEL5D+amACQ/D+JqAG568CjqACAKHGxBAhJh4IGQJEgbRREsQUxCJEiEAhL1RQMQHoQQ8TEC5xHCjxBRYTIlIoyGFChZEdflSoqEQFS54e32aqMGGCZh5bL6ggHOKoEhYVCgGMSlGFpIp8Kg7SHNJkCKAhKnyqadJExdIeCE+dRJFHzQgWQIZk7Gqiq5oePSK+eOEIUFshD1QSbKIQyTgJYXuowVIFyIsmdntoFUFlyJBTf6n47HGqSQ8WCkqoEeKoyYsHWoGImUxFxQgMKKgCEqGC8WM/TdRQcVQFRv8FDAAsi3HDQgSLIyCeYBBDdgSMEkaAEC9RAsRyJCwwSBiSYkTwNiyesBiBJAWLDCNQwJCBQjVpI0ZgxCjBgwUIDCxgNDIiDMA0BTMUKEghoVcLHhh+yOhvhhYUkKAFAxVooYIKTGnEFFQIMKOFI444IBgMBjiCF15a4EUGYFqQQAQsesDAGAlSWKECBVYw0JgK/rhnEfkAAEAaGTopZZNDFDCihxEOQMFHBXqRgwgueCBCBg8EIIAAAZg0RYEdjKgCrh7EKKEFOVrYAYUSZBhBBBAkCKOGGhARBgkQEAEhBhC8iWaRAWik8YhpMkGDkaSE2IIFnNxA8L4DEWxEjkb/7ptFgtZMiKiKLahAQYYWZBBjtB9QEAGD+xSY4AoJ5kCknEfweMKNaGBpgE4AjhhFBk9aAKESE9wwQoge1kAPBSCW07XNEUoAAoUYiIjlBUAy4w6RAzAYYY0qTMhhhMPgMMKV42ooYcVrRp1iB1hQBaCAAgCI4ggZ7gPChCZQePYBuOCoqrCqKumsM0dYABEGEWxtrQp2h3ihqyEeoMKwqjj5yIgYKghhiilAgGURElQt4AgBRxhJhR6qeqGgtGwtKI8XTBjpBQwajKGKPNzNIyOSLRgqMhN+MkGIzV5qAt8lyHjiTT3GVfWITlpgoWMUUABYhTwqIkqtpkcSIo8q/1Loo4ISLsnDgpywgMDdF4bII4cqrLKVZKtMmFqKQBoowY13LgCazihGgbWSIVio9bWzOlYXM5UewOmFNeQYQ45YTfDj65mrWkwNuCxyBAIsXhChqsqICKS/bF6ZWFUao4CViioOYIEK0oBwXIWjLUKhWVuGEGE2EFYAgbDfUFBDtZJEAMIIEQCJlgU1HkABghfEiEGBCw54Io1FPFe1EwVigEGO6WNoYYY1VGhigAy4x+CIdE0AQoI+QLhCAbxhGBDYKozAIAX73ERCAhmA0PgBQFZS4IgB9EgEGaAnt060gxid+EIdSsEDLjWhCjzYgQNT0AIgxIZ9ZqrBfQRkrmX7pGCC+DnJfYjQghJUQQ37G4IRUkAEDnCADxsYYAGicIEj4MKGmfAEFzjQghiMAAT48aECeNEcTc0ACTWAwQ+OQI0j/AAYP7CPEckBgyT+4AAcOEILYDCCKgimejpswCLGVYCAAAAh+QQBAwD2ACwAAAAARAB4AIcDBADQmIrouKo3Ri8TFwrYppTFiXWzxtgvNyjvxLinuMm0d2usZ1TF2OhJVTjvysZLSDDx2NEpNRvPiIzKlHpQV0rv6ecnJhhYZkuPNlKPKkyzaIiTVkrjq5qpWEu4hXSRSTVxZmttdk3qiKscIxRvSE1wVlSup6y4zuFSR0zvZ5n29PGTSW6ROWfQhqVxNk6sRnOvVoXPp63wRoaQiIwqLCepKFPLdpNxdmzwVo9QOC9tKDFuRzWtaG9wV2yOdnOpSDCpVXKulZa70eRxODPGeW7S4+7vNntrVzGYp7nslrWRVnCRZ2zKapHOmKpSKCyVZFaOeC1VOE5qaUyVlY+NSFF0KkqnOmvRt7TRyMbnqK+uUy4mGhJUZDuuRkv0K3aKODGxc1quiI7MdqHzeKZPNxeqOyyrNlXz4ttyZjGwJSt5g3CVVDaylTOPeIXklpjjsZx4hVaSmKmjJhvuqcJTRhqKhXGQmGmxdo6yhy3FaVX0O4GlZxXMWShWZmhyS22wnKWNdFKJilGJSRWWVhSrVhrKSGo0Qht5eTGTaYSVgzGztbDcsJ36aqGcrsCsZSvIWHTnc5yUl02veirrtcmesMLHO2jKRzLLZC7TxbuJaCjFZ27Jli7N0tJnVBx4hZW5pDWto5jJVEbVXYlPFRdQIxhcVGVtGy+YVYHGOC/Dc1yTZhq6dRvFO0nMdhjliZI6S0FcSmJ0NhdySRd5ZByMKTKZpI2njES1iqKtpk2kpnW6x7bIKWTWucIoChE/UDVbGihfcEZzKxZ+eIeTLRyZoXCrHSO3K2O0T4GmlE6ls4rHSlDSghzGhlrIq1LIsjTQt1Hs2eEeLCRXUR2wl3PBLVnbTR/aVB7FmEXWoHHlRnvhWRnlZxXnhxc4OEM3UVU7bXdfb4FobIGcHUSQcB6Gj6GflDmdpl+nHkmysFG4wZHCLSnKYBfLbqLIezLMkR/cxDvAz+DjeRPhkh3gliHy0bwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBxIsOAFCJMuEFhIQGFDLgxLMSRhb0ctIPYyqtmoZt3GPtcu2ZsHwpgaS9p2ADgFo6DLlwAkOLgAgKHNCwpz2iPxZIfPHWY0alRjr5WNPtbsbetW8owlS08AkHpBAKa9MjBx2lx4YScJnBd0EHly4adPMPbMELU3R02qS2aQKk1L1JKhqBDsVIBZpupLHp4IkPi6cPDgjPaIgAFDxOeTnmDMBEWs5lIfy9f6dGO30YahDDVxUMFBE6bLC2UI5Rl8AcHXCyQkkBBLpDYYEDvAvHhxCgwQYogl97lsr1AfTmaM2agGKSqAGhXWpDDt8moZe13tIdCOYLs9HozDN/8G4aHEjgyLiUkGIgrTZUyFCmHaWM2eB+c1EZSmTnCifgQDAAhBdyWAUFttJfBQmw47NAaGMMQAwV4fmACBySMg2LNRRcvgx99LhSn0VXcDlBggBDxAMCAPJejwmA5iMZYbEFuIskWFW2zhRSvLQGLRXQLZ82F//kHQV0YABpikAw5U4AAPMD6hIg8GgrEFjVswgOEjfSyTihk9lGWIkPbUMqRAhR0WCBtetVbidksy2aKLKaDIAwcg5CihB5M8gsklrZjhRQ86lKLSmUTC1toUKWoXG4kD2GNiBSYgoaAOU5rAAQePsAGEBx600YY7QHjhwSZV0JDCQgMJ+SFDrXX/Z48mSGgCQaTamViik5SaoAMPUOpgAhRQUMkGGx7k0QYmHqiiRzN5iGBCQx5SZxNF3SFQq7aeBJirkgM4sKsJEIiVYgVTWEolGByEMYkHejg7yTtRLJTRmddeUIO3A6oIIIlJhstkBeXCCCME6ZpwJ56gNluEHpOwUm8NrL6a76MDYOBAuQj8ki2A4go8xYCYwoiEPepCscDKPTCwsh55sEEyRPimKQFOAmYU8r/hmoiwCBV0hym6QDPxAxNMLNDyAhMwwAMSHNip0JDXktDdiBCIYI8IEOxrogMaMynCHQ50l/UdcWBgx9FLLMEEBwwE0QMFaahYrgkt+mWtfwjU/yBBdxiscYcgMyFwa4lMduHAFHGUbbgIcYhghxhIM9E2Ez0ssUAzzSABAcFQ6AGC3qZdm+3fCGCAgx2CYBBgyCViEIwIgjSOZAVdqO2GD3iXoOkLJfQQxvC3TOGA0zfzZ/oAt3JXAQ536CKC67pmjIEIXSjOnQiSuxGCDyX4zgEUmS8QBhQcRDFFGgwgIEHFMIXYVXcSaFdB4LoIIkLITIZ7vcauq4E9ILAGEfAuBSVIWgAWGIACCKAAH4ACBBYXBvfZJH4NcY12EJMx6Omvca9z0gAqwL031QABDphdCqRggg80sAAFCMAbOkBDAfwgBRWAAgPKdUEQCQYnPTORCP/WUIzaDdF1KKyAwDTmnYyJYAopMAHTGEjFAMAhAXpRGBvq4BD4EUkwJMIABu7HpCngYGx3WAMOlKjEEYrrc90B2/RSwLQPfGACE1igAzsgADj8IAROOhkJekikQVrNcGusgB1wsAY1jk0XONBYBSYZICUhSY4YKMECDFDFBtIwAVgQQwgwMLKdFIZ0aGrIBf52gYzdDwewVKPgqEADMY5xjANIgSXDNb0K0JGTMFygAQxAAQo4UAAUEEQgdGCPhmAHVgNZiAQkwDwSVcAPYgwBLO1gByrQcg0h8MMkKwCLbMWulylggAFi+IEerCwMm4LCBzpQgEAEQhCIQBkEmtn/EAjUhCE3S1J37kcDcIbgBzRIqDdpMIxhhCCcY1ySk8QoRQMsoAREIA8DGAC3DxQTDoFAgiJGOok2gCIKEoDOP6VZP8SNMBQWsAANfHDQhNJADoCggRtwEE4/HA5x4nJAIAxQrE2BgA0bNRAPoEABOFBAE1GgxSqmmgd4tKEG0/mndyTFpCbhIAsWOIEPfPADIZzgBDl1g1q9J05Y7OpwDviBATbKgSrwwAMUWICBqrAAB1KgDVFdBR/4oJp6IQBNF0BCE/uXS1O44WhlxUIEIpAFIdDgaEb7gS9HONH7fcAAHIBSgcJQAAOEYaMBSEACspEHWtDCHpPQhFbuxRDD/xlOVwhIAfhM8IMACCACFsgIZbHgBDeYgKZs7CwOPsvRTfXAAPRkoADqsVpNlKEOUchDHhxgLx3UZDDTtEcUbrUdKaQAgb39bXARYw8LoOEBQmDCQymJOA7ogZMWHaYBBCCAAHCSj8g8GQKi0IY8IIIhVSjMPgF0Mu6cN4FCEEACgLte9toDDTL4wR/bGC4kMKCYwVwABQJAz40a06l1gAASosDiOmyFABC4xTMU4QARRMFzU4LCOiU82R5HAA0xXUF7xWACQFZPx5wMwAI2ulEPLMADRSAmNZDgiTRMYxoZUeVCINAGToACFOZQhD1SbCkO9JW/AnjAA1Sr5h6jQf+4vJsk7KYwTPMxwAO14cBzTUyBMOiTvWGBCBuU9WVRKcITdhqWFdGMZtUmQM0PAG5GZIBDXQ5MBB9YMqgsSqwFZNplFJDgPhFzCOwM0hXM4ESXRTVmFJVAnsdstKMdPdmYtpcGfwCQ8YIRh0+Dqgc9GF8P0GdmA7C3fogZJAGYQQ9OqBqwiEYCEqTYQP7OWs3XpnB7ZWACBDwvDl2Igy5O6wEWVeHcxNpUGD5gO+zgKssXcIUrnA3YMddB2oEwprUhPWtHR3q9K3jAD8yLgciFOxAcJcKdgiC3KDNg3WvAAEW60j/sxJsVecDGLZKBhDrcGwmBILGEIx2BNatWwrT/rjAanKDLOJxDEtObwp3hVtcqFNvTdxDBAF4zgOyNmgSsmMQksOEMZ3SczKSFQ5ojnQBGW9vaks5IJnwwAFuoQxm2ICVHPZBU8mzSjtPrggbBpjFcIUG7eXBGLjxRhjLoAAkfKACAZSAEIYjB09VGswx4LNwbLmIX3iwgsXR4Wga487MB2J/OtTNBxhpOE4oQVR7q0HZhUSC6mc70D9DHhLwH4AM/WIAQJBsBMUgBB8rIRCcyQQViw43rHlBZ3Bcpgu3sS4w74+otAEv5MvCgrzFcWRVX5kIBMOLzdgyADLCABUpjAOu76EQoOMqiElQhQdQuQBayQIUUdMcEQtj8/w+81TER5ME6OoBCAZoewwVOQAxCGKYdj+lfTj46ATA0wRT+noVMKNkDBqJw4SNPDfRmFoAFIYBAdrQy4rIkgmAdPCAEJNd/MrAASLMyxNcBqvV5wodmBWACOLAL9hABWKBkHMUYCldsxvQAFrAC7yUEZvYDpIQn/iMCkhAFbYcEBeBjWXACNNBtOlACm7Jfk1UAHGVzTBB3AmACNIAYJahpIBCFXgdMCRBcaFByMhAA1GAHC6AHlwAB1xMHd4CDEKB+j/YAWcB8JyAED/U2PTABCQBkArAAVQAjUsADDGBDbpARQ3AApXVam8IBXCdiDVSF7VVyTdcBE/AwogCGIv9QDGNYBhCwAPS0dNuXhjKQaQsgcsEVAQWAgUojT5aVEQ1wAAogBEvGZBvlQg3UCcFlAYgoAIrIiI4oCDeIIh8ABw50hg+QCVnYgY+2XhEQAO6URw6EBSeAGCigAPZwAh/AZBg4ATKQBe11iGsmi4uoB43YBdxji9NmTADGbwIgA7uoWhGAGLBYAHmkXpSFGKVoivYgB2IAf3V3AsyIGFd4jR3gXw8jR2IoCd8od9bWbyenBWlma1cYUz8WU1doD0OAAvZwABKpAPfIXgeAju71APy1jxbFAP54BwDJVHLHR9d2jb61bz82YUDGkJNlYRkxkRRJkQcAke0VUzF1jer/qDQOwI1iWAxTkG8jiXKzpgUNtGaV+FsaqZJocIUUtl4P+ZISKZHsZZNW2HT9FQBFAAHcCDl3EAhMYEwC6XREmWQblWSpBUOP5mPR4JBRaWFS6ZK2FgECoAVaIANEGS65MwV6+QMjBkM09Jcc2ZGPwQGgtQPrpG+82AmmKJFD4JAuCZcrYAEaqQX7OAECMEFi9ERT8AMe9UIwFEwGkEcUUGcuk3z7uGiOlgUKcJHs1ZiO+ZgKqZEwNAGbqJVTkD176VEjVkXDlHdwEF0GqVodMGIkmQCLwJqt+ZjuGJt9FEM9sAlkxz3cw5nFVJ2jaVGb6HT8NVlrpgWjWQBKJwAV/4kYQ1CerumQjUmTzKmLxOgBhgM2nzMFdlRM+mUARbBk2XlyPNZjTWdRnoQFyNma5/mSUwmLGvlAE7AEJVAijac283md9lkEG7WJMRShebSO/EUBDFAEJIYFr8mHQ9AAAxqRJJoRBspfdrdZXSVGgvCg+lUEEjqhDOAFpnIqm/Aw91VaLtNAHvqaD1meNIkYFymRr4iIMkAFbOh9ApM7GMCX9FmfHGUgIMAAEwBDmYAF+EcBTmZam9gB1OiY74gCQeqarHmRsYmMluU6ksI82dMFQ/Wkw9RnbPAYRMAEYiADMtCLiCgEv7dJVpQFKECmFzmgjbmYpWiik8V8MoALfv+gKxOUPYGgmxDqXwwABeETPpsifAt0d8MkkG/ZluRZohRJogz5AMh4AsUVApGCONmDacQ0qdf5AUVwA3iER7QaAHikR+ApAJ0AlQfgmuXpkDQpk0TqXhGQCSeQhT2wARkBVNz4WdX5qsUkTAswqxPwBtiKrQGgBZ8pANQ4kYwpplHZmI1JrAGKiROQCHu4piXyCyJQn3HaSR0JCTAKoyIHQ/ylmkmwmlEJrp9KrKuZEZ2wfVggBG3TrPvTqvDamwwEQxQgoaDCAKqwY8bHCPx1AnKwmuYak78alTHJjPzqsfYwDD7QrF2ACCgrAisDrw0bTP6VaZ2qnciYsRwbsoz/6bEKUAkcaw8fKwef4Ad1ACAom7LEV58t+5mM0K1CiWZYkAQ0G5XxgAL9Oq4fK5NycLX24LSfEAJ8wCQspgiIIAKnFQabpF8t2wEG2Wj81nQzu6/9mgX9yrFDALKjegByQAOfIAdJsLUhEHQsFgWKEAUtmopkq1/TGpRqi238VQCAoLf2aLM4K5NVy7N3+wnlcAI44H2uIDF/qwh3EArPKIgPt7LE5EmMdob6KQMu4AJOYI9TG7ka+7E8aw94i1M+sB3M8AhRoAmgEgbJ8AGACAJwM6HxuquyZpXHt7pK4AQy8Lhx6wgZEbsfa4p3SwNiUALb8QidUiqgMppMFoWw/+cBZOunBWCxTveZE7C6IzAGrasArjuRleAIksuzHJsFCYUHTKADOAEEIOAbNDoofbZRbBCFgggCQMBkUfZCjJC0n1kAeLC6LnADrOsCuMC8zXtWGguP05sFgCAEiRACzHQBEvIpHuAF9uAFw8RkxxKF/GvAXBdlu9l+1bYANzAGEQzBN5DDELy6ThCw9CuTnYCxj7UEZNEHI/y/GRAEFPABNCeFV8LCL8ywSJsAE5DDOry6N7ABNewCNjwGNiwDMZm1PMuaNJAIG3BufXAlEkKjGZABm8jERsW/yOIBObJRCdzAaTYBWnzFq7sBG4AHY9AOY9AETeDFrVsJiOHDNP/ABGecAWkMBJJBo2egAR7gQh+wwhKSJ1wXLxMLTJ/5aBPQAzGgxTfsAnjgxzfQBDcwCoTsxRQMCNF7jzSwBHiwBMVxJZIhKPbQxpv4eQP8xDQiClH8qtWmZgHQBH68AaaMxQy3ATHQBDHwzF48yHiQEfJrD47gBm7zArcMyZFxBl7QxkHAQAYAgCxMoxsKo2YrlAGQzA/8wBEcAywQzTEAAzAQzYXsx2LQjMl4AongNgpRCHoiGWDQxrwcAPT5ZF7Av0ymB+rsW7Omx8BWwxvQxRvAAgyHDPZMz848ymJwVhmhzUsQ0AKtxmagAW2sAVWwQNdZBIOoNDfam+XYdAv/sAETncUS7AIbsAQYDQNXYM/IQM+jjAe4cFZsCD6DRAiEUNJX0sbnkQE9EENFsDT2mcN51LBC+Yk2vceqjMXy7NMt8NP3HM2okMyAsAje8z0IQACDsNQ5sgVsUAUZ8NQZMKsrC6O0mqtY7WgFsKxyg8wbUMjxzAIs0AKGDQMtEATRzALO/Mdi4D1j9VBKzQeFoL0AWNBtbANn4GlVbNW12rAWy9dBsNM9ANitPAYbgNgtoAGGfdjyHM1+HAQfHNmJMFiDRQidEoUpzcudnatX3bJZzXBLENjLetrQXNgo3dotQNiwXc8s4AOmYAo+8Ae2PVirMMAgEM4Z0NOqXKu5/9oB2OqXKNdfQcACw70Bo03INQzNiG0FL9ACGWDYhI0K0WzPLPAHf5ACsZAChaDUhEBYgxCFNsdwQQADTeDdC5St9FSO/BUAPH3eiu3HhMzeGWAFVpABuxHf5l3fMGDe4CMFCDAIIv7fhTAIskAEesZwkDAKG4DgrxDeecdoAVAFhO3HS8DRzqzRFe7eFv4CGfAHZlzPLWAFjL0B2zEI9iDiIn4b55bEm+DO3v3b26qdM17j5a3YQg3WL8Dj7v0CQI4K9qwBL8ACieACJSsL1yHiUcgGNFoFQfDkyWyreYR4aAsHdg5gVc7YhE3gGw3WViAFUrDlu/EHqMDTLODlPv/gBhvABCVACs1UCrchvA3DAZjjx5CwCRcamm9AYoCJ523c04Rtz6Lu5y8gBX+OQD5g6IcuBUuQCB2eAaVQChCRG1sQsR7AAUsAbJDAcGKAeG8AQ5RJQ7EWAJ8eA0Gg3FeQ7MneArsB6IAeC2O1BH8w5FbwB0uQAVWgAQBwAbLOBRnVMFzXAwXOcCxQBcY4kmj7l2hG7BkAAwV+Bcod1vDO7M7+7GOVCD4g6H8w5hmg7QCwAzaA0uRhCDCw68JtAnJ9BVUqd78OYMYrABNgAwEf8BpwDDYQ3619BYTt7OcVC6YQAn/gBz7g3vftAyzg7xpQAj6QATZgCSxgsJYAA9f/rgEXXgU9gNX8Zb789Qo2YAILFQpCYALHwNrx3gLOHt0P5Qcp4Afh8Od/MFaowAIAAAwvIAMjQAU/UAJCoAIuwFuUE/DtbheEfK1v8Arg/QYGaQghoAQzMANKkANksAY7oAE2oOzKbth1DwP28NMaztosgAr4/gIkoAEhoAI58AAq0As3kANiAAF4MAN4YH1XcAZIY94scAW7rAGabw+vAAkmoAVfkAPRMAMygAAmcAIhYAUpj9JWYB44YAIvoGGxHwJFduEacAUZ8AQpoAFUMAMjcAN7QAlHQAd2t/gngEd22gSRgKvvRwM5law4kAEzUPVHoAQngAVZsHwqEAGA/5CsxLUIMrAISqAFi6ACZJAFI0AHVn9WJ2AC2u7+gHAEZBD6KqACE/AFjdAEI+ACR6ACMjAKABFp1IgZR1Ro+aJExRcZL2xQIfNlhJIsIxqRGbGQzowcEmfQSaiikYqNOY7MeHAkBxUNvqpkcHLyy5EjWmiOaDLC0AgZLnLIuDEiB8eCI77MaKgBywwVQn6cUKEiEsI9SrR92aNixoyqe6KNoKMyR6NIX1SwdPnCydGFKlLOENpklMJRKlwouRFJxUkVSlT2eqHhxB46NHBQGUrJ7wy/dJQomTnCouIRRx4wNUmGZY0SgquCdAJRhYwcIyLlmDAhx8+7TkZoUdKLjP8SHBpMIFSB8QGZRlQAzdaigkaFE5RyUCKdo5eWEYvI0NHSyEmKMzVS2DAByA4OGSGehADvBA+THlWYiMFTwoSJEuBDSMFRIUOOFzQA0XCDYwoOGlJexKfhhBR2gCqH4YQQIgX1dMAhhApwSMGQQBBAYAcNXsjgwgxaOaMEH1LIwMMMLMkggzNssEEDG2CAYRRDIHmFkSZseOIJBGCpYIAneOHFBl52kMaGDGRI6LoMXrgCBhuuQPEYL/SABhFYCCAAAF92OEUNTPo4Q4wR8HghgBHc2NALMHTQgYgdOCigzQkCKAASDX4QwrWJhDBhSRueMmEHGrrTYAkffPDjGyn/CA3BhBCgeUaSAQCAFIAnSBGGj0uqcGIPMX5oIocfUNRAxRRVNMQeQ0Il0bkZZnJCDDpO2MGGHQARzp4TZKggVA1aYCGDP/wA5xNFprDjmXQcqKFKSYHZQZYzmFDBUzGOGAEH9RahArwTsi2BBhOoOKEEIkIZgZIjGsEBAz8QqICGNZyYAQsalCAjCyFsoSKF9TS4Qpw1FInih1xycaCCGiC1ZwcLNRCCqVAmQEmyLHKQ6gGKI9ltN3SFTEGGI5RwzokTnCjNrxwe0OIyJSju5C4hSoBBhCiiCCEXSUiIFAACnrDCBjsqU0Govk5a7OOT9iDIqBEqeLGETHfbYwZK/5C2oCwnspjBpoIwopgMHGzwxJ4pFq1D2UifOMUGHEbYQ4hQSlNhD2rNYoxuo47Yw4kXeoDBBBdmsGCrLyJ4QLIc9sDCiaA/hivoGfQGw56C7QDlArMRBsaGEE7DQYg9KNFiqMpmaCQsph7QaoQ17GHCns1nWESorClejQ7JMlIhAolIQ1cDIuzRoYJkQME5Z4Q1V8IJBHDQYjgqbFfhhBMyOsHdCH5KAYYQrghhBDIwII6OaJGSgQohZKBDBsPoeOCECEYApLMLEJiiDUmMz/kUDUpIwZ79S7CBFdaQmwFgIDcVeAIVtsKSIEyBBRro3HVsQwUnJOgFVtjfezKwA4sq9OUBlGiKBp4wgDogwh74i5Q9ToGOcezADGqohQ72RAYn1AAHNHQIFaRznUH5IFQ9e8LCXuCQCwUmVETAjhPoAMIcCOEFv7OHICCAQgLY4wKTIgWlZFEGe9igWyG4EA3AyAv45MoKh+ofz55gD2nYA4Nn9EYK+mcPBCTMBimggRNC0z8uOkASygoIACH5BAEEAPwALAAAAABEAHgAhwMFANGXizdGLxMXCrR2bS83KKe4ydilkui4q8SJdbPG2M+IjaxGc8bY6EpVN+/Euo02U0xIMU5XSVhmSpM4Z/HY0Y0qTiYmGatoVe7p59B4iSo1G+5nlu/KyNFnjJNWShsjE8qUevX18W12TXFma6Y7a29HTLeFdI6IjXE2TfFHh3E5NG9Xa+5XjlNITKxYTK9pblA4MOyHrLNUhrjO4m9HNnJ2bLzR5HBWU45HM5FIT6xWb7Gnqa2VlSssKI12c+OrmdCorasoU6xFLuyWtcpYh5JobsZ4cNCXqvA1fFU5TpFIb9K3tHUqS+anrm8oMWlpTvN4ptLj7mpXL5ZkVVIoK8tXeK+Ij6lFUI55LJWVj5iouqw3Va9VK8/IyeOTlygaE3mDco1Xb7FzWU43FlRkO/UqdvPi3HFmMbScppKXqMhHbXiFV69oh+OxnK8lK7OWM+RzmO6pw4o5MI54h5GYa6k6LbF4kLKHLdOHpY13UJODMqMmG8zR0/U7gVdnaKdoFnRLbYtKFstmde62y1JFGoqGc81YK8RoVXd5MpBWMotoK5NphImKUbK2sclHMZVVFKtYGa5lLPtroTRCHE0mFnmFlpSWUp6wwk8XJJ2uwLZNgbB7KtLFu+KLk62nUcc6SstlL8eVLnIcLpMqN9BZHM13GeVEe08SFlxLYlxWZXE2FWpUG3Z2h5lXgpNnGZijjrEsYbZ1HbWLobmjNrrGuMc5KspURnJJF3hkHKkdJsMrWcQoYc1zoScJETlLQj5QO3ErGZykaLI2Hq+FS6mSTKOkcqynjqW0jMEnJcw5bcVHUMpgHsRyXNeGHMarUNOgdMm1Oc+6w+zb4VZRHZIdQ7KWdLeyT8mKWMWYRdKzV92xn+FaGeVnFeeHFx8tIzdSVTptdkIPH10tRG8+YGxvhYMdP4ksH4wxGpFwHoaPoZ+TOZ2gUqUdRruDH6evwLjBkdlPH95LgMd6MsOgMNvDO8rBXPMfbuN5E+GRHeCWIfHQuwAAAAAAAAAAAAAAAAj/AAEIHEiwIJhKrwbwW8jvwsILYBryq8IPBIgCMSC8ecTwjcc3yTweKsUxXw5db9acegJgFL+CMGMCuDBgAACGFUE0dMjzgo8VK0xAgDBk4Rujb2yBEjLSFjd+J7morAIAVSaZANCQkVnpwk2cFy5YDHshxooYMWqsSAF0yDA7Rxcms/XIzqF4TvkN0yV1DVWsAsm8jFmDVU6dhy/6+DknR461KdjmGFK046PLI0vxK+VRyBoIgENfIAMpp0MQFzaAUB2DLdAcL3LomP0EQhc7DO3YPcQx0iFne4XssvI3tEwwZAT79MGPuQB+GzbUmLNiTmMdH2abWKHDMTrdQw6J/38UKlIkZiF3cXlR3HhMhjodLiwQYaGJx0BrfNgOlLv1YOdQdsshoQwRiiQ52OIRF08s0557AylU0Wny8VMAQxHUEEEEApiAQw1mRfDaE0/MMUQXt3RRYBddDAHKGwyS4pdAYEAoEE46RSDYYhsw1CM/DjgggQMgouVCho/N0SKLGCAoySHLwAXBBU+sUSMYpNi4kEUg+KCHImCMhdOP/EQQpAloVSFBhjVAxSJlL3AiSSiPgGLHMjqAUQVLNg70EGr8QFGDAz2uNh90GNag1gpVbFgDDgtJosgQL7wABxzzDIHFC4PUAAZEPhRgU43GMVQhGotMsUh90R26kANmOv+AQ1pF4kAFFTXkoIgiL/ADRygvHIEINvyQAUYEWvBAgk2lbsncQqryM4VhiOIE5KtTRGCWhhJAMYWijvEzBicvINIMIpyIkoWFJGhhA7OhwefTQhvUt6G1OAUpwJpo9RuBtx8uBFulzQjLiTvrkgVvvFuK9eMEsMbADzDWOvCqA1BE4EO/MUyBxrc1UEHAyDBgQICw/Chir1cQwodaWAtFgMa1FWM4AT8SLBSDmVBA4QAJRhghBgEwwEDAAmPUMEWZijokU01+utxwmfzMrHG+EAfJTx0W76xHHWxMYIPQgYhhBD8Y7AADP6tuSIaiFMUE9UwFIIZYqAtNEEYdQDr/VN/FQI7AhsVUh23DFSzgwAILYlBRNAHEYJNtBAV88MIKLy1cUAETXFgRQ56LbQg/E9RHeN4j8MPG4AUwJ8EEE/xghAloBmVCCibAMMbuxJQRAXtgaA5TQzohxmreNtRhDOn4QnHzq60zFMYPLLighBK4f0DF0GNQwXaQVIi1EGALDRDWBgII0Gq3YSxPs9YO3Ozzza1HEAY/JLCghAksHH10AAdwAhBOQIUNoYEKG6jQYIYnkdWor1V645vqLCYAIVnseX+7UPxwNjYCAPAAAQjAF4AABDcg4AcukAAVMKAtC2lMeBJ6Gc2kxzc28CMMz9vgkCDWHObIzwUsOMEC/0JIRCLy4wGGkMCHFFEIhxSgADQxH0HgwxDYvS5IULDB1uoQBhvkbE04s1gEcgakm03ABQRIwAkSkIAhAtANQEAAP34QximoBic1WRg/FIIYAXhRAoawQRi6uDVj2GACEkhkzp6zkMWUkXQmSGMRQXgAEj6ACVcgXcbuKBHh7RFQDkGk2GwgSEHyzRCwE+UX+fEc5lxQAmhMwAdDyMaFHAABcryEHiLQI4jIpyBbuggjcfYH2PGDlIYYHQoGyY8/KNIFz2GkGWGJgQSA8ARGI8AYFoKBE7jhAHrQAz8SgQaV9QiYwSQTzibgzIX8AAXw5IcaUECHVhyzmGQEUiJhh/+DNBLABLl6AQYwgLYEMEQPU9iDQjkBB1rsYQNTpFerrvU6CaiCBSSYIzx7oIY00FOLf/iDCzwHJItJ4AcJwJXAFDHQx4SMIYvIQi5eQVN+1AMO8PJRq4IkJFhidHE/6AEPeOBROhiVDs2UwC8WAkZgSGCNA+WHDmrQKwI8RgcEuKWvZPoKQACiNHvY440uYMedWswFQCQB0ILKhIV4oQcokJ0R6PADWOJMAhV83RpfAKL7jOEACRjDQAPwgAdAgx+5yEU6ZLEImNFEgfayFhCBGgA5ZkAEIuCHF5gQhDsoDmd3teAIoMoQGCQACCAMIQL2YdhFkKEQ66LZAGLAx9X/bAANWfibD5SAVhP8oLL8uCxmMZuBM3QgDWeraz5zhghZJiCNbMRlAGQZRznakR9ZgAN2FwIGHdzkIjOTFhrC21sj9AABDwiucIeL2TME4Qd0LB22CMqPA4CQAPwIAGoxsM0DLKQQhZhCFgZcCHxFgBjR2IPFsjC5DFEBgOi11hnOkAHhZuAKkCLBkBxAsQ+wMYQEGOhAX0CAF4whAdCwxhQ8Rg1qREeGZSoGPRq6jj2gYUPf4scJbonLDhT2AR3oAEOEy4/FsSCRsAoUG0eGgcthzrRjeIFBxzBeXkYnOjGIiCJ8RQtaXGoPrGATDjBQWVyaGb2FDbKQhRsEIO7z/3U6DnGlnnsrApwgxPgtoJU3QInoiM8UzhAFHAQNBzQUIkO22vGZf+xjIAdZvSLIAApTeMgRGOLOTX5B0fjhOO/xI41o6HN0KCFq8TmDH6IgdBbCvOJ+QhjNjm50miGdgSDgQAkSsAEbBHcMwfJVKLO51ULGcILBbQCK/CB1q0BgClOkGg5ZMHSA0SBOHsf6x2kGcnCH24Ef8HYCNgS3HggKFH7sQG1LtnMYoNClC1BCawm8gClksRA87GEKAF6xHvSLXiHzQ9bYTu96z5AGF6hOGJfQZJPR9oLZfHoBJziBBGEMsQSCQBZ44AQ/nvGMKbw2AlP4Kz8Q8OgOnBmXD/9A+bYx24mMwoIfyIDFBKBAUIFiwDEkVuMCSHezi8QPkdAhK0Oe8QlWJCcCONixCREQhDT04Ap2DgATzhyECGN2ji5wRC0Wcr9brTDEGDDaGgNAM+cE6XllWsQeLsWPQiQnBpBCbQDufGfZ8cMIrz7Ana/Qg7by4woxsAEyOtGHTnCaIUx+gcgWcABD2LCHmjxdjxxQDGi7nQwx+CtgRwZAIo7sBJXdxtxP0IMABIEJnE1hzGvRh2MQtAa0046rD+AFL/DD4PzAQQ9+QAU6IoqRWsF8Daw59/8tgO9sjDiPiXgAID/Avjiwgda90IkAlBg/sDcB3m95hki3lXZrHNn/6a4V/BhQwb6AXQABPhC0kX0eCIXVexpvmfID4IAEtcgsE6xPUOqsoE3WhF4VcFnG1QOf9gMzBxWPdAlZIHw7dk0EABQxsDEmsBAJIEf1RVA6IDIQhgMokFkNsH9y5hiyQWb9VgHt9W9BEADWYAgEgAiPEAE3wwZ10IDm13nrBxQe4gI4cDYwsAAPQGEIQAA6gBb7gwEnhAILcQP1FVj0xQ8CJXVA1n2Rxg8VkHJAsADCcgsyyA/CUINkEAFZZV/Fd2fux3lxdFn1NTI/QDRUQHpK2ABMyA89AHYiNgYhcEsdMHBXiABZuIVdyA8MmCEPuHQrqH6PU1lARmQBYDRD/3RLTMADC9EACrAQPHACIvZ5UtcA65UBffiHzcCFOHEJUwAplYRyKYcAlISK/DBcGdCEwPWKtscPcsgQmqAGV8B3PSBUCsCJxHUGnzhdwrJBNEiKplhdsIZtCOAEJFdhInAG6sUPFFZctHgDNEAD1rIF2qiNk2hhwIiF01UyxFgHpOg9lVRdaRZkKVdm/WaF6TWN1IgvDdAA+LKEkBZpnlh/iEg4NCgMUNBfJJSMKecEAFRYqIVL/xZhEwaN6vWKcniN2IgT87gQl+WMZ5CKIXQEf6M6daAHZ2NfyGhmBClLATBQJElY9qVtDDEN/DCH/ACR1ziJ80iPreiMI+cETv8QBE7gXxfUM1BARx9EQkIJBNP1XBhQBRRhUE9gTfXVb0HWBzhxAw8JkTM5j1JAayYnQAGwAAhgJsbUMz9wAvmFfug3XSGwlUtmMhGnXyE0cj82i1U5lVI5k1Lgiq9ocvalfgFQH1CwEGAplvlVREXJb7j0TQcQBD8GBPkVR4XlCLQYl3MZl75YYXcpRyAEA4PwczgRlviSbgHAjIu2EH3ID0yJkJJ5A6gZmahZi9FocvUVADvQK14pJFAQcRbIRglwBHimiKmYXgyRcs8FQHH0mFVJA6s5k9jYABFZYQmpigsgBiZwIbEyAZcGmLh5BEcwUB4EQrl5BG70mSmHNkf/oF9MYJxVuZqRqZy0uJ7B1ZxPB0v0cXY3Y5ukyUbYmYlNtimcgp2IcATWlAAmA0DlaZ4PiZo0MJMtyZ6veJcPEAR0eHuAAzu+V5+4SVCPkQPVZF+dwATPB4VpNAYe5AZecI1zuYTXOI9SiY0x2ZqRCFc38yPDpAcGxQ8hgJuBpQhIWQNXgHpB0AFt5WM9UAMjE4AKoAAl+pLWeKBySJPr2QBVyA88Ogt/gBNmshB6AJik6Z/TNVC0YzZnQzRuBHUfplWPyRAwKZW0GJHJWWHGFYk8gARIlWyvwhBrdJuyVJ8ncAQasAALsKd7upXfWUlM0ItMCpHoeaAROWTU2Ak8/7CCMNAGE8VTOjajpIkTtHQyGqABX7CpX+AJnWdfbtAJ9GgADFGkiWqN1rgQBkCqNNkAmxUEC9AGdDBqDGExNlpLgimMiDAIg4Cd3kmWB+AGTLAFaoAJpMoQx7qEqcoPqyqTfdAHm9UDYiAGrSIAG3mrH8Z8ulop5SJLwLoNaWAJxqqqzcoPlciELlmPDLEFrcACxwYkiRCvnwZduKmtfaqbRAMDv4pLqGVf8KQJyMqsk4imOJGs/LAFOKEGlvAHBTZO8ZoI87pG9RpC9/o/ggmahskD9ISwzVqk1kKq6coQajCy2qiw/AAIQTJgewCxIQaiNtqngwADQcV89oWThf8JQijQCiiwBatKqpXYs1HJDwC7EAA7T5agBltgCQshC5wwYFmwB1mQCHoAdi57BIOwAzqAd7DKp5saQKCZl/V0tEh7rD17rJWIL5qgAEbLDzxgAwY3b02rsnswtTWHAVawBliQtSGUqQvAqQCEk/26AB7QBndAB0irCWW7qpiACeoKsFuAAkebBizQHKYgCVmwCJUyBsVwAoLFD1gAClwAAToAA1egAR7gARrgCUP0BTS7t0VQBKd7BygwtkC7jeq6EPOEAldQgT4ACF0wKfpJmiMWuhAwNI96uh7Ap9/ZRja6A6/rAZvgAVcwsmqguJqgjYyrqtbiBfB0B0YQA2H/MQQ5YCJYUL74lZ8QwH5t0AZWUAQcwAGZuqcLgJtnSAAQ8LwMcLozMAN3MAtIkAYAzAPJirA44QVpMAs68ymUQSkvgAVcgAXYiR3uBwPti7wagK/1634LoAMMwABF4MGnywD7e7q90At5gATkai19wANqQFdiUAUXcAgLXL5YAAEklk1WkMOn66cjYwQkk01DCpsd3MHPOwMUIMIkjLp5IA1FWqTlqo1K2AazwQwLrCkODAGmRQA7oMN7mgcLcAf5SgA5PAgXXMZfsAMQMMQf/LoUUAL5mwdyYLq9gARe0Afz2MQH+7hGIMUQQMVDYAdWHLo7QAAaMAhWcLoLkAez/3AHbXAyVsvFhjwIfYvGFgABJbDGRVACFEAB+7u/sIsEhNABduyqtQfFYnAHYgAGpdAigKwpQ6E2qBu/x3cFd+CnHqDDt5zDmvoFMMAAEGABnOzBH2wBFtDBM7AJ0ZsHTkAIdTyP0LqqdGA2KTAAbwIeNYwFDLAD8sunV6C7fWq6RWAFHFAEa7AGViC/jcgAFGDJRjwDw9wEJeDGCzEDHpAHp0d4z9oHCvAO/GA2DhEJ1WwHpAAB58YA8ttGVzALeZAHccABLdACDq0CpwDRsbwAO1ACQ+HGFLAJRbAJFNAEm8wAJcAPnawBJ8wEdazPPBDNYvDPAM3KA43NDPCDR/+jvA3t0O87zi3gAXGww6p70RBwxCItzCVAzJtMAfO8v4R70rWXBkVmAjoBCZDAIiwyG3l7bj/Ipxrg0A/NAVEwzqcLuxwQB5uqASIt1EPszr4MzJs80iTdyYR7BzzABHE6ufwgCJDw0l2QHbNxbtrMpxFN0eR8uhUcB57AumbNAEuwBG2c1kYc1EOB1Ee8v0vQBjNAuFdAB0awOAsh1YDw0h+QHdh8bnvqAQ8d1tkMu8+bupvKp+cGASkQz24swjOgzkPB1hSwBCS9BErdBjuwEJx9sl4FCJIgCXw92jCwxRyQvBqA1UVA0T7Np1vpy0GtybO9v2dNAZV81LnN25f/PQP8sAQsoAoXFQjD7VUIEtofUNAMsAZD1NwwgLxjbbqom8hIYH2QHc/A3MGbcMyaDAFNkALrfNRL4Ar7uxBLEAiB4AKp4AKRINWRIAmLIAg5YDk7MMSEOzJ6Gr8cjrpIgARXUDS2rd+NTdsibQFN0ASwnQJBvQRicODhLQYsYAJKcNeCgNe+KwirMAc64Nc7sARYzLcLcNjKu6cg3n6DYNubzNZDvAm2neIpAOUUEAj8YNn88NFLcAd30ByCYOM37n8rILo6MBRpPETfqbz3bQRLsANkbNZArs7bHc8izA+aDOVQngJU7goLYQEpoNt5wAI+sAqCceMUPr5zQCJD/8EFis54IsS6YWoEW1zfBADkafzLQd3G/MAAmf7RkRHlkREIriAGi00OgcACdNAGs1MJEVEJOVDof0wiT4DNNQwDIcS6RLQARSPL1hflaazdbB3PC1HnKaAE43A9/CPqiz3sYoDgEFAJqs4PlWAiJHjoJKIDeYsFq0uGWi3kiBjZcL7dbR3PFBAZ13M9qbA4YhAIH90EZSO6FgAAzl4TwTAHdkCCElgFEIDNtK7tfau8fOp+jO3GJRALRh3umjzs5a4EqZA/RebpgdDnvywQT2AB5vAEK+AiQsAF1gEBiN7j39noFDsyfqoMJcAFQkDMQiAEl97GJbDY5Y5WqaAK/P8QCH/AAgGe4CywBO8OABagOBYgHCmAAjhw8ilAzLVB0EEJBDlpfTWtAWuwA7lIB7uIA7Ggydy9yeUe80UmUn/QCk2gBKXOAq6wBACQCSkQBEQAC4agBD0QBUFQADYQBIZAzJbsGYick+qnp3xqBW2QB0UgDzKgAjc08VUv2+JOAUIw0sAe1AwAzAXe8ABQDfzg0NPAAV6QByqAAj4QBCrQA0oAAUKQAobwA01AO2Q+xGvQ00awAMrQAh2gAg4KBTyAA8Rc9ABuAk9gAziQAvDF+7nHDypuARhNFRbADypABFHgBx2QBIQQBDyQBxxQC/9rAzzg1ZwF4j9Ay3vq21b/YAJXkARsi9KnxwH8kAaN6ghI4AhB4JhO4Ajk7wUyIAdBIANDNfvvDgYWkAZJIANmANEcgAQAYSZKHCJEkkTJoCIKB0IqzHAgopBDiwViStzxcJCfFxmT+MngYEaOihZmZKiQY4Yfh0kcRrZIoqJDkhb8LPjKBCFNTDNJksg5lQSkkySEOkSsICMiSRUq4hQpcmcJhB6nOPT4wYMDhzhOzPjhd+orh6Zg/UyTIYdmi0lxHtrEmQKJGaf3OMz0Q6RFlBaEWnCQ4UTOwDg0OSxYY2UBBJ1+5KCwwa+FCkL8YlqWw49fTxkdK8tI0kHFxCSaLfjI1IQH2JRIPkYRTWRh/xAnLVpIc+1EqYwrHmSQsIDDK4ePHVbyS6PZCQcUEnj4JRRkojTdjvjJcTIJiQsuPgBYYJEGRZggNqrwgyJBvA0ULnD06OHCBAscRuybIIEDQosUKMT/sAEK9pRIwYYJUODBhSe0aqE5+OTDIYbIJLDBhTX04AcAcSxIAQIOIQBFiBgk8OGJEZvgxQIIuBBCCC5KWIMfKxLz5AAPhKjivF8k4KcKXpLggpcnvhECgiBUkiAWxkqwqYQWY2FgEG0S+QUAK315YhRSQjnEgh6IQCEGHsC0ABQuVohhhRRMoCKAAw4IwE0rLPihByQ6Qw6HF4XICocnUAiCHwjEYIGFP//AUYKEP/ipT5toLsnQSgCqQCUYQB6RK4kebCArDAt2scCCFkMVYg0u1ghVGQiscygJJK6Qg4cnhHgiDeZ84CEICUK1YImpAvkjnDD2gMKQaK5xQNJJM3liFSFIiEOFMHpIgogwTMCBB8340ZYfE1DAgVsTVuhBBkKSmMTARSUYDwkVmEBBMy96OMZbHHCwgIFyLNlDjx8++SRZScGo4olQYVGIB3c76MyLv+Lo4GHjjEu3SBeCKM06JBRuQQbLWujACdEk46CPPPjpwQR+2OiXn08uAUHZHmdFQYaH9CLusphKi8mPk2yWQYLETEDCD+P8oMznDNxCwgsViFKhNJD/iLOBCzQSGeEHexyIVNIqRhHCBtB44KFjDvwQ6iEVNiPL5iT8QCKFHRjNw4+EHOKHYRla8IMJJAArTQWQToobAgegIKGOay7o2kowMhGCnzhasKEHPwipTfCYJlFrtA7aDoMLI7iQXAVH9n76L9vk6GzqzWQIgi0bhMChDAlIAHgDZQeOnB/XbHCiuetAIpv48SRzwgXNmPR4AufkmEiFIALtIQg54LVBjg60lYEHE7hwgUJa2Il5dytHscAEF4RI3wRawyCOnwmIk+C8pmzaAYolLKh8/eB8j08KmpA+figBAk04TgcIcRUL6AAKaGjECAYwAPMBAAyjaEc1RmEHfyGQIgZ88p0PIhO3yGlnfYViQaiagKMBcigF7NPBEkpgAS7ogAs4QIIcFtiCHqTgA2WYQB3KMMELyAwMF8gEKpS4ilWQYQNC+JZN+mMTXijBBrtqghJY4AIfVKEJVfBBGAeYRSVIYIvhk4D7XIACJLjGBSUYwQTY8IkNXAAEAQEAIfkEAQMA9QAsAAAAAEQAeACHAwUA0JeKOEYvEhcJ6birLzgo2KWSxtjop7jJs3dsxYl1SlU378W4tMbZrUdzTldJ8djRzYiNJicYrGhVS0gwzWeMrlV18FaP72eYWGdKcWdr8Onm78nHjypNbXZOKjYbs1aFjDZTk1dMczdOz3aP80eIsmeHt4V09fTw64esGyITyZR6q1hNq5aXKywncFVTkImNy1mHcXZsrqervNHkzqitlDlnuM7h8nimUTkwcDgzbkdN46yaVEhOcCkwclhrj0dP0ZerjUcxqilSkFZvUykrk0htjndz0uPudSlJb0c2aWhMkGhwy0hzrWls8TZ8q0UvVDhMlWVVkHksq0ZO7Za0l6e55qiux3hxbFcyqDtqslUq0be0ijgxj3iGlZWOr4iPKBsSsXNasXeO9Cp1y1Z5zMrLTjcWU2Q7rTZTsJYz9zqC8+LbeYRwspqliYVwk5hqoyYbsCQppmUW5LGbeYVXr4cvV2dnc2Ywi0sVkpeo5nSY7qnDk4Q0jIlTrDkqtk6CyWd21oelsrWyzVgtVkYZdEtulZZO7rbKTyQXkXhSeHkzk1cvq1YZx2hUzdLV+muhi2csnrDCz8W8d4aTk1UVk2qEnK3AznWh5ZaYNUMcrGcuuqU1ykYxs3osxjtNx3Qa5YuVTRIYXVVlcyobcjYWjSgylFeBrIpJr6lNxzgwxThnyFRIzWQuxZgw0qN1TRUlXExiZVQcmKOPsJlPqqaP11MeZhopc0oVd3SEuMW3wytZw3JbzbZU07zDJwgQVFEdjR1Dqx0kuHgdsoekrJdxq6d5pLOL14YcybM05YkY8dC1OTlBOlNLVS5EX3BFdW6Ciy4dn2Qaph5KsC5jwCkpwyhix0pPzWAazG+gw30syIUryopax5xPx6xQ5kh84VkZ5WcV89nhLUZDOm12bz5ggB46ho+hnaZfl6VyuTgfo6/AuMGQ2U8f0JMe3rCe3MM84lB+43kT4JYh9p/CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACP8A6wkcSLBgmETSBihUKIFhmAENiyyU4MKUKSgD5WiUU22IHFu2OtVTJkSYnFXffNS71aSgy5f1Gg6ot7CmhIY4w6go4qOnjz8C48ipp/HPpyGEbKkCR1JYmlVNitQTBQtmvUhWb9K0qVOFi5s5dBSR4LNnlzh/4gyspqrTH0L1ltb7I+dpVKsEZ8KsNEDFzb4NVago4MKFji5ddPQswrPLH6AZOxGSDFIZNo1DmgDBy1lCvUp2JHgtcPODhA8qwupY3UUIqcQjbnWBolbgHyiEJtdrBFedsCH1ykjlbDWMQFwUXRRYvvzDh3qJoys+rDgE4miPcefu1KpRo8tD07D/GE4c5sLBEgQIKCCAwvIXQlbrqLdjtY/GPrqQigYFCitCrUDRyhZCqKJRGj5cQ155eTEUmATLqadeARTUQwEFAiihRA6M5RBWF2ZBsQUrWwS4xRZQGIigKXfVkwiDAtU0WIUDKMfeeh+oN9ADL3BYBAU51BNfFyieOMEmQmxByDUGhkBWE8aFYQqMCgnmlSKMdAXhhB/ceOEDSwApVYX1iJAkilCw4MkmrXTyiVFASJCISjDGyJBfBSwhUJeDMSdAjuuRSYFYF9bzgggibMLIFiywoIYa2kBBBQuB1BOGTAAAYGl5EzGHRyRZRLLAn12uJ6GFAvUokIcvSCGFkIww/8KCHZxsQgUWjnBjh6UQFZEpp1Xa+EGoBWQhC443RoihAPVkAeR8FS6RhUBCCCGCGJ6w4AgvE3jizhQQhREGhcAC5gKpgbq3Hns3MlsPs0B66CEF0r6QBaJANMoCFrh6Mgy4N2nwxQPl+qWCcwJkYGEOBSzAHHvvuhumcvIugEcWC2QhRQIcOzFBArjawYh7DL8BgwrEnXfwTexRgAcu70YIsYQJe1DPcjlEq6cGTDBBRAJOOJFABGI0KwKZEhTq0q92VtknnhR4gIcHFOS4bD0KC+QBHDdTuLUHGchwBBE7EMGECFJY4MQKkVxIgQSrSfQS0wDIuJyNBWTQBhx+xP9E4an1oFGPB3XUo1zUdXhwBAw/vPDDD0RI4XMCqHDjrMP56jCTXnPb/XDeMsABhwcOR6xeBs944EfhhRWA9RJHMLHDDlHoMPsIIzghxu6ooEHBeApxZreEXYJujDF1ZLCshEtk4AEagrfugQdvHPFDD1FEMcIOiIqQgBhSiIBVmaItZJWDp6nnnOtLvGHMIX5koOO7WE+P9XouUNCGBxpgv8MPQxtDBAJQDwIYoB5SuBAepGCampgHIqTJUZdyFDY4HKIOb3jA/N7lPA9MSDn1SB32XpAAAtYjAAHIBA94QAcCHKEHCJwAkGqiqYLUDTDpMZ0APLA3vvFQfq7ToED/FEaYczlvCT0g4QBRyEQU0oEBb6iHtNr2ARoyLUYq6EvLMqCwrC1hf6JrgwzoNyqBtKdr9ctADxKggHoo4I0oLGAL6XAEDWRgCUv4U/kGkKkaCkQ5WhTAA8ZYjzfIoA1i3FotZJA1M7KriK5zXgZ2wMYlMrEeK2QAF1qgAcUtYVTLaYgfm4anvN0BazJIpRj31oIv2FFhBGPWus41OD2tUQEmROEbV7CCAhqwGG9YABoKEIXlBK9Bgnkkwe5whwxoIJUmayUM2qCBU5rRVOp5ANjq0YMJtJGAQvseoiZQDzrQwQ/o9IMHpJAFAXimQX3B07qw1kwNaGBxMGilG2Dg/wUvPLOZ6nLXArhIQgUk4AVCYsEEJiACb67AAOdcwiEepQZOpKIP72yaadIjS6zVYxQ/sOfiWkDSFvAzF9W8wwNWmk36KUIBDEVUtRYaHwSugA6vUEQfpsBTO6gBHmrgnEJKlaOC9CCkj2NCC2owiH32s5/VTKUQRyWABbwBphMInxBYsIIExAcICagHA15Bi51OwQ6eiIQdwKUXiDjMAzIgWMR6MAp7MsELLeCCQMxg0tgx4Qgy0MBKzViPgbqRnBTYgRCKpgAxLDQADBjrWqfQh7U2UFw3nJEkqVqAoz7uCAEgQD02gAIU1IMDXKiBFxynAfrtaIww7Z4TFMCDev+sYIAEWMZYp0CBBUxBDbtaSA7qJpj0eAAVS3gAYaLQgySCwQAMGG1pp7sBNnCgBUy45zUF0AwROAKXBn2jAghAgADgkgfkXUEWPkCBPgAXXCoIAxCqVAA8VNUDivDAcppLyRowgAOjJe10p8uGGhzBn/LTURYcKpAAJGAFAajtQntJhxUUggJZ4OkUCrGQhwyAAqhIRh8eoIgpOCuxO5CCAQjAAQgUhA0biHFpN2Aoe9JMACKAo4MXulAWJIAFvFDAK4phLDwAAxjO8YtMQOwKTnBCDX3Aw4WmJQKB/JcDWI7sfwci4Hpkl2BUFcAS3vi9CbBgNSKYrRhYoIAViAH/D1J2jnMkkIOHMMKnTn5UH2RBphdMILTkDTQBtIxlAAu4Bi9oblUXoM16JMDMbE4A2sL66AcnsGpynnMWQVEPV6jB02rAw4UN9SpfBjqyHEA1A1ws4A28kBliHmgbHA3poLnKCeHzngLsuz5NyLl8AnEFqKfA5yxkgYQEJC+hs0xo6aJgA4h2nQzqgIY61MKxVd5BCIAABLQhqmiF61J6NOHrKqoAFNtwRTdoMQVRF8LYiuilsgut5XobesYcOAJzM5C4akuBoWi2gNreuLt6tGEJXpGAJsy4UVCgm6x+yEIh3p0FRQRgxVs+bb3r7WwUsMENPRBAHdBxCLAtwcwN/2UBt70XAYGMTgAJ32GYTKOCYWjDE93ohTckfuEsFK2FWD6toJWt7I5PQgMCmAU7jjGLOzL03yyolo+/CbYMFGAwgyMdqbJgh657IxWyWNW0ykneGgSgBY4+IRcEXYNB16O09XjhIHTxhS/sz1X/duwEhObGANjMg8pxlwYDpdZH2aEQq3rBCmpLQEofIXxMaDl5BcKxvNaDDfXIgQyOMYlHTOILuU75QjfWxjckrogJ0xOXmIUKNWx4VUU7IccIyESOnZAA7zDhCQJQAy6kFoZM18UjasFQ+uyA2ztAdj3MYIYv9OA9LXj8EZC1QzvgYVVuPKGjB7jECLRcIOTVJf9kU50qGczdDJNwcNRXUw8lpHj3BoDAs7kgg9m50fbYrIcfrp/5UtfD+wkgOUdwAidgezwQWY6WALs3aKL1AjIwCabFBTsmAokxH97DSwdEWtbVAt5zBHdkJsziPIcwBZlHEI23ITngAj0gBR4zXgPBUN3GBCdQQC8AA6ZVDxL4aFFXLVv1YBfHABp4WmZXDEcgBo7QCRTgPHUAByRIASomeyKwGsl3VGczNAwAYwSQAEDgIVGgBBNAR7kwEA3gRtiGKArlg9BFWjSWagTAAxGAK6yQhFvDhBYSVg2WdhyThyWEXqRFeQlwBEDzKiYlhvXQAo/GYwu1ewHABY+ghi7/xgBt+IaOwAoDpTojSCYC0UIEYHYRADRCE1r/1WUBIDQDVEBcMAMDcQMCgYo8Znu8ZwYHMGOPGIlYwAtxiAbT4weHcGy9hF6DBomilWy/+HYzJhC4NVrLRxANMIaXMBAlNQMIUA9IUFpsAAFsyAPmhSv1s4S7qHiYpGwbF1kEcAUsJmOYF2OXF2OYJxA3cAPLOIb1YAXyKI/1MIbTqI5i1Ybm5THbaEEa04vo9V9XxoYBQI6DBmBilY74CBPLWBDwiAQxpob5+H9AEziEAwfpsATxVg8GEJD1No4ElGq1NXkc4HZscJICEZEDQQM04I7vaI8pGZEeB4wohAUCgIsX/6k4vfSNQ3cF5mUAAbBQuIRC0VVACCkQByAQ79iOTNmOLvFsfTiOV1ADV0A/aHBHeHQEEIZJK9SV2EhwE8AYOSYCPtBG8jaQjzCGDcmO7UgDBZGU0/hsJXkFPhkBBFAhdzQ9sHNCB1QQ5oVLK0BmH9Ng2BgALaRlZlCPLtGOSTkQB3AASACRa9iGshcAFICLXHRHR2BbENZEf3lxgiYQVyCQPPBQh8kAgwCP5UEDSHAA6FiSdCB7WBA4mTk9mwlhB1heZFZCBnlqAwGJb0R2ogUTjVkQqhhgQheMTmABVYU10SIQEEYAWGhQHwOKwFiUVkYABkVAPMAFqpmKizmGx/9ZXcl5Qj7DHgswRFd1QoEJYQqABQtVQif0nlhgSaNJACswAVgQYVxwnHiBBDSgllyWnCQlWOSCNRngB0MZAIFJn2b2MSxABZNCKSAzAYHQRjAln/3pn/VwnBzaofXYADS2hgxQA1/AScrlLlfpAfDHoOIVW/EhBN4kEJPABdG1AlMnBntoBk6plOLJoe74mGP4mpMwAy3gTw8AKDfJRW9wcQbQoG0mBozAGDrABGBQAzNgBnqVamjHMbhEAGsZoqrYo0oJoo9wjwLhezUABkgnIZeJi28QAQYAlOJlXgs1O8eHKECzRPUwW7hUQGu5lExZpsdJA4n5bNZ4ijMQBP7/JADkxixXGUVM1KAu2kZYQALeRwIkUJ8B4H2X1J3weAOPeQBkSqod2gBpuYz4WKRm5wQmgDCQWm2c6aK8xEu6BDKaGgqZsKuhEGF9yQOToJgNMKot+Y4gqooN+Z1aWgMRYAJeAKs64gFQukuemY2OEAiBwC/1WRB0wAVWUA8IMKxC6qPw+J2KWQ+PwHybRAREAK3Q4wEvWqeXxKA62ChB1pcDYQB6QAnfOqxpORDhWo/u6BIvOYZWkAs/UCr1sAgM6wFe+qKXNKe6VIBslGyFiUL8FI0NwHzLGK7LGKBhKobfShCUcAeFwB4M27C2B7HVOqcu25HjmAlvqABg4AUw/+Cxo1qwxkqwA0GPlKABcyAQPNUHi+CwE6Cj4gVhmlqfA2QAvUkAVbAHgRBO/nSz4tqa5nquzSgQlzCGMEAJ8fizGgAKnqBhfUC0inCISIsFgVAGuuZ9ckqXURsDFiCDAVCzd+UGWZqzDgmiBNG19fC19TADcVUAoPAvZtsHaRtTLFAGTZAGYAW33BcKFdAEWgAEP9OpFWACFmACJuAGXMCxqhmNZfq38Si4bvADhAEKmzAFkdAoYkAL9YBtVPAJabBtAsS2mhoBFeAAQxAC/3MEYBABJLC5FgACIDAGYACN5xqP9Ji18AgDMEAfhDEHsSIpjRKYC8UKadABI0AEY/9AAm0bCBUQCBYQAkmwAxqAV0FAvOYbAyBQAcg7Bm4QjwNxCfTYvGI4CdI7BkyQAzfxB0IwGxJKBWtjZlQAvMI7BpVbBhVQBg4ABOp7ojUQBMVbBuZbAZpqAQ4Av8lLDEHgBiI8AwK6tUppBjOgB5agAXUmAf0hIhGaBlTwnipnpQxcARdwARVQARZgNnhVA1WAAxgQA0Sswc1qBCHQwTHgAIAACBWQDSSACYIQBKlZD5KgjI+Aiv1EBEXgAmgiKRIaAvsSNAnguDGAARiwuX/VAjNQwSmQwzq8w4IQAU5gBEbgACAACCDgADaAxzuMCRosCDWAAIR8CZdwxQ0gjzD/YAkmwG0n8sJhnAbhZAFNUAYYgAM4QAJg8AWDYAZXkAIYcAFrUAKXjAMpMAbsupydCwImAAI2oAUdHL8xoMGYEAQzIAnzSMiKzASNHAKP3B8FvG0g07YanAKCAAYtMAgc8MajXAJrcAGXnAImQASe6wB4DL/wawPanMfIO8uYIMXEMAPyqMtWAANMgMph0AhfHMxG4ASXqqlTzMZmUAMY8ARkMMpwnMadWwEx0ARNQMRL3Mpa0AEdYM157MSYkA2APAbyuA4IYAWS4AVmMwLp/MvYSwUOYAG7631B0HtBgAFrgM8XUAIkrcOYQAL9XAZEXMmsvMcdkASvbM3XXAGY/+C5YGAFMyDOVmAJZvMV6owif9AFEprRFhAIxKu8FbwHoVwC0CzKIX0BOEAPKYDD0NzPTcDDx8vHMN3HsIy8Lc3Ky5vTMyDRTEAY3vHLEsoCAjdAJGACERAEQhzKTU3STG3KKD3X30DEHHy8gDDQIaDNfYzHXs3KY0AMg9BUGvA4hJEHlXAiJyKh3KbRxOt9OAAJ+XwBTQDNGJACU03EI83UO9zPAtfBDvDSgA3Lgu3Vngu6MGBP/VMAjP3TjAIE2yZwGh0AJBDKpczDs0wCgiAI/MzPmW3XOzzagm0Dfx0Cf83Hgk3NhF0PXsAEPwAN/lQJlTAHjbAJm6By20YFAv+HqbpdBYIwzSZgxDc8y46rwWPgqpwr04CwxMgdAh0A2H0MAkaAvJ5rAStsT/00B/7t34oiBNyWxBbwwBjw1mPwOA7gwGPguTtsvKzsuRLOwdasxw6gBdrcAX8N2HaM33tsBD8AUo/z3/4tDYwg4CIABBntAE0QAdj1AkSw4Joq4crrv6pcBiawnMu54njc18idBCOA3IBNBKeAvNZsBIZgCD0QC6OA3dc9B5WQByjeKAJnAkzwAipeBpiKqZs7Bv4EORbgwLY95kbQx0184S+dBCGAO3/NrkbuAEbArrQTBXlQ50+eB6WQH4jSw0AwAgWOqZ0Kt/67AyOQxBVAvGP/bgFIvNxMfOHyDeRJAOQ2YAiMvMc2kARG4LmLjQt1XudDkh+0rdyZ0aso5KlgwAQqntkk0KkkQOYjgLkcbOEYHukjEOlrTumnYM3eawSWIAg/4AKlUA+l0Ok8CCI+EAJpoAVpkAa0x0QnwAROcMa6ykStTgSLbgTHS+GAcOGXPgJR4AxAPgKGcArWbgT1YAg/4AVWvgOJ8BCJIASeXi2kMCcYTQVA4AQ8AJSdCjJ7UAXkdbERQAS4g+3l7c8yrQWz7u1JkD3/U+5G4O3UDOchkAjtPgCJMBvFPu8+kC8OQAURVlv1sKsGSQf5jkIJMPDlbdVLbM0IbwO4kz3ZEwuP/0MEhnDpSWAIRLBtHeAiiaAQryHA1VIKOsAhQGDvTjB0WhZoJZ8ABP/Asyy/HFzmd/zwMB8FMv8DlvADtS7uI4DEO18PPtABweADOgAFRzEEiBEC97FtDmCdG6f0AYAF1uzPTy9wSHzfyIvE3t5cTK4BhnAHPwDkSP4DRvD1HeA4HQAcIwADLzAE3kvQx37vv6hbDKBbgWYAJKAF1GzEPOwAyk0EIODBVG/1dVVNPXAHubDw4/4Dp2DusDACQDwLbRAFLYADNVAAMlADb9ABpjACWpAZe1ABoUBe5HgFmXAFPNAEkQfNOOC5OY/tT9/P3D4EsIzwnt/HQ2ADRnAKWf8/AvUQDBoQyuKAAY8gCCUAAy5QAyXQAjkwAtMwAobkA4TeAd1L0Mi+B2VABG9cAUEQAyYQBQDBZEwFghUcOAgBJImGFyOOHHHIUEOSEB20hChSr8OXElVwPOHwBFGNGYIw6AriRsYMDDi41KjRAkYNGDNqyAgRb0SQJhHAgHETIcKeICSMkohQI0jJK4NamklRr0aKGVVfdKgXpoObJynIXMCAIQgZHHuqVHmCY0MJHBgQlSADCRGZKhjIBNkxBEYFMi1rkLgwtEKMwRgCXxhbFxKGeiUuPCkR8sKXJL9gheAK98mTxl0xXBHJIUWJeimClHC8piuZEjVGdKhRAgP/GCYtwpLAESMGicGEmzxZU2WNuKhPLlxY3PdLB8s7We/pGzL4BRwXEIFNcaUejrasMaC94Ov1DM4wZHy5wJYEYRIgxhgl0zWF3CopQMp+jGO5C1gdZgSv564vUsCBg47aquGK43wJgo8rsquCCxyqkKGDF67oiztEqkPKqDFAIGKHGa4byTBfHhwEh3qugCSIHtJwQaMX3HhDhpuK0GCJetwwD4Yelmjhix5eIFIDI6OQ4YEQLggBBh6P0OAHgYgg4ogfiBhjBx9YugCGelpooYcdXshBBg3qkaGHJhQpoB5ROqCogxFC+GSIKOpxwYcc6knCmg5CGCLQQJtwIIYm/8oIpZ4KhiiiiAJ6qKeHERzQwoZVfHBhiBBqoKseakIYQQsHLAqUGgcc6WWRceph9RcfbjGlFUI6aKEKGHKYwdYOPkmjiyJy0EEHKQxgNYAA6ikjhCNaCCKFFAQB44UhtBjiiBle8GEmDUIw4ocf7mgmCg3ukKiXZA4RgFVWixCFlDkI2emJFmTAoIQ3sOqgg0DzHaKJNJrId5UQZsABrjWCqKeKGZIYwgc3MIDBBZs0ytcII0Iw5I56KOljiTeSSUXddW/xoZQhNNijhDZaeKKKNsYc5AsjZ5B5Bxhe+GKGHXKoJYWQIJEhgzvahKGNIC7gAgaPzGihljCJtAgajv+nOCKVkEUOwwcf4JyFrRlOEy0FM8DagwOyOSgQB6A17aGGllNc6ugUwOPgCgOrAOsRQapoYQcHPJhCEQ1SOUQFkQcowge9vPoOLLQ6gqxlyNYYzauoDt0hiDXQXqMERLraALogfCkBtBLSSiEsHGQYYgE8lpChF2AGELmexIeQwb6qLkhdNcY76qsEr4ALYgQLHHjhtLVOryfsC9bgIggM7KtC+OlLKD4ETRZ44Q1OJKAd6xFWQfkCGVpYAxEFhYdMRcgw4KDeFNpIgwkqUC5hkBTSU9CwC0pzFgYgEaAU1AA5FdKBJnLwAFpwwnC1q0cOtKCBKgShADK4gpe+UBr/DFQldTMoWj0ucIUeOEADEyRQBuoxg3oYpjU1+EILalCPpMmgeSxMgRvyIoECLEENhwAABFmVrx28qAM7yEsS2tASAWSgJbbjSAmWY4ElGKED5+vBEJKAsyC04AEjSMIRNRCFECThC9/hACIw0IIOFIEChVgEHgAQRAiGwRzTCIYP/pCGDuSgWjgIQhGOAMgRDOELLcqit36QL4YVIYxyKiQk89UBHQwhefVQ4wVaMAIdfOADfqDAHOnIqgGEQQLsEoUoSoGLenxgCDbTgJxgEEtrIEkjSYjCD3rgAmckoQguAGYYccmMHuzSBQX4QCV7AIMgBEFIaTjDBxZwiAHMAjEgACH5BAEDAPoALAAAAABEAHgAhwMFADhGMNCYiei4qxMXCdemki83KcSJdbR3a0pVN+/FucbZ6Y0qTbLF2PHX0fFnmu6Irqa4yU9XS6tnVO6WtlhmSyYmGPNHiO/p5vN4p+7JyfJXkSo1G3FnanJ2bJNXTG12T0pIMq+nq8qUepCIjKpYSnI3TI41UreEdKooUxsiE7jO4W5WVPb08VJIS49IMuensm8oMc6orqyWmMqJieOrmbBphk85MnE4MpBncK1FcK1ocM+XqSssJvI1fLzR5G9ITKxXco9Wb6k5anBXaWtoTo53dFIoK21INo5GUc94kfUqdpWUjsxojNPk7pJHbatFLrCJktC3tJI4Z4s4MYuGc6+ZpbBzWsd4bvGoxJVkVPc6gSYaEncqSpN4hrJVK454Kq51jE04GHqEcGtXL5KXbZmouqw3UqxGTfPi28pVdvC3yfhsolM5RqVnFeWxnLElK1NkO4x4U6g7LNOIpc/V1JGYqMdHb9LHx1loZHiFVpVVNIuIVKUmHHJlMohKFbK0suh0mjRCHJZWFbCILsxYLXh5M7dYhMw3anFLapSENcRpVKxVGs9ZhdexlZNsg5WWTrKVNcppb8mmb1AnF1JHGbF6KclHMXmFmIsqM4dqLKpnLuaKluaWmW0cL3A2F5ullaqmksooZMU3LsY5TtLDvE0TGVAYJponGpFmG5ytwKiWUrKYc7rGuchVR5qicrUrYbl2HK6nTqeleKq0kMIqWc9kMMJ0XNN7odS6wjs5QDpLQnQqGXJJFnhkHXx4h9ZSHsl0GMWbSsinU821VeVFe/edwVpSHVtTY4wdQp6wwqkdJbhOgcpFVdmGG8i4aeBXG/Ha4isKEz5QOjtSSl9wRHNZG2htgJhXhKkeS7k5H7OkOcEpKs5gG8iKLsqKV8ibL8a0M+VnFOeGFx8vJTlsdkIPHl4uTlxIYXs7YY4wGp2mX7yDH7uwQrjDkdlOH816Mc+SH9mgLNrDPcnDasrRvvUebuJ6FOGRHfHRtQAAAAAAAAAAAAAAAAAAAAAAAAj/APUJHEiAwMCDXCilKsiQS0ELFgg4PMLQQo8YmaD02QinDxw43D5CA3ZJHL4Xy+AgKhZDn6c7B2MyjCkwIsObBVVE3GlB35EYQGPM4dgH1cdRpFIUAjYK2jiUZxAhOqLP1CmaA/1UwqqPg82bFrgI7AHxBo4jFoICpdJnaNE+3EZdglPoXdN72uBEvUOV60AxBrEisWYQ4sPAPRLjyEQFB9AjP6nMmYMKFcdLmJcCG9ftY4o7J/yKrilmELueFgzo9MpBn1kcsKm84NXYhKeMb9vOKVSoJKNCzrQtS1FLTd+BKgKP1sdFjJheFnsYkG7AAAcOSBprdxyjcXcqVNRN/4bCu7ctRow6w6l1psRxgQWXE4xvIHWA6iEMBGDxAjZsINxF1h0vqEABhSuF2ELeFy+M8tEZMbjynnwDAZBTRPqkVl0AHBoQAhIfBgAEEjdAdoNZVKwFxReufKHgF19A4eAZOFBhXE0UwjeTh4Alpt99HHCojwQSJEAiZCHcgAQSNcYIYwmbvPBFIc04eAIlNorFRSY5xjeWHHuIleGP1v0YQAgJAHHiES58iIQ+UsYIRQmWbGLLJaTMQUoSFvyUY4UPjVkEiNV1VZ1+QXLoZghnhfAhCwJtssceJZQQCTjwQIFGCZK8wIVNAzm0XEWHFqEJGZroE8B1+pmpTwgCsf+gJIk3sKCFFki8MGkJhESySQlYLPINITc41GeX8VFnABmpLEsGkGTqF4KQspoFYgJFkLHkC1Toc4UlJSxyyyKWxAMGAWFxAQAA8s1kUXUc5Odoq61yeKaqEiR54okhZMvCm/okUWkJtwRrSSzn9lDQuu3G1xMH+lXwqhgGTHOofqoGIFARIfSw7w36+KEtGVogYPIOOyAQLCF75HdDRAyPNlNXEEnrRy+qbliovQFUAEIC1d0QggRFFKFPETnkIAQCKCNAwxVIkOzmVwYpJ5O7haYWAgh+gJAfzxJILBAIVeiDHwhl6FGBB0YIkYQQOeijRRA7jODHhyFYABsSHYz/AatfN5k9HcQGVDBGGXyMyfNBIOhh6NZjVONBFERUTgTcSiNwyzdkOMqBwAhU4UFPgJMKb3VrI17BfRlz6HPjjvuYQAUVGGFE5W2YAAQQJpiwwxXAK5JACCXgwLHVNAUu7aqoe1DGLCCsznPPPovtIwhk355IG23srk/cv2uhT6o1fVW6ThYkymrYY7zCBwgSCInv6/qsPl0IY4DQgQTdE7EDDU4TQAFgUAAUaMFRftCCVwKHlYfUJ0jXCVLq3qeHBAhJAqp6XYcKVQ0QuKANLECBAAsgAAF0ogYoHEAVXJAALUwgSQy8WmEsoDGegeBwfNDDDe03pABgUGLT6UHP/0BQBBewAAElTKISB6CAGXRgUHsQA9UaSJ+IEUlsN0RbGcbgAQtiMAAJUNXQClU9FyDgAChAwQFoMAIBDuANTGSCEYpQATJwIDkzk6HgQuABIoluDFxE2yw8UAEiEek+9wmiAeoXPTMeQIklLEAN3qAAKczACB6QQwjumBPk6QNrNCzk2jzgAS4ejglVoF0hD+mCQwlRH9GTgCNHKAAaHOAAbSyAAhRQAFbwYZPo+pSXdBSYIG1IAnmgXQdIWYUqMIEEgMxDMom0C0RySAKxdMEEDkBCFKQMAVcQCAJGMABH8EEOfDCEyICpnAs9bIMhqEAeJNCBDhiBBPicgRVI8P8LL9Qzma1U1BUrcMQDIGBELyjBBCagj22OoABvkAMZFEFRS0RiG4ogHbo2NK0fzU8CyCBCPe9JAn3u0wse6IA042evMPpQDgfQAhAE8oIXLLQ/SNDCCN4wAk2AwRepSIUbCDGPSBhEBfpJgCETEEaBEMkFIq2cEWYgAhFYwQtYxapKJVBNMNpLH1U4wEI/AKcSjAAB/UkCAgowgBFE4qdCdcMgCHEuAggxbFXogCqLEIczQbWeOfDCDKTgAAfgYQYkMELSMClLH8ZPIBVQYwlIBIQXXKEAB7jCQgWwy0kQwhe+AIMlNGEYLnDBAErNgwf+SMgK5AeqUuWsA1pAWwf/aEAKPDACC0QaPyINSQIeUCNDBbKDA9SAhDQQABMV0FMxVAIMhCDEJyVyAx+qFpAzmIToZOmC7gLBCMp1AAZoS14M6EMDVsjBMg/JIWqwYBFtNOgtDwBHATwSjm214w3AEAlCGEIFzEmCD1cbCiaUgRWvKEMRngqEHChXAeLFwHjJS1sMyMAI/mSpxsgwgVyScJwCOO5CH8rTSoiBDGBIcSXwSAAfVgGiBWBCKGZRhpSywFY0YCuECythfaRBwhWOAgs6QIRpJWAaAdDCLUuIgIUutAQIKMEVDjAJVpCBDH44xjGuk6GIBAAEk3BEARxB5lmIzgNF0AIK2DqA5WrA/wFpKGxh01DbG/vWXkW4pckmULxuFfcKJcDlFdYZQa+8jAByEMYk6CHmAoSiDFUwQgdKptw2W3q5CtBApsVLWxl01wUaGxIIWIEFPgcaAbdCAAqaPE4tDO86goi1Vz7pDHAM4xnPKEABzIwCxRphzZfG9C53yePxpsEILtBFAIyGNlaItVIo+4AWdiA+fZzRD4JglazvSGt5DGMS4NZuFSD9azcKWwOaHrYGflxhGbBAF8B1nB5CodnJ7i4JSdAHWb2FAsdBjIbb1kkwvCGMb6/inCA45zjZnGl0D/vhb6awBozQBhdUQIf60IMcGAobfQSBbrecgKrHYDSyCEIgq/+CSDBiQfBVrEIORSvaFdy4ads+fJdM5DRt9cEDUDsOlhUoAp8bWgJ8WxuAKCgDCDRmkQDEIQ4JmHUsLGEJYRDjGWC4ctQuC0d02zbYTGwzhCfcglJ0wAWgcActQBF0hn7gpgk9IwpoEL0KLLIH9aPdqjhAhugSYhiysIZzQhBCiLZZBgKYQRRULQApXFoGOa8tsgHRClCAApUIkPYENLtQVT8SBLAMgHTCWISl3ycEmlBEJPprYjHU6qHdVDUCFPu9HLe5gCaLAmEdEIU2gIAW9ahDHWiBgIHweQLSdloB3geC6USMkB0Kkj5W8dbWh+CyBQBgAHUtAJOJsM0CSCP/CmYgAylIwdMVoAUtWlEHKaBAH0i4dxKAcEQB4qEOTGilAVhwSS0YAVrLRgh+4BxigATcFH4BlFy1hEbANgALyFmapmtDRnl1gAcFpAX9gQNLAgRqJkCzhQFS4AEuAARqBE45IyR8MICupwW6hlkA9AFJYzLeVwMQhntIZGkFwAIeUAot4AAO2GT60BgaaG0jMAI1wGn64AAzYG1yEHRwojE+Mz7OgQRrFnuwcQMewwIfEGgDAGcDwFD5lgPAVgQk0AJOsABS0H18VlMvADq5pADjlYQagHisUAVXsAiXMDuNUwZgsIIC1H368B8sYETgw1n6gAEwgABJcAMG0AY5/wUD93SG+tAAmKVZA6FQSCRAcNgCGGBzA1ADNBAsrqCHZcCHYhACa9WCi7dqMmgyAgADAzBeDlAAJmMETKNkiCWJDRABM9BkTrZQjyRAdTBenahpnxiKi+AKjJQ4YPAhVWhpiAdATfNgGjBhDiAAKZNcbCUFIuAEkhgB+iACKOBkZ/RIMoAHC1BhhaUAx4gFtzCKsJRw+kAGLEBimHZ7NEds5BVnmBVenYgH3rgAk7iLZmAHURAFVCUCgNAAC+AEO+eJNWBfwcJIelAG8/gBRohfNzdsllaNcRhhDnCI5uUAPzAQK9AAuxgBZmAGEdCSEcCQDtljDsCOEXkAO8BQPv9TkSEjB5I0SZiGbsZYaUz0ZjMZkhLWiYXljUq5AAuAki6Jkg2gDw15lBI2kw4ojWNTiq9QBGuFQjUgbLsEAwKkacfVZrYFAxAmEHAWYRggiSsgEFDJkEzpjVTZAvrAjg4oAFigMRX5Cq8gB6mYQsEmlsEIjEnES2wlZ4XVkAMZlTHxA0w5lzEpiwMAAzAgA2KpMWRTBURkBLDXk15Zk5k1AZChDwegDzHATQ81lOhWB7uIklJ5ECsQmZFJl5yoAZUpljQwAGHkM2hWBOU2Qi1IQrhkX2jEammkXCUER8OGBy9JmwIJnbRJl8X4idmHRExFR0EHnCjQRpBknOZGZrr/Bos4t5xit5DSKZXSKZBnWJW4+QYktAOSUD90hD0g8GtFWEJFqGdIBIvBJmfsOALc9JUDEAHpqZ6RKRAL8APU+XUDEJ8lEGoVoFRFkEb7OV9Y0GQzt1xip5gK8AYGJUA1IAVySZv68JYmypBS6QTuiY9CAATSAllVYKECektYUGoiN0IHcKPJlVxo2VYTgAUhJgUKmqArUJK1eZILMJt06aAzMAOD6CGQVQF8QKMY2mSYODCVEizBIgncJFZIVABEWqQC8ZYI6gRKepJtWZ0ywARO9DUDQTueeaHzxVD9YVPcVAClIAUKYF9QlllIVAN4MBBM2QBmqp6x2QA/8AMN/8CixVgKIjADXrA6iQIrUAdTdHpLV7AHlHAEOJADUSADInBbNhcFOGAy3PQGsFmojikQkCmVK/CcDFmVPnh+UZAHPIMm+hAHctCddGpfEyBTuzNT1vY/JRQFxfVIbIWSrNqqCqqiLXmSw1iM3CgCudUBASAI8hMHIKBGv1qjO6oENEADSqAEWKAEtaSAIkqizXqoUrmoAtmSUCmTkIp4KANrGsNU3YpL4FqE3mlQPMoJnTCwnBBiLVgDpcCoT2mocXmoLvmc3liB50cDNuAF+CokIDBfGvudO4oFaiAJN4oFOXZcujaiBcmSL5mSKeuYsfqws7kAFYgHliQEQnAdX/8FSxo7X0rEfQY1MLegrMNZAHaACSypDA/7lJM4iQ+rCivrlGbgBYkAMaE2NqgaX8EYSSRkX6yorLfXgiRAtCuJsvIKm1D5lHXQlEzrkkNLBJWAMQMBAt73UEuGtQcbtJYGnwWAWL9gBkY7tq/ZsGZ7hnYwuCs5tB3gBgKRYooAS6xWjnM7QpYJdpYJA8clAPxEAmJbti5pBTzAAzJgBSLgkpNoB19rB2aACfU0dSkGBooABt7ii1fguPnZk/45ABTwAE1Qrj3qBf2ET3ZwtCKAC42gAx9nA2EQBqALjg1AuphgByLQRwawcqvLuooAmAylULFbjh5GoJxQDEOQBE3/Y66NcAfEa7zJGwG44AMp0AUmQLOY4wVRELoNIAKlKwJEMB3B4AZg8CtStgrjaKdv13k6K0kD0AlqwABtAKonUwxLkAIn8ARPIASPYAVW0Aii4AkG4AFMEAU20MFhgFWgu4ukSwJRAKM9IFd78AWbYlZiBXcKVSnZG4ydoAQ6IAQkIAJNYAM7gAgpEAMJHAY6nAOH4APZ0AN5UAcagAtKwAMcbLwlJQINUAr4FAY58DIWMAfcMidogAaSMAKctwc1RSk15WSSIAlNgAg6IFh00AhqoAMncAMSwAQi0ME2MAQ9bABMgAEQ4AMbYAxrwANNcAgVG78NgAdWMAOP0AHF/2IBBrIiJYAGZ4AGIbdQYFxTUFBTaNAMiHAGosAALmAEPAABOrwDy8QEMkABOSwEJ+IBreAAD7AEFwABMBDKOWwDORAGUFwHImAHWCUER9ADcqIpkHwCZoUCCvUBW7zFj5wUDJAEJhAAoLAGGfAA5RoFJLDBSgABdEACGtwKGgADF7AEW8AGFAADFJABtSwEuPySqmAGJPAINoBvMAIFk5HMQZBcxtwMDnwCW3wGJ9Bg91QHDjDNGZABWQAIIiAFMJAFt8UDMKABa/AAPgDLD5ABFJAFEIC7VKzOVvCShZsD8XwC8zwHUCCkMsADJUQDapACJpADO4DMZxAEYUB+GP/9ABBw0xSgAe1HARed0WwAARkQzuNMATedBVnwANRMAjtgA4/gBaG7kiRwy0LABYwQI1RQ0l0oBSYjCSfAAkwQBh+nA2cgBDugBBmwAeTMA3TA02tAARuwAWctzmywARMN1xRgDBDA0w9wARkgA00cWB1tBqrgBTnwCCZA1TEyGYEmAzQQBGgQBDnAuWqgBncwBCbQATvQCPqwAQ9AB55919N8ARsQzj4g2j5Q2hmQ1zzt1j7wAGuwBkqQyjYAuiv5CHCjMFWd2JLRzwwg003w1k3wBDo4A0rwAG/d2Z8NAWxg3BewBc7d3KL90zed1xsAy0ad18j6BIcAuiLwtDT/GxHoMc/0fALkfQJBoAZInQFKEL8zgAsVfdbUTAfZHNQXEM7i7NxbUNFAzQapnQFbcAHlnNMyANbaHQWAAAhWQGRAkBx/MAi5XQJQ4M8MYN5qUNAUMAOAQK4FnQFzvQHiWq50Ldr/Pdr/bdEZndq3y9cXnQWovANB8ATMMNuA4E9EZgAE0OC5/QV7kAQn0MxB0AQ8bQVMYAXvPc3G/QAyMAPnfdwFndFHftGxvQYakOJsgNHAbQNC8AQ6cAhhEAWEXTlENgiD4AaMsAm/8gLk/QRBsMQ8QFXK/QDLrd8wwASXU+EUsAYDbgNN0AQPwNAyYAMGPgM2gOIwwOfo/HEv/y7IQZDIYJ4DbvDojy4pbXgCOlDWUeC5t5sBjfDexgADOQBVatAE5ccEFQDSHRwFodBHHZA0QnAIPKABuQDWTQABuUuxMH4IOvAERIAMIZUIkP7oqbAHfJYExNsENLDWEKAENqADeZ3XYRDBP04DJOACPWAC3ysEkO0CR2AC5L3lgG4EEkAEP27RMuAFJjAFuJ7riZAILoAOLiBXYg7ve4DMH9cEoazRQmDsPEABPGADahAE2J4DvCMVKcAAE97jQyAVQ5DrT5AE7Fvvd04CLHACd8AMDC8ERLA9BvAHHD/mg/AHn/AJ3fLjSsDZYdABQmC8FGu8sR0EkrADarABgf+ABQZ/AkNgxze/8DowBFNwAgVf7G1uBEmg8zowBV3wBB08HX/QCxzf9LARAxSuBkucA5SeMi6+3l5Q1jwtsANwAF3QBQyw8xM+BTp/B5U9BAyg5oDeAW1wAjSrAzrAACbwBI9AB0TQA5/wHE3PhimSBD8eBRLQBXcQCAAkriUMBDZAAbuEQo5wACcA9m5s8FNA9nAP91Mg92+ziLd8CIfwBFOQDolABPAs8JTgEJTAhmyYCTHwNtwuCmrwBhEZfjmQBI0AAWtAk7rm9V1A6ZfPAJN/83DP8wb/9UAwAzTQCIHs+SbQBimf61dS+gCAJZdcUykCFFGhA2igXLBProH/8NC4yfiOIAAm0AVTUPQ1//s5b/QmkPZh8NsQYOtGfw6JIAQnkAQMkCGUUBC0Mf0v8AlPj28AkWTHgAEKCGpwoMEgQYICTjAYomPIEAYMplycOGSKiS4mdjTKAAGGEhuJTnRMZOLJQ336YjBIFgMHFFIpzlChcibGkRNJdAgoqMBBmoQLGdJIkYKBUgawUpy4OGXikycqgzSBAIFOGCGJhHR84vUJg5YMWLBYWssECRZKTVTkKbBgPgd1HRgdwCkFCyZMSIiwwsJp1ClPLnYRclUJLjo5TBC5BlYIEWxP9J0yIYMCqCptZmSQYcCDlCoMMpkYkuJOICWcBqyBMaBG/6fYdzrwuHCBwoYMY17CypgxhQ4dahqFAbI0osUn2B4RMaEvWYcHG6I9qENHHwlyMvTNuGEihYkqHmIAeXumYsUznNSwgLHE+oXQRUR06MLg7cMkXXIISSKxE4zogAX8KhrihCP0YYAJfSjIYAsNfFhDBhHoeKAVHnjwQIQHMpBCBhlmIEEGJkSQwYMTLsjMBxhEkAIPGaR4wAErUASEhxxlUEIJKy54AA8IspABAhGOREsfLhiYwQcI5HvgAQqWgCAQCijwIQMM9MnggTX0WYKNNZag4IEleBCPiQyopAAPOtgIycwsLtiAygvi242NQLLQZwMf9JnwAiYYkOaUE/+s+HMJH3zIYlEIHoBhizU0gEAfB+igoKUNtnByCX1keEsKfR6YwQgPHwgkvi0oKGaJCwLJbdUtohHJBzr1XOKBQQHAjAdPH7DngQlX5W2DNTZ4QKQsMujyVyw3yOUtEbbIggQPmNhAnzWw1I3RKxXNio0sKIDABw1G9TODQXswhYFpKcjiTCYgyOBcCB+QAYYNoOUhCxhEoiAXNijwwCwYfPgQAge6ZMKKDCiA4QESJBDh2Aqry+VfQDLwlw0eXDijBwZZsKI8GTo4ooMiJLDCWhJcKGIGJlw4y8AOOmjDAwlO2GCtlo3woAgPSGjDBA8q+MuFGDzcYOIZZnABCBb/bvCgQA9cuEMOA/QxR7+KTDihphsk6CGGsbuohYETkqpINR0auUMNTgpoIoUjjjBgFwkCOEIUUVIQJYYenpKBTAlgOQE1HSBKChYdJCFGn11a0keaGDzJxJZCmKSABANE6JwBUm464gYccPigANUFEKAANRgwYgYesqJghrbOSMFUFmIosYMTJiMiD2ra6CCPAjsgJhx9tqb8CFN4caMQE3jwIQoPHtCntLSXYkq1M+6oCJETRMgATB94iOLFGFKIwQqJe0BRgvUKOyH4csZQpIgqwpGF8paOOEUMPpGCDgRCH2NoEgTGIDURMOFmDewAENhyIvSIAAJrQNjR8mAA/wmQYAy4kQIJIISHGYRiBlJDyxCu4QFFyMEIsuif/7hwhJcwABRcEgEPAJUVPCArEBpAVr2EyAYPPMUFMvABBTZGgRxuAALP0gAM7IWsOjzxhDoAARjk0IEY+o8ANEwBCZ4kJWSV60F/SuKftlCpJ0FAAnEDAg8kFCFtXQACGAgEmfCgj4PpI0sQCGIRj+GHIiCvEgTwnz6O4IkUeKBcR3LiAzg1xgflSh9P8sEW0LSDILBAO1sCU0Kysikp8CBZSbxksvSBphMIQh8sqEI7LIBIGa6vgBvwwAwkpa8z6oMNfRQW9hR4hhzo4JaAACQfkbWvLGSlSjWikgw2QEQG4P9AEGNbxTZaQgBatoQLBKQAD0QDg4kxoZkPONKjROBBB2wABi4w5hA6QK8KSCAUWajOp2RAghnIIAsh9EAWNCACB0DACkBIgQUMwIJIUK6blPMEA4AAMomKpwtj+FAAKvAhCRzBQfoYVBCKMJZcuiAFXeALD6D2FonijAExYIKUNLAGUjHgCAGohD78kEgZeiIbMYHCHDJxg9xlQJweMGqaPGZSIjT1IeJJnFvEox+WvnQv/aLpBmZgAhxwgAN8CAFP9UEALljgFKZA6yc+IQYOjIcEHdDPW08gipzJrwttIIILDHCEu7pAFz3Iz1114QIX9KAHBuDA+lxAgg297AwGbN1mSwICACH5BAAEAAAALAAAAABEAHgAh9SeKOJ6FOBWd9m3aNrDPcnRvgMFADhGMBIWCei4q9CYiS83KdimksWJdEpVN7R3au/FucbZ6Y4qTPJHh/DY07LF2KxnVFhmTO/p5/DJy05XSyYmGPIpdMqUevE1e0tIMfFmmaa4ySsrJyo1G6pYS/JXkfb18nF2bZNXS+2HrZBJNG53T6soU29nariFdHA3TVJITBsjFFIoL+6WtoyJiq+np25WVI81UfN4prjO4eensVA5MtCorrzR5HE4M3BITG5Xa28oNG5INqyXl5SWka5UL8yJhuOrmqpGL1Y4TGpoTo92dNPk7fY7gfKoxHiDdJZlVag6a8d4bdC3tc+Zqs/Jx7FzWmxXL3MpR/K3zK5Ec455KyYaEk43F5Q4Z602Uaxra7WaprG3sY9HS5FnbNIqZ41WcvLi27KWNPXZ45FGb8xGbpZTNaxES3BmMJmouKc7K803a9HU0pSDM5GXqLElLadnF1NjOniFV493houFcqUmHK6JkeSxm4w5MI94UvtroldoaHmGkJOYcMRoVTRCG7GHLupzm3JKbMxYLfkbb1ZHGYxKFZdXFomIU1AlGIhqLnh6NKxmLtOKp1MZKJiXUZmklK1VGqpWarZ1HbN5KMYpWslHMsxZimscMXM3F7YtY8dVSs1Vcc5olNPFuzxLQVxVZJEdRJmjbsU3Lsk5T8x4jOiWmkwSGHd5iJJYgp+xwq4eT69oiK1zjbjEuMpraNe6w3ZLFZknGY5mG52uwLmjNqenkKeyh89kMMt1GMNxWciXMG4rGHdkHY9phqylTqWobtZTHtWGHN6wnOSKk1tLY15wRHFWG4oqMasdJbRQgqqLQbiGp6aVTdhFgceGWsa1TuZEeeBXGzANFTk4QT9QO1lRHLg5H7KXcrarxKy0cMEpKs5gG9N4pcWYRMitT86ic8zFUuRnF+eGF/uewfHQtB4rIzZTVTxueEMPH18vT384YGttg4IfPpEyHo1yH5+nXrZPgryDH72zRbrElNlOH8lISM16McCPKM+THwj/AA0IHEiwIJdHuRAoVLiBYUMuCGRARLBBRBBnSPZo1FinTriO2I5xQgdAxbM6ca4FMeBpTcGXMA00XEgzBoIYDXNuiCEjiM8gcDZyrJNKFYtEx1JhS2fyS5w4Mgy0ohTTAKQuMUfMpLmBS4wYIjZs2OFjx4afPv3sCboH155wqTjVSbRPaYBudZyuifoSAcEufmEKaXZT7E2bX0Uo9uHMj4+eMmR48gMHDi63e+pw2oz0WDpxHVmsGRNzQ9WBG7o0wid2wwKcI2LEJuujtg8Vwhy/CEKChGWNlRMlGnkpEbJuz1hsEvUoZuDTXLp0uVVRxALrCxaMGCHEsXcfQXw4/x7z4AEJepWRCB/u69Il0HU2fSHB9/TphTEWuD6w4MCH/jaoYJsQP9QWxA4/kAEFCkHgggQSoSTii3pFqJBKR18EEUp99sGkEE6FZXfAiPx9IMQHHxzwgxA7RLYDgmOA5wcSRYRSxIRFFIHEhV+It5dApnU4UE0LfACYYv3xN8KIDmiggQMsRvbBDkIIIZ6OOZIgiQpFJMLPhTectQYXBnDhjJACffjVAo6w4RVOSWqXpH8O/PCiDDCYKAQKXOqIBAmaSOILJ6rAocoYB62EJkEMybaAElc4kJ2j2WlHop5TyoCiEDaggIIkbLDRGxrB9INEGyTUogIXMw0EUYcLVf+6gBuQXAGJAwdsNyeTHzjggA1UsriDDVBAIYQKoZJgCBqSkCAFIdUYohVFHNqH3wEwZHdFLgtccYWS/WnAn39MAkvWiQ5AWqUKfqBghSYkEAIMIZr8swVFXJCJJn4VKfkfiv2JOGevB2gw5YsvfgCpDXvy2RsJwDyrSSb3iqDQvvw6esAFDhi5wDayHoCryOl+IMIOBzvgxhVCXAFFeQ+AUd6zhrDxb0MYH6bVfh+4cQuuAotM4sYrSLoAyhoooUS6ZJhhRswyG2FFyyjoiTOs/E7q2gcruLGCyUNrwLGvK+hhNNeD4HHBCUuY8YMZZKAABSZgdAAJyh9sUJsMz1X/ReR1lV7wxCCOOLAfib7e4cAKeDgwQpErPMHMCXwAYTkQcDf9QDXVXIHiCGOQ4EPfzi3kmqwLrE34BfyNPOIFzDDeOJIOXHDBEmT88EMSL+j+wgtgWCF8NHd8QJ9W1uInYq79qW7MChw/SaLt0CuO5AplLwEEDEkkobvcKAS/4K0OQGHYxaXjtMGSuT4u9hOoOLKCuLWLK/YKS7N+3QdPrNCCBt4DAhiM8AAjKIABOmCAC6CAIjdAYVoL8RBDXrOk7SxJdfJrHJM4RrQVjKhSDogd92zwgAMyQAEoPMIR+pCAJcDAAX+wghJsQBOY2KQwGxAaiSJHODxETn9NKljt/ySlGKIpAQYkRKESl9gHCOihBUr4QwcGQYQFRLAvHxKR7cRGthOsYBC8GMQJcCU96X1AA9mpHfRg8IAGuMAFDTDgARNwhAQkYwktuEDZOrYVCd4kOx84gZP0cIInPMGLYHxC9Jw0ruzQTo8XYGMDlohCBqwQAlPgQx6V8IHYfIh0BshaDi8gthOY8pCDI4IebEdKRsKAP9cRGfQ0IEkTKsAIDWhABzrAgAQkwByV+EMn8dUqRh0mYOEKhO1aYEo96IEINDBkIJTppFKMa0QamCUMLNCAE7pAZg+wgqeg4II+MOAPf3BEJFY2zL7hBycfLNIFAqGBFrRgCTTIJxHoQP8DV7jCnsrM1ojOKLYLkLABDyiQCkhgAQugwAIu2GUf/nCFOVhUE2jYxRyClCaFWJBJBSOlKYBgT3zSgAhECAMN8nCCFkxTXIgj4x8aAIUfeEoFKmiogIQAhQ70wW5bGEYucmEHQxAADc9RSHa2Q7Im0ZKkllvCEGpQgzDk4apXdakGrKlDkemhAQ29KQk68AABkaeXHUBDUIlqh0YYYg4XY4jjmOqAO/gHBpZrARnyMIQpUIACVRgCDXBHBjzSsmD0qx0cScCiH6jACgxogBUaqgAIQMAchhjGMOqRCUgYJl+hVGqJhrYAvEa1smfAgAlMQIEMTIEKS7ABSe33JCf/nQCODvVUG49wQgMmwLJ268IHtmAIQzhgITsI5VfW54Y5pOg6SYABDH6wBAUkgAKqXe1qMXCGDISBDMxkZLmAoUuE5rIBLFTAJOuYgA5cYQTDRYMhtlCkBYwhi27ojxv2mx3pJsi6EMBudrW7XR4swbCIu4IFdsmAEz6gAwrgbUN5+dNFfOAKW8jwIi6gByXM5APRAMAcFrcFz20KCkboZYD/ymIMuHi7fLBBC0xxgG2QCAq5ROEDGtpQEpjHCrr0hrfcwA1ubGcsHw5xRtEwBzeYiGUocEEvfZkBy0IgAxlo8WopAAQbOMl1SsilFCYrOh+ET7Ik0KUV2GlBrewA/yJsWNYudoEGJnuuSjawgHV9yWdfWrbKWc4uD6T7Sl8tzgU77g1Ci/UARFvgwVDo2HYKQWmt2OQXyPBHnevsBgtXiZxT5vOVq2zlv774DC7UxgGWxjgXkJkEYACD3MCwIBS0UQmF0FWlLY0AZAAgGMGo8xaaceEr2HqOv7Uylq185dQW2AYL0MAJ1IaHXpCZQGPItqc8ZQUXNO7IB9g1TjANbLV2ehHe6umUR01qZl+ZAgTOwBKiewEf1vsPFigzCjBBt1w+2gVPUAJYNlAIX+VKLL/IhCHI8dYrLGIRLfuDAlj47ta6GwK/xa52z0CFV+LBHpWAnhLy/VASaLuAb/8chAdxIoID3EFxls6EJjRBDmuUw+EWvgJkqZzlDPTZzxgP8IBJ0QIYWEIfvbBE0hzKUAvg1MdudAH0LvAaEdROcQe/QnHRUI5iNEM6w5IyCxPAAwUMgQ+NVsAU+syDjG/ZhWKghSWI0L8FQcECk21ooydZNA8qxtAjKxIk5lDnOSwC7DboAG8VgGhE4w4FZEixLxVYHj74lQJ82MEKekEKOQS21iXP98tS7AgfAm5jS/vgkhwwDbUeXriQjWx55KjjtNuR8W9UAA+mMIVBXyDptJADLxxapR+MQXdJZEAVCkCEbC3ABkNYAhSWAK5VG8IN0umCEHjJ+AIqgA9GCL//Ed44ZRRO8soQaLCM414FUijAClAQkA8I9ANy8hLeGJjCCaYLx/IAjUmOgH1dsANQ0GCRhVByQwYw02hHYFkKADN7lgAMYAMnQAqslQAP6FCOMX+2pktHoHHdNQTu8gcXoATxJzJ6VAlXoX1S5k0PUBs7cDKdggINcF0UwAAONQaQJ2UJYAM0YAJMEAFTkIFOh1MoAHUHBAGqdQatVXbeoAdWEAqcoEZ4gApbMIAF6GAoUBs/YANIFDdggFoYkAAPMAY7sABJwFM6sAR5EIQ9UAGRNVnbxlAPloSqhQEWR0dG8CyhoEbGMAhX+AEPYIDdt4AQqAMJoFo3WB4HRmsN/yBYblgBITAEO8ZjeOcCKMQDcnCHeXgEe0gIfahHjlAJW2AiLchnZUdAsVZCf5ZdFKAAUTNHU1ADTBCEOVABsFADLsBj5eECRsADVRAB29WJn9iHd4A9o3gFiccAY2dZvlR26xZgG3eDvoVdgFWLEfCGkvgGdMAHfDAE4FgDFRABTLBaTFhldKRez0KFqFAJyshL7HVxV5YAiJgBpyZgFJBa3EUBPdADOfCPFSCJIfAGBEmQsDCO5ehi3YVxR6BeO6ZGg9ALqFAs8FhHyrZsGIiIv5VlZxBg+oiHf1WLIhkBERCQIXCSJ1kBPUCOLtaS6HhLMVM7eDAIxgAOKyBFDf9mke6mAwdUZbzlS62VcWfAhEzYkm6YA/4YkEpJkrXYkkuIcRioAFLwAfU2CKiACn+wBLxkST9Hj+qFQg01SSiUfr2UZSxGjtpYAf+4lv9IkkyZkIpIjzrAAwkkMseIPUqglSakQnzZkLm0Y5FBgwzSTd20kVgmB0qpktnIlm7plrVojj6nAzxpBAnQK9SjNEuAiSZkgCekRB3gRjvWaJjYkBPHbFUQAuPYmP3Yj435li4WlAlEQArQK0pgO5gZURBGSZ+JbAnUYDxgZUcAj8kmBqmpmq3plj3QlHiIcQkEi7VQO0qDPSuQmbtUnZ+JUCXUlTaIjp/JjL4UAsfJmiv/SZLi2ZTnOHmwSAIkszRJ80bVeV4I9WgABpUr9lcQ0AcIdUBHMAXF6Zb/OJ4keYsRkAPKGZQSqAC50x+GxmHueZ0NIAVSoHcm9KBSYEC+hXEdYAFSEGFTgJStuZqOKaDjiAFMgIc+lwDgGElF4iu24wgNel5SkGiP1huokioQSgiEQJhWUEIM0KEeupj9mAMhOo4BSaImCgE8QARD0AL/QTJ3YDt68J7w6VACklMpxgCkMAUQoF5Q9wAbegRV8J/ZGJBBSp4Dqpa3WKIgSQo1IFiswz4f8KR3MFNSmktWwAaPIAM+QAYuwAM1UAV+VWVDIATlUZhkSpIBiZRtmY0D/4qaJSmMIMl7PKBJQ9MrT/oHuOmg6mUBNaU7NmVrA4RCfAAGOdZLAYmoibqWKzmOOXCSt7iJJjqLNUAFedAC4cYkL7cCcLRL56UADioFqxB+wVqht0R7lsSfqIqmP8qorYqaRbqPbFp2sTZpTaWrunSd1ml+XhqsysAK3soKEWaAR0AKJZmSyrqUQYqSjlqLntd7RiALeUCtTLIC8JlLublECEUIolALEFqhnMmMU8CNb2CuznqLKumP6uqoEeB5gDoETsNUdnmM9ZpjStRgUplvvUFe/9pgdCAIA5uwzqqSaimQJ3mQibmNeYAIj+NykdCyK1Co8FmxFqteiNZGc/9kTgZIA4IACwOpCyiZqP14sCX7sz6Lkh0LBIvQHy27BZHwsm0Us5XEmbzFmXyGs4LlCm9QtCEriWEwCVTwDZLIsz9LB2RLkB3bAnbgKxk2B00bmk+rSzKrkT/njMlwQv1EAx9rrt8wCh5QBrGwCWXgAaMQBiipCxXAT4JAB28gCPYkcxm2BRYVCTvaUDt6Xrukn3IrahjXYA2QB66QuIqbktLgASxACdghAjIgAR5AuCFguIhLBzUgSAvwC5rwuJA7B3+wY0f4aDALYTmZub5UtwxgBKMgC7OQB4o7sNLAAZ6wAE8gBxTgeVWEBU3AuhVQAzpLA2EABNfxC5KwBZD/0BtWMA27SKUPpXf2irm+pJEzuwqd0AmjMAp8QAN0sLyUUArQiwMTgAM4kAFiIAIswAHjgJohQLbe+AOK0VZsUAQ1+pk89nQYu6M2u5cqdEK8ignvOwrQMLhh4AGeUAoYoAMc0ARZgAETwAFpcAKoywGdMA5UwAdhwAdLEIMbgATs8idt0Aa10AF5xwZGSAI4xYsUa35i5gEjTA2doAWdUAITsAkiUAVOwAEcUAJyIAc4oAjqgAFVsAAycAqxUAYTwAe1+mY1/CCo0gZf0Ab+1lA+jFMVwiW9oaH9GqMxugZBYBFlIMUcEAssIAMnkAZ6XAJVIAcl0AQcMAFpsEUH/wDAE3BVZiADIuAnp5LDNzBWLsBQfOLGbfwgTYejUnBeoKABYqDCqNtyaEQLKaAIE+ABgMBaHnDCHvCaaYABNCACZdAJeSAL2ZYjDzLJN3ADD+YCntLGyNIbvUwCoVAGZXANn9wALPAEWZAFTyAGlvAETFgFlpAGGZAC+2sCM8AB/ZsF3swBHlACGFAKErAGxKDLN8DLlZHDX1DJmNgAmYwsNBLHFkAIe/EBMrAGucQCggACIMAEWTADJpACHDADNAADcqADJYADGOABTZABM+AEGXDIM6AIGXACMuABZDALZsAFl6Aj74zGvzyIkcUnRcAGNFIEDGUFwLAJJ0ABRP+guiVQBifgBDOAASDAARngAYoACESAAGLgBCUACIegCBAtxROgCBZdAhnwBB0NNy8g0iQNB2jcBr88VuZXhH1SBJJACB5wCkQAAjywA54gAbHQAhQwy4Xc0xwACDVA1BlQAkZszmngAUYcy1kAAlE91WRgMSN91X5wA1oNzO8JBiSAJTkSB6dwAGIwAU4QCILwBAtwAjhQAiZg1+DsASBACzFABBQAy2kgBxkwAU0NAiagAymQwlNtBg3hHryMBHDwyzcgAWMglXHAAnEgAGMmCpugCpvQAnIwA03QvxngBFPwBJm92Xr904gsbWmwylPs1k2NAwfd2heABXEABD//0BCN0Ag5wstjcAM+8MtrwAIwIEhBEAdSEAc7kASUcAJZoL86QAElwAEpUAUpoNogMAHm3AROfQFEkAUegANRPNH/rdSbjQNpcAA3EActwL0IwAjhPd5sUN5BcANRcAonUAUIzgsv4AESIAZVIAZ0VwUgEAY10AT/XQUz4N8eYNBNnQUHAM2KoNqnPcJSXALfPAP/GwdrkFdAYAeSYAeXIAnNUt6/zAI2YAsSndAa4AkyQAX7mwI0MAQgQAVDMAEg0AQ1wAOafcVZUNSAkAHRhgEp4ARVQANqbsioXc4YcAFTnVdkkAl4bgdG7sPlHQdYIAZMfNEzQAQ18AQ8QM5N/0AFNVACVGAJdl29NYDIaZAFVXAAb9DminECYiAGLRADMCAGaTDLaRC9J8AOUdDdpjBSRZ4Jeq7noaICY7AJNjADHqADUFwFDm3R4DwBk0AED13cTcDr9J0B0aQBiqEYNwAKkKwYGdJypBQwIvAFHKAFiIAIMLAMMKDn4d1WjFDMEkAEOIDlJ6DFqD0BIvzfVEADPR0Goq0OOnDjNcDF7c0BeazXUpzH+C4BWCAB/M4CeawFamAGQIAISbAAjcAIFt5Wt/AJn/AFElADIOAELTAFJZAFLu4BTmDETTAEJwAIE0AELVcDU9AiIvAC9x4Fp64F0KAFUcAC+n4D/q7Mcf9ADdSwBlrgBVigBrMwC9dxC7eA8AivAgzPAi/AAxNgC2IAAiUw2iOcBZKdBSdQCk6QAifAAn28ACZPzqAgATfgBSivBfdw8zfwAlhA9mX/AojwCq+gBVpwA/GgBsQwCUAgAp/QBZ8A9DglBF9Q9D6dAk3AAzmdAhU/ATxwATuABdMMA2twCBMQB2XA723P717g9WzP8jj/O2T/O0DwCmagBmqA9maQy7nzCBDxCEGPUw6/6BPQBE6gATKgAQU+2mEQBKiNBSIgASDgS0ZwA/t+81zv9V9v+b+TBFjQPS+AOWrgBZ+fBGYwCwB/A49A+gjwCDOCUyqg3jWgA1NwAar/CwpYcACRHgY3MAMJ8N8loAPpxfte7wWSj/LuHwVe8ALdM/+IYDlmgAg4Dw+IYAY3MAYSYAAA8egRAgTC/MBRoeILCxkwdkiI0wbTIQlEnNS4oQNCAo4dFdyQ4CVKFFBeTI7UoiWKlxdJXCaBsQwIEGJAXmB5geiFGpAGDASRcCqIDySqWLD4UoZDGQk3xmBSICrJEw1REkDY2DGBkaMSWEiQAGqlGmirJslSo+YlzGWmWiAKBASnGkRm1EjwKcGGDa+bXtCw8fUFWBk31MxitUbCl0Pr1mXlqIyFDSJEaNSoYUMspklTpoRR4+WlKVMzA8EI5ApLEkSvgLxSY4DS/wseMyzpSTIEB48FJ6Y8AXsjCos1IDyU0JEgOStWyde0oDJhwowSOJ4AjbKKipFVKkOy8KLlSxSe4cGreVXzBYJTLUCUSANCzqQJNETwmDBkxwsWL/SceOGHHxYDC6wvlBHFBh04gG8C3pTIDAsJBhvshyBOsOGFJZbQsAUbWpBQAvJkQKCi6XBoIgMPsuChhklAoIWKME6oAQQcpuCBhyFo4IGIGng44YYJaPNAhxqmqIKHKUCgIIwfxaBCDB7ESEEHMWysIgUneEgBs8zw4kKCITxIgUEQQJiBgxQOmWEGD3DAYAIcQMhiAg4AyYKDGUDggIofWCACBzVnqGISQP9wSIFPJyYogcwJnNATBEBAWLTRCVScgAgssqHkhjA8sNMDD5wQNVEdmsgigxQmoCCFGaQroQkyOXBwsCkmAGGIJWoE4ZAFm5jhGg6aOEQ6YJtIo0pQSwDkEA5AIEICGWajglYQFAFBRWCrKyGLEkCo0gkccHAWVzdLsGWwGppwgoYTiChhgizcnG7UNjkgMwVAnJghBQ8ywLVRHKIloxUJ1p0BUiqISAEHgGeYkwcdSkCXCid0qHIGWwCZ4QS9dPDAxhQomJOIMHCYQQcQaNCgBm9ZfM8WjMXA4WJAqIBBC0EM0CsMd3loQYYWlNDA5xNogEGJIYaAYa8PW2ghiRP/NLihhL98XuIEJY5O4oUTLrgMhiBqLIHlpWH4wYYdTvDwBBjWGGLndyYE64UbjNpBAxGCyDsIpm7oyqs1tOhkDVGUYWAUhmRYoBQNDpChjDJYKCMIEVi4gQc9NRAsCi1EPAoULWoZAJWdfcomCE/q8CURMWegYYEaYJdAlS986GIHH3xAgQHfFVCAAVEkWGIIKlJwdYjAFtrVhiB4bOEGM0xrB4YWAvGwBWvOMeYEn3ySoRVh7EjkBSo8GOIEECbQwyuwAifuC8UguoHmUKngw8ggWAgijJVF+JEGCuQFnsDFHYKYgxL0YA1wrOB7BphWED7BghYU6wljSsET0lYD/yJAjYMt+AFgfPSDF9QgBVkI2dcCsQAN0OAJ0ZkCDSBWhSHwgghp40sU5IHAPyyhGMVwwAO5IAOgSMAScqpBdFSVgip86xAZ+JbDpAiIE2AOBjzwwAxoNoMklsBVx8mADh72LTkk7wdaWMEW/tCCYlRiAw9EABFZQIMyoelb/qrXBLIIqiasqkwp0IDhfkCFFKFIXhNIAQacRagJgEyPiIriCb7gADds7RwOQAAcZeAJFpzAX5jxIghkVcfpPAuR+GpCGF4ABkzYgD5pkA4HKLDEWE2BCuDKIiLBNQEqDKYQDtCAHvKxgUwKkRKxqGAJTjAEVE0sj4BwJAiqsL4Mfv+BDFpIJpXiNbH3lMAJyFsTk9TEA2Z5zAeFyNs0dhGDB36PCxScAW9OoAOWWSRRmLmnCymAnJy1IAotaNgFWuaE9ziIBzQYAg+cEMMTOCEDNWhVGAa0gQXYAA2V+B5BHgiUH8DgCxIQEAuw8AQbHeACNtKADIggnWhhQgl3WSYMREoZKjBtMCCNmgSCQAQ0ZSALuZLWBxYRCTdk9I3unEcshIKEr+yABUvAARV6E1X+EOFmMp0JEECCBYaE6AX8mdBNdToZi/20BEN4wTlH4IgPwNEnCODCBsLXCvF9ogsj6A8NWjAhvd6gDFIT4GqAAIMFyAALMhBBYiW0Gm3AAAYViV3ACPYHAxpQgQpI+8JdHVCJYgYEACH5BAADAAAALAAAAABEAHgAh+NqF9iRHeJqfP+VwNrDPcfBV9zg2wMEADhGMNCYiem5qxMWCS83KcSJdNimkrR3aqa4yUpVNq1oU+/FucbY6bLF2O/X0o4pTU5XSvJHh/Dp5ycmGO/Jyys1G1hmTMqUeu2HrExIL6woVfFnmXBnavJWkWx2TXF3bvE1fO6WtpBJNLeFdKtZTFFIS5NXSm5WVY2Ji/b18a2nqRwjFLjO4fR4p1A4MXE3SywrJpA1UM+orvQpdm5ITG1IN+OrmnI3M7zR5OensVEoLHBXbJOVkK5TMMV5a24oNGhoTatHL9C2tMuKhY12clY5Tao5atLj7pVmVauWlsw1btCZq/G2y3EqRGtXMo54LJI4Z6xEcSUbErFzWnmEc4s4MZmottLIyJBHTLO2sfU7ge6qw5Job601VJFHb5VUNs8qaE83F4tXcfLi21RkO3FlMJGXp6xES8lHcZB3hq1qa7GWNXiGV68kKqg7LMxXipSEM1doaJCXbMxmlPtrouhzmopJFY14UIiEdaZnFbObo+SxmzVCG4iIVK6JjnBJaldHGZZWFa1mLctZLcJzWdLT05ijlaQnG8MpWcdqVHh6NZWWUZ6xwrCIMc/FvHmGlK1WGq1oh9JVcfLY4VEnGIsoNrUsYqhXZ8pJMMdYSXA2FztMQlIZJ11VZMk3TNJJg89kLteJqsGXNceXRdO6wuWUlpNnG5yuwLF5Kq52kK2oTbrFucc4LueKlU8TF2gbLGtVG3x9i4poJ5Fpha6VS6yllclHTMhratB2jceJN/cbbltLYlhSHXVJFXllHJAdRJcpG5dYgqseT66VcbulNaOib8yqUcykdSgKEXItGaoeJrE7H7F2HaaKQ6a0jMElJNtVHtJiHMmMUcujNsi0NuNEffLStT9QO11wZYo3HZhyHYeNoJSha7lOgbhWhbqDHrSHqcp1Gcx8LsmzUdmwmMjQv+FaGeaHGP/O4R8vJT8SIDs6QDZSVTxud0IOHkwtQF9wSnI/Ymltgp+nXrKsw72yQbvEld6OHgj/AA8IHEiwoBZOrhYoVLiBYcOGQrQwxNGpE6hHj+po1EirTB0A2EABCKBCWh0p3Y4cuJWloEuXCw40XEhzxoIND29umGHjiM8jdjBqzHiNli8Ri7DRcveuZBkpcIQcsEXqpUBdiAoumHGgw0yaG7TMmIEDp40fQjb8+HmkyyM7dTA+KurLziJQSwFMq/M0qlWCaWIS3HqgB66tOBluncEAB44fXSIf+WFDSFs7SZDJtQPqLipsi95l0ygCDpi/qAV2SJPoHM4NDGZs8NqB54/bkFV06vLjxq0uSewgQ2YH86K72TAt+jdNmghImqSm/rshTZpiGxwz2I6AQYcOPSLz/+Z9W8XaHJHDAU8S6jgoVJgwZbtWB1IZFtKnW13IGAeC7giEwAACL4CB2w889LDWWV20FQ0ySbC3CCpJoKKICrRoVMYRoeSnn1aIIcbdf92F0IOJJvZQmRA2MHgbcEWEUgSFRRSRhCl8QRadQBt8KFBNDIQQ2HYd/OfdfxFEgEEEKgohRAg29GCeCjbWKIEiSUiwiC845iBEF3BocYAWnfjIH1mFnCGWbAN210GbEYTAZIs2YJCiCyooYmMSLMACCyqgmGKHL2BsYJmPAy20E2xI9BDBdjO8yV2bASYYAg88hGDiCy64oMgZRbDAwhxzqJPEGyz8ogJOEg3UKmo32f8E23Zt6GKFLhEg8N2AlMaZ5As9YNriC1BAIeUZZ7BQyRyKsMBIJNpUYgMnWhj6IWP/4bCdd1a40oEVuLhJ6YC5IhCBFVD2cCIGSFihrgoquLAFLCxE8iwsAVxxkxZiTreAtiQ65mZ3NgjYHa8kJomAnXS2GEK7wHbqggSiGmFxJedckZ1EgiUKE8BGRjqgB3GmwcA325KLZARICNhCCy1G0IYVNEPxwM1ySGAxI3Ocke5MWsEEG4m1DR1CG8XkOqm5CZtgAgbbFcyuCRGQQMbVscghxwNLbNHDGS6k+NVgMInMwKxshmBCGyaE4B+JGJCcpAl6PBrkH3rQ4cEJTKj/4TcZE3/ywAd/aBoCeCou5DGIYzHW2LYecKFHIREMnXAEbERgAh0RvKk2HSYwAcMQQ6hROhlykPFAA9q0IScDLrDwA00/wsRfytvtPbkH3WFAIgIeOF0I55Ky6wETTGDaBKY83MCDHFtEXw0bIcjOcce2K+R4CLrmfoIezZjA++/AB+9B5gA7DQgTQxzSxPI8uECGGg9sUewf7UrgFe0vaY9Tkbp6E7u40IxCPG1lCwseEiLAu8a0gAsmIAEGljcErjVgCQlwgAIc0AAosOsP+pvJq2wHm9kEsEi6MyDnkLQk4DmNe9vCgNNa0IQXrCCDDkhAK1rhg0EMQgEraAGx/yQAJZpg70f+2wDTSGQCyQ2viQ1U0sIY+CjHfM4EQrxhArbIxRwqYAIrIEG7fNYBI2bPccDDQNzmdgK66YELJ/CdnaZoLqgxgIHie8HqGrCCJWAwgwrwgQIGwQQJesAKtTEjiLaynRDEEQOAOAEX4Ei3ZpyAZGr0Ha8aoy08ekCPDeBiF3s4ASUYQoxQiAAhypiYI/JnNkr0QNxOQEs4So4IgPDA3k4gQQS04GD+0RwSMNCC1eFwiw1owAc+oEEFPGMShatNWcaWqMVscmF50CUJaAkIQBABBpKkZTYxMIqD/Sd44muBBBrgAAes4GZG2EKnoLCCQTjgD38ohCTaQP/G6yHRmpuMWx4wQAISiA4GMCCCG2CQi1wUNJstaFPc4vbJ1T0AWGBggQQkMLEVMHMCy7ACHkYKizkwAw9lFMxCaBOgXE20FEMo6EEVKggYxIGXecjDL+HmUiY0gKOdUoFGJWCeHkDBARMA6RWM4QpXBKISBJiDQpC4qyIlSUnEjCnpmBAFGchAEHEIa1hJMNByLox7C1vBT4GqAgkk4AHmccEDkDqIZyzVFeIIRCLmgIepMqRz3zFXrl5WioKSIQ5RUIIFLPCFKMCACVe7KTEX5jsleUCtLFARD1Qw1w88QAIPSEBSn1EJYxhDHNTQxWz2dYCVCgitRmoB6YbABKT/rkEDMYiBBTighClcNKZyXJIamaBWoMq1AT7IIQa/OIEPXCENIbhCJSoRAYVowQatHcts2oAHGOKgCS/jARMSoAAL4Da3udXAGjggCDIUVI0sfAEjPpAAzybzAwpQQAJCKUj9IjK6c6jEFcaiBTBojwFtGFAbFryd8JJhCV8073nRm14dkKGQvvsPBqwgAfo6wAdvpW9yN5rBQXwAESGwwhVWjAibaG8GIagGN/CguSug60RGXYIGJ7DYHkv4vBowxAtIUAoEfINEUEgmFxvwWYo9wFkNeEZIrdAGYhBjlbJpCIx5sQ2T8tV1Ke6BC1bQTOYmlQMc6PF5LTCEF6ix/1wIQEIyjXAzuP7guJ9V5hYWfLjvfMcGDYHCHFTBDGaQCg+4SNEL3JrfRjf6zBNI83l18LJfJkmG76QYC5hcrAesYAUS8GgqBdQBQpjaKw0JhipWrQpStQHF6qJnmfML6aTyWMIxWAMTWjCPOEcAH3RYwRY0rbViyQEKLrBZA9ogrlN7xSar2MY2VtHqKySaZmNuJ61tjWZb8/i2FX4BAzBwAjqwgQ69GLYLggWGdie7U56mHJEQ4GzZBGMV+J7DFV6NiJoxk9Zo5oC3uW0BCnOACeD1AOgUDkIX/EDMn/iEHJK5BU9zAQlk2QAhFIZqddx7FZXAgxUQ0W8rbOEDgv9M82IFPvAIT3gNU/glHfYxCfEhgWITY0G7WcA1T+vBBAiQjX/YkLnvzEDVwXDGOpxhhTSg2OQO+KHKOeDobbscvZYgAQIc4Q9rOIJdHB0qvHjOxyWIzwOPY2DmAgiFaPHCGbLAhXVSTOYfKkAHCYiCITwNyEbrIL8F1+2uwzALRxABgsiGggSGLYGtfToBVAN6J69qpAhcoRqHRoR1bPAClOfwne9kArLJ0Hd33swQirWAIWxgAmtYoh2WiAKyO0UxitlMx098HPAWaCTueYAX+tZ8GmwggXYymWuivNkNFcCOBHz6hjpQghIo7QGvz6IRveBosHgABkzpMYNfaAf/ESLKgBdEQfRMeK25TFCJNmy+B8x0PvIN4cclMJnM+a1vKBUg8HYOmfBfYAlvBQXm8XDBQk8ZVHAaoAQngClqdTNKgySF4H7Dd1TGx2TJpjp1hlxJ9VY3Q1755QAvcAKWoFv69VkuQB5itjooxwEaoF4cEAVylUtIgCchwAbBMwnPlQY9QGaf9wC3YQM4wHmx0wDlZQEOwFFgID/4hwQwEANPQAFK8FYbBS/xwnMeNgG4tQa7pQQOsAxMsAWRAAp4RAfk8Fw2YIFv5XAI8gJCBDihNQG3pQAPAAY2wABN0AMS4AOiE4VAUAEcNGws0CkaNTgZpIUxoAG7NQGBtARG/xAJoYBHzaAHV1Awc9VO8vdOdfaBgoRbSHgzTPAAx9YAjuWHFQABUdBkG7V4WqQDjYBbiihwjfiIkRg8haCDJuKDfpcASyCKW0NekbZmCbA1GKRBSiADTxCFNFABlCADoLZRyrcEOvAFFJBeiziLkIg5wjMJVtB5ZZZUIdh3SRV4uYaEy2Vea/AFyUgBf3iKXuAGhmAIUTCPMgABFPAEucWFsghiFhMJZagH3OiN/WVm3qYAQcB/L1iOL2gBt6VeFgAEQEADElkBpwgBXnCRF0kJFXCPiQiDjAhiTCYB/8iNUMBMPiBI3NZt+vVot/ZtL6iIi5WMMkkBFECREHCTN/9ZAUBwjy/5grLoAL0oB/9IDkjwB8z0YQSZVEGQQQKXXIBHdd/GhVz4kn5IAxFJkVhJk8nYk7nGiPqVAEYQAuhEB3rwB0xwlAPZaEvJTgmwUaG0RROgbSq3WPfYjhUgkXgpkTSplfiYkBZgkEGgA0tpLjiIBIZ5ljh0kooJkiHpJC7QAC5wBOzETl8UcI2AlTrJjnm5l3uZjOlFdUGwlBAmJx6ABE6DBMS1Re20mjmkTPvFR5/laaEFYgnwQ7b2BRCwkZwZkVbJmXy5kKAJlKF1g0igS4fpUaK0ZKHUTEGwmjpgaz7ATLY5AWGgm7vpm3sJBFupiIzYnMP4CwxkmKb/GToetUzLlEzHlwAHWXUrx4gfwE52Z4++CZHsmJ07SQNbqY+DlEOfwAKCtUDs8mnmiZ50BlrA6JW3tlgTMAhMlkE+oATWuZcSuZMSupH4+QQOSXUblABqwAPkkiQeAAgC+p5zZgSgFVqtaTF/BIIK8AE6kwAP2pu7SZ9auYw1SQEagKG7lV/z6AERJScM5AGFMKIE2mQVRzGokir9aAQZ1AAVl0FKMKE0GZEQSQOdaaPLmKOxeHdEEAUkYDBJgoMhSl8kip4cNSXrpAMOYAlKEJccRHFM6gNfIKU1qZN6WZ/LaJUVgKGxaAlfFQe8A0A3SHR/oEzniZ5bcAacIAQ9/0AGhqADOsBbPaYEFrV/FGmldWqVd3qfuXmjibhY0qcDhpAH5IM5bPAH5Vmm+7VRzLOEcoV80odMgESRNImVvNmbFnqTy/iKsXiMMjAFcaB1hIAkRGcCanWooVSmRgAM9eeIK7qhHwahtXqpdBqRFEADOUmRL8iFlhAGeKc13zGsV2Wshnpf5olMD7CsS1ALO9QKGJRc7eQDlvCHOHmXy2irmoqTnZqMjfAF07cEmRAH4do06Ime9JWcTBYKmvALFmMEOsaag6AE7+gF2VqvFAmRFVmvNNmvXxAGUeA3gUWYbGACBYueopRDYKlpUMaaq+kGl0Cx+qqvOnmXGQsBGv+Jme4YB0MAQBEgCT5rAjdTsl2EifulicsZgqsJAy/7Cl7wCjJ7sVh5k5RQr06Lky47BIgwID57BZIAtHtksqrJsizbaPbkAL3AUF4wtdmKsxcbs7npBnCbti5LAoGQJCuGB10bm1/7ljgUmlX3RfmVXAnAUDAAsxUbs3cZs69QAW4wDpfgBl4ATiRADbCwYlcwUpLwB0b6tcvkoD6wno+GtA0QB7lwCeMAuW6LuIrLuErrBjIQRwyQDtRguZeLB5obdosXtK4Zr6DbaJi4BHuQCbEQB5BruDhJCVOrkasrA0oLA4IwBI2RDopwBbogKlvAC8+IJxMDjffloOu5nkT/Cwx3cAd7sAexAAOoCwEygA4ygJHKq7oIBQOG4KE4oFegkqTvuYrwknMsUHEsmJgnmUPn+QnjuwflsAeGALdusAdoIAJocAfoML6pIAPNKAP8kJuWkFCGQAZCuAHToALA8QYi/AsfwHhnAC/JogJnsIp7JEol+wYFnAXlaw6ZcArK4B8McARocAy3IALdsAcogAYokAHAcIxgRQI2UC0Rwics8AZl8AbJBI14YoXwwsQSwAgNS2fpGkpgkAXlcAdZQL57AAfKwABhwFhE4B8nMApHAAmk4BhCIAIlIANuEFZqkBZ7cioinAMs8J6YZYU1UsV8sopbYAQGqwAs4ARZ/7DIBYwCQjALKSAGfDAGJwADm2ABGLABJ1ABYcAFDCACexC5u5AJ7VYjESLCb5ADYEBebckCJ6zCocICEWIlOlOwSMUCF7DIYWwOdyACJzAGwlADFiAGU+AIJVADvKQBNVAD8EAEQoAC70gGpJwDe1Ice/wJCTCFD4AsKpAEJxzLGxUJ9mLI6PlFLJADF4AFTgDGp1AFYZABwfwFGQACYTACNcAFjTACO1ACGdAIDIAGNaUGsaAGWoAJNoIZIlwGYPAJWrQCeBLINTJUjDDRFrM6SKUAcuAEnnABUnAKWXAKN6AEKLADINAI8+wIL9gIVLADfEAFGcABCCACqRAHav9ABjdQ0AdtzanMx675U4BMyxs10RWnQX0gBVLQwGigDJDQ0RdABBxQAiCwCShQzMscAyUgDFTAASOAySIADDRNBjiA0zndBTlQBjmQA4NznlvgyklQI6GyUaHgC5rQCoEkAi0iBBHloxdwClIgBF5QAyCQAhmgA0QwAiWgASiAAhpABcI8CqBM02rQEPFhyklA1md9Aausf8n0TowHWkYgBUdQBZ5QC7Xgzl8gA4yFZhggBb0MAylQAxlQA980AiOgATuQATEQBClgATG9ByTwAi/QEImQCG5dBCpw1j9w1nKQAJpg1JpgBJ2rmgJQBV4QBi0AB31wA1Nw2Bng0iX/AAgi0MuAMAYjTQUIwAUgUNtDHAMgAAJfwABSkAkFBb0L4AeJoCc1cgZgkAPJnQNOAAlVUFA/IAIjwEVLQMYvEAT3fAEoENI1sAYZoM8ZAAMiwNcJvgM14AVaQAIpUAJWLQYcMM9hgAPxTQakQwJDkAiYoAhX0ixgYNllIAIYEAYpkAJK4AFO0Adw8BxVcAJh0Ad8IAMYwCJfwAEmPcQTfgFwIAUvQN4ZoAT/4dKLndg7wAEn8MzyfeK7EAhcrghe/spnDQktIM+3nQEyIARocAMn0AIwwNgZUAJZrQSOAAIlYAEZIAYgIAY6cANG/QJ0TudhYMYjQAVfsAlUAA+B//4UZjAEpQBTQ8DlkO4K3AwGUuDOJYACTz3Haw4DQUDoGvDUY8ABQ8wB6f0FJQDnO5ACPGDUN6ADGaABfBDkGFDoanQC4MAAN7ADWWAGh3AILTAMLYAJw50IepUIyPIGvizYKSADWW0BIBAEwzzSwvzSUyAGx/zasxDbHLADU8DncNDUm+BVfAACRMArVXAEQpADOyAFZmAGpuM+DOAH8k7sgeAHoiAKZXABMlADKUAEGGABBnDpGZACQ2zYIb4JIJABKAACY9AH+54CYTAAey4FWYAGQmBHYUDoNnABaLADQiwGcJAFWFAFZhALsdAYflAM8i7v4XDvItDqJUDJSv8w8CgwAgtf88e80ikwBjtA0lrNBV7FAEQADhztBEt+ATngCQwgS7nuCTdwCLuQDIuM9GawC6kwBDggCmkgCitvhZDwAlOAAowV4RYw0ihA8D1PBVQQzJZABSlAz1SQxjiQA1VQBVLgBIq85EaNBhdQBXx/A01wCMmgBu2eD4egBnGQCWTAA9SyAJzQ9Sog5kGQ6hkQ5FwwBh0eyVQwBo6gA3rOAC1ABFDuAaNQBh6PBmjgCVigzovsBFhwAZ7A9+/DA6XT7mYA+GqQCbueA5zQ+JzQBVZYBlVABJlPBDZQBaHPCoLdCy2AAyfAClyQA5W+8SIgAnf/+ki/+uqM91j/cAOA/z6BTzpqcAgjXwWHr8oXIBOcoBDR0AV2AC+mUAWR4wFNsPdHkAd0Hv0ZcAHHXwIpYNgAMSKLEycDnVy4gEUhQYU3bjSB2GTYkCFkhtyocuPQDTM5Lhw4cOTCsSNdkpgSAWmHiAsiROQAkwXNiRQgSMBRAGLEiCAKfC5h2RKhJxEKjToxYwZiC6bDSpE4lGdIRjOHhpj5eODCixctId2A8cLlDZZCcpiR0oSIlxYjvL2d4FNBLREviBCBIUPQC6JGsZhRGNEpCRJ5WuTJU6WJ1SHJzBwgdUNHCkeAmkSpoYPBCSUnLnS64cRllSpoQCjo6aNVTzgkpmTIkKJE/w0uIkUQxO1E4W0zBDtiyZLQTLJdFw8cIzGixKYRjUBkgBFPR4YoNsjeAMSEY44cZRAiLFNL04sgO5Zn0IxEBgmEPC7cuMDjyIkXVZhoZ0LiBYkqCJ2AEUIrImLrQwwOUKBCBxlSGWGWKaY4QYYRalBCBx2igEEHInrR4YQcMpAMhSBkUOILHZQYwQJBZDhxijB0CAOEIMKY8AsQxtChBhl27OoALS6IAgUQzNtpih1A6COFFFCoQYMMahiBigx24IOKHVIYYYcpyCKihiNT+CIVPmrQaYcxMihByAzGuHIEPkY4M80MDsyAiAugISUHQVCYEgUUxvBTpyDEoIKD5/8sACEF2EoQQ8gd0INPiQxGiIIJCUfoozwxUuhmBzH6gG1TMTa5EYUSSuCjjx1GsBPPG4zMoA9hRjhw09lKoKKEEWQcowYoHx1hyRJYgU8GMcaA4QQiSsiAiiVj+1PJHYQEgY8xakKBg0nTrMFOIeTJwdgU2JyCCBBq0DYFKHUI4lRWphgjCBlTYKWGFDwjD4UJQeAASiIEsTeIEWDAQIZcE1SOFXnDqCFePqZooQwctHpBEEBO0IEEIUhAAgNBkoWhhReiIELkF3hAgrAmTsAghxLA+piJE5A4AYYmbjjBg7xaOELCEgiOIooWeHhhZf1OaAGOPxg4wJ4L+nsvB5T/bMAAhyOoPgKNC3JwySUn4IDjDjg0qcWBPUQQQggGRsEAASHQQEMENI7A4SUdrsSgjBxCC040ETzJIhJnJBkFpAOgOeKWTlBZBMgUYGBAhscvMKWMH2z4AQwXVnCAHQcSSMABTS5gIoopQEg0CrHKEMHSF47IkIQc1KAoD3paGCIPEnggYR1uJkHA8AOEsCWaQBZ5FQVDThghA0AugAQhl/yDoww4EJIiB4b7nMKQEY8Q4QhBBsaBRQy++yuH3Ou5BI8XAOFGFjaEF4KUI0QRgQRQuQgyBS6IlgERCBPA3YWFCDLgwQ1kAAIq6CtneWAABmDAhdcoAQbq+kIUHCE0/65cwAn6aN8VmCALWURAeFoQgkgu4IgnyeA1hgLBF3TVBw7oCl035MMJXtICHaAgBQxLgQtLkChTcSAI6dJVI1KRgijwIAsmuMIfSCCLScxAeAtI4QVgMKRg6QoEfHqWD/kkhucMCQQYGBsPpmCgGoihWWTUgKrAlIEg8IlJILDhCcpAjDbQrADEWIDwhncLEZzgizsa4ggaxcXYrCoDQ0KBGLYkh0+8IBUZcNKUOABDRr1rVz585K4ysKUcECIC7+vHBgJ5QlLkrw8lOEEUCNUuaGWAD3WcFAeaBwIulIEMWdBfCWLErHYppwRjQB2SUnQkHaDKMz8gBNV4IQsrCvnSR/lLgWZOEASCEQGZI9iRTmQwwU2UQActAKYTSHAuDxRsDMpBjw5gEAUdUMGCJxgDB2SAKEHwQAQbYMAL5jAJaxquEyLgQcTi488qcGFCCPDAhDAghAHV6QKfQEJwYtkCEVTBLlOIAgbgEx8S3OwIRAgWB6hAqQsIIQSIkEQbCgqSDRyUJHYoQyds0LoaTGEzPeXSwzg6BBIMASFVQBvUHMISh3wHfC+A10pLEIUb/KADHShECAq6AC3ggHi2sIUoipGGDogALOzhAQzYg4aVnU8xQ2gBA+5RBRzUFQf9UUwTmMIAHDCgA+BrAQweVLIykDUCk1hlQAAAIfkEAAMAAAAsAAAAAEQAeACH5XMS4GF84JYh+pvA28M8x9C+1+DXAwUAN0YvFBcK16WS6Lirz5eIxYl0LzcoprjIS1U3tHdqrWhS78S5xtjossXYjilNTldKypR6JicY80eH8NjRWGZM78nKS0gw8Onn8WaZKzUbrChUb2dqk1dL7oet7pa2bHVOcHZtkUk0Tzgxrqir81eRUkhLblZVt4Rz8TV89fTxq1hMuM7hHCMUbyg1z6iuj4mK6KeycDkzkDZQ83elcTdL46yZb0hLk5WQLCsnmKe4vNHk0La09Cp2rkV0xnltqpaXUykta0k3blhq0uTuqEgwjndyrlQu8bfMbFYxaWdO0JmrlmVVqzhpy4mFJhoSjHkss3NbzDds0MfHlDdl9juCrDdTq2to76rDUzlKeoNyjkhKxliLs1WFcWYwsrayymaVkUZvjFdykGhvspumyitnTjYXjDgw5LGc8+LbUmQ7j5ZrpWYWkniHk5enrURLcypGd4RVlFM4ryUssIqPsJU0WGhnrIgvx2hSjnhSiolRpCUbpzsqioV2nK3A53OYlVUVkoMznrDC+2qhimYvrGiKNEIbVUcZiUsVsXaSxUZsc0pqmqOVyVZJxXJTlJdPtyxhxilaz1Yt5JOVXVVldXg2eoOPq1YZqGUu0NPQ89ricDYWuE6C01Zz1oqnyJkx1rvC0ca76IaSURglTigZbhwveHeHjR1DiI2hqlhqs3wouqQ1qaKczXiLkSkzjWcbkmmCyUgzxkdQ0mUqxGxjzHaiw4lMO0lCTxQYbkgWalYckSkbsXQdrYmjradOuMW3y3YZ3LGcWUtisYdJq5VOo6JvqrWPyTwn01Me1YUcw5pIyqF7+Blt60V+OzhBVVEddCwYeGQdkVqDmaRmqx0mzTlRza5QyLI0yLZR5YgYHi0lP1A6VCxEkD4eqR5KuDgfsJhwwCos0keA4VkZ8tG7Nw0ZPxIgNlJUO253Qg4eX3FFfx9AcT5gfVWAeIA+my9gkXAeu4Mfu7FBu8WU3U4fy2EZ0HQvwo8nxKk7CP8ADwgcSLCglVW2EihUCERhBisJMiRAAjEiklq1cAnaqEeQHj3oROjJ9AwXAHAptunJQi3HAVZFCsqceUDiwoUZaCSgIbGnlQwqctQYOmijR496BuUSkWmfM3Uot3XJkkXFgV+qaB5Y1IZmiAwHbkbMSQNIBqA5kGQYytaNoKJG0TnD1YXkUwDm9EyNhETrwDYJaEIJtvOsQxqIHQABksONGDdDkQh1M4iJMKN6cGXCpevZM3D8PoqIpMOv6QxtDuHLmcEBzxA0YAfNkUMMCTHC3OTgwcoNk0GXkzrLRFyXp0zQzG0TgYnUKtN+rbRpAyzDYgfYEWAPkUS3bto1cqT/EKrDjRthgypT0vWHUj8nTnSJ7iKjL3StC2k4aK0dgQfsLoxHWw4+gKdCDZC5cY0wTDjxx4PrfZJHLh91UQMl9t1XUH4S8YSdAwiE6IAHSZBIYhIqIIGECkFBhiATEvwhQSVOSPCJDBRaWAsp9oGlYVj5jQjYdiA6EEKIEEBwAQQoquiBCkkkIR58TsjwB40xUpJLF2KsUkMuVhxgRQ0/5ldWIGVYgRh/2oUAIgIQeMAki0i0cCIJKXzySZUS9BJLJZRQYkcuJGSABJk/DnRYa1EkAQF2+n2IwJEhnuhBWh6Q6AIJJEiQhwwSSBDNP71Y+YcRYhgWmEAQQYfTh2Us/wLFIhBM6mZ/SMoJgQtQ5sCiC1NMAUUKoEqwjCyV/NGAERjw4QFFKpbp0IcOQGFLCIO1+WZ2tcIJxZM5lAhBFFBEmcenyigjQQPL9mLKFTw9pNBPq9KE01ltapdpkUWGCGetFzzJIosekOtCEsF2Giq7RvTCxxWt2ZQAEIrhx2EGIRzJQZwqOCAOtXAiOa4HFAsMQRnlQjFFBBEYYUQEDEcjK5QSL+bjTEHux58HZQBTa3YgdhsiBydcgJ0KHlwQRRTjqpFGGpBE4IURDLywyCJTeABFqgqpcEFD9ubsWmsenFDGCR5k4C8CF2yc5AlyPDoiIHLgwQEKTaQhSRpqdP/qRQQYAMLkk1GqoJBrFisUqZHYcRCGHIFAwKbIcUBwAh4QuFk2HvGgcIMSoCvBtxdqRNBLL7Q+SoIMbtyU+E4fuunA3ZBz8PEFaxN9QiCYfwgBBxw0oYYPPoBBoA888OAFFswrE4UHMuQgcb0b5uzBpI2jIAczJ3Bw/dpREM1B5RQ7cMIJhDShRAtggEE8CVOQEAEWwQJCrgRfiYVzYRiHmLEDSgsDMwJRNJHBSXe/0w4QPECIE4zgAu5TgheqYIQqMEABC1BAA6awpDJgwU3zUsj+InakjGlMewTEHJKWhADdiQg7Fzgf+1wQgQsqgAGa0EQP3vCGBRDiAhcAhAT/nqSTisjkYiHz1wkex7slckA7SmLb7x61GARcrmg0ZIAWt7jFN0yAECMg1yc8EIIEVIR6ArEeB4DothOgAG5yCAMKcMdCFiatcVdUAsxe8IIGVAEDF3xDDxbwBjACDwqTGosIqwe7Ec3xAoRAQRjkCDdmoGCNQMQdv67TNjycgIYN4KIWFbDDCQzhCE04ASCg0IgyqoqRHlIbG1FASzk+7geEAB4m6ahAIMCpexdoAcxsqEV2YQADGFyANCB3vbJgrFUEUVxstAOiC/QBeCOgJSEI8YMbSHIEfchkC3CFgDgAswXruuEL/jY/Tk3hBW9QACAAEQhOlCEPZESjmdRG/822hXMEI2jCDQb6g262ohXZvKbRVvg7DoAyAj5IArFC1akGHPMNq0SEHzTKB1kg4mZASsBXKAWwNW5CCQAV6A1+UIc13IAOCFXo2uoIiA0mgVMpSEGoxgMsDLwBA4u4gi2GOgc/EIAP9VLI/46UJCUFE6Wga8IRVrCCNdDhqlcF5wV8EaKAIamPFMWTDDAQgfH4IAIKmECzroANW8xhDofwwxUWGZHMZexfCPBFCzYBUDXQ4QhD2MAGtHCEGwhPDU2Y4ziB+C8O9FEGKPJBCrCgwQiEigETUKsfsIGNewxjEYaR10JGNKK1OaAFoWtCWuHwgRjEYAMdGIIUmuAClP/ScUlAbAJYOUUCLzSgBzfU4gTWMQFpcAUBV/CDHyAwL8PtJDYhKAMirqcYMLSgBT5oAgMWsIHWuta1H4BDB9agBoAytqskUBYDGgAzdi1gAetlwCAXgAEohEAFV+CDXB0ihuc6oAxHKoOAsXNdH6hhuxPorne/C14bIPaB/roAFCRwTAXcEHDyVUCokNkDDDhCa1cIsSN0YsadeEAZ3kAEBDhxhW9lygdTqAIGEyzYGn/gxuDdgwtGoIS1IWAKFtWiZUMlARlgYV0NUMA5oACFMljDGhmLl0I84AdTyEIWfEBEGTIVJRK8IJkLyGxmO9ABG7t2Ay5wARDjFKITHJP/rEWmTW/Zm2QFYEHAZDQhUCCSBz90FMtZDsaJsvjeQhd6zBMos3dtcN1xJukCYZAGBtgrgZdNwbcvYJmFpxCnjDXi01+RyDGg4Q8+mIIPfCjDh5MA4y8bWswdQLSiWwuHJrSgGghgGtwkTWkveKG3EYiflzFQBm2B+is6gYYATMHshwmayfK74HvFnOhYi3kDrG2wC6pxgTdyQA7NmLQExMBqMdhG2Fh4Qe++goBj82TUzJarqh3B5Ckgc9pkJjO1r83gDjTBuhzw5LczLQE5wwIWvm2ABCLwgjBEwZmNSNKkznKMYfghGhuFgiPoDQUsYGCQiRastfed4AXDQQrj/8SDNizRvSgUuVMyMLf8qsBHOZwAAc4sp/eiPIxYxCIa3+iGxj/ccQX0kMywNfS0w1zy76JiBL6YhD6aMQmlSWB1OyXWHhnQPQ64Bgi/q5ytoOCHWPChG8UIxnQ84IIv93ABNmDAEfbAcAYMwdA2eO8GzmxrMxijoGE4QfymIIEjS+BvfOS65RBQxaaKyAOL8LN+gTEdFbjg4+pkeASER4IDJ1MBmY7AHgILhz2oAAXNQAUoUHEEYcP86iuTcRMV40sOME1ETF3GwxwxnSRIwMLsjYAFt8iyF2wXGVVLvA2GMARGX4DqxgDFLK7Oah+IgXhZVIAWCvCDFgAIlVNogv+2rOiHMrQBRUlIctWEz4AqWLAKwU8mAya93Vhb2AUo8LsWUMGAYAuo+u90QXv3AUOAAsTTRyzzM0iCJpU3BRamQewFP6XDMjDTA5kFeiyzXe+lAPiHCq8FX5ZFAt9xUzX0cQomXkcgP01ge3gCAXFANJZwBW0AJS8AXOtHGyoABJbHKQ3AXRugYbfRea4WBTcQA0tAAUPQf0WWUymwOhiWVrQGW0OgZE2ABZSAC79zOdoggyowBRfUfyRAG8TTAi7QNxM0ATe2ABFAAj5AhmLgBT3QBJ1whEJQARp0ZLwFKk/YAa31AbA1AQvQAxTUHlnIDHJwBUiDVha2fhTYiPL/tQCt9YMvUAV7sAfr1ACFRYcVYAZHMGRElm6AZAOg0IeCBYiCaASESDSBEIMk8mVgFndVIDV/g2B8eGYaNEp5NwQrsARHWAEP8AArsAdEVnwMYANaQAHgVYqByABGACgeYE67YwlQcHlGN22AmEHSxnR7l4xJaAMlN1i8SAF16ItBUAc3sAdHkI4r8AAUsASuBQd/uIzL8gdZiAdyII3UOF8kl1kLgAMLwIdReGNwwFrhtQHiOAMIWQG++ABB0JANmQgV0I4xIJCxJo+WVY/32FOkBHJjpm/w5Y9hVmYbUHI35oeCxYsoSQEUoJC/2JIVIAS8WJITWZEKEIte4IKX/yMH2hAFgMBhHEltOHBBmQVcetcBYYZt8AiPJUmHMyAEM6CQUKmSMTmRtGaU2GgEz3g+9ggITYBMpKR0/bheN7QwWzQBFvaPggWP7TiOFYCQbomQKimV7ohjG9CPOGADQXlA57M0XWlDPfCXgLlelKYiJNAAJFADSZZkIUlmoACVL3mQbhmXccmL4GWUOBCUVbAAcnI3J8CXxmdDD2hh9McuBMdwxtcDWtRDYqYFDxCRkikETimZk7kEN5Z0mFlDzxgFL+iZgCRKgvmIhPSA/jiUyPR2E2AGrvmashmXMEmbfgiIOHBDXrALv1MGwHM+uvVmx8QuwccAIGloIgeIk/9WjQvwAEIgm7Apjsx5njMQk/BolPHEALAgA7qyMbbHR9vJMC+zcAh2jTRWim/AXhfUA0OQnHGJkOd5oBHZnrT5nhvIAGngA/+SJBxACPg5afoZKjUEfC7zfghGX5V2QUPQlOiZnlL5lCtJAR9Am0m3AOnIAXaiJA0VCH2Un8tiBKGCBREgAzJgBzy6C7uAiruQmPypACNKogcJmzMwmSj6lCvqh7FmAz9wBCMQo0nygsHzZtzJLlc3HjolYwqACt6oQTIAMzoqX1qAoCqpkE65pOr5lE5ZAc4JW6hQVXTwRP5xpXEQBzWlpcaEBXmgIjmgBntgA8YYWJm1BznAMor/yaZr2pZtqpLs2ZopOpGCxXw2sAd9MKF6CggvoKVGEEoKNwXEY32cIjUWpAB7kHDSppCP2pZueZ4L+osoWpuxRVVSQAcj8D2baU41iqGhBKxGQAvuRwu0UEHtN3wDWqCvGquSuqQz8ItQ2aAboItx5wWMsDZXegK/yp1vVkwtQ6w5lEOpoEN+iQor+QCJ0Jpt6ZhO6ZQtSanhqAXNVwWMQAftpq01taXs4pvzGKQuU0GhSUpDUI5BIK0Lya4vCa/x6pqgoAVawIlPc1f+sacnwK/9Gprzp3A8amShNLAKUAedcLDrGq/SWodPGa8Q6ZgKuQJ0IAm3smKcwAknwKje/wqyN8QujJqNoXkDI+uQDcumsPqLheCSRduSIrsJjgAiITazNctwxgSayLCBCoAMoTlfwakAs3ADrRAEJcuuYAuVQmCyrVkHdeC15dgJIzAHSRJiiMA7lqWjQQaad9ePYMmPNvgDrXADB4uwCeuS0Xq0D1AIFVAHr/AKQbACajsCwzAMIXYFiIAI9QAInjhMoYkMPXCZr3aNwAdTnfAKZ0u2Jvu3g1u4h1sHK4AC3ncMPve4gYAIlHt1ehhKW/SAmXtogPiAVXAGjAAJdHC2fWuy6wqRJku4K3C4QWADI6AYrOsHi8CjWLAML4CHTbhwMPOtX6l08ckAtDAGY3AGZ/8ACTcQuvEKtKTbmg9gjitgA3RgNHPwCYvABD46VgqXdcWycC9Du8kkSIs4abDgvWcwCmewB2ZbB7+YCIXwkOj7ta2pBTdwBGuwAjewvOSQAr5hBxi8CxhgeHmQU6uTAnkwjPobXMBqBwBcBOBLBmQACcSwBi4cwdI6uA2rBWswdy41AirABDrMo3bQBXbApaFyLjnFBEMMKlgQqhgbSmJQBEUwBk0MvkVABgJ8BrTAC7wgBegruA28AuY4d7ziBDosvxisA2P1Ap2CJzkFH0MMI0fcMlu6XTJABUzcxN5LBlsQxeDLC1RcCjagroNbCOtaAQn8UpBgbvDxGxhsBzr/oAM1ZMYk0MFEXCUyoMM1UmkW9WZpJQMWMMdjMAreuwVyPAZkcAbfewZXvAII3JCt2ZA/oAaMIAY6AMa/IcZdQMah9ALnosNpzKOhUglIvJ0IJgM6YAGgLMqkvAXIPAqjoMKjbMWl0MKqzJBBcANQkwZW4AlgXBkYXMuMDEhmnAJgnAJMwMtX4jJbaoFqSAUWQMxO7L1FsM5MTAZFMMUawALh25BFGwSFQAdpcAs8cM3ZnB4+vMhjBUgKx4RU0su+XAlY8FuF5gVbsM5UMApbQAZOTAVskNFUwQYaAAOu4ApsMAbEkLgr0JC3wDdAANDZ7Aa1oAPcDDjbiQUyIMsN/3K/HgdmbyDM8EzRTZwOmFAD1zUUB1IDd6MCWcAIe0BVDcnPaSARnoDNsuwGFrDIFiAGWzSeCrDBn1gJoaQJ36kAJLDOFiDHdzwGItACZvAEOJC6WvADF9ABX2AGPDAGLExVdTACaSYRh3AIVOIEKbDINbDIXsAAAUAVIIADSfitGGAEWWABWWAI71UFWaDOOjDHRcAGLaAFIKABJgACoQACJmAMIAADJRAFWUAGjLAGQ6CrPOYACfAIhwDVTpAHsJwDi0wFWXAHaVYDImAIo7SIWcADbm0BqZAKIlADFqDRk93YQQAC07ADoKABX1ACX9ABMGACO4ACVIDakLAHdP+gBqDDY3s9B56gJzHnBovcBWdtBiZgAkNwAZeQCgxgCKlAClnACpNQAk/QAtSQBS5gBmGgAvIwFCJABDwwBB1tAloAA0/AhybABR1QAmEgAqjNCLBwCzyGUrfwVhwuITm1yJiQ2SxABPW8AjXQ365gATUwAj9wCgx+ARbgCpPAAk/Q1mZgBhxwCRaAAh1A4yagAR+gAU9QAiCwASYw4agtz2igBJtwUkrA4RwuxGKQBTWwAiBABE+w2UdwATWgAmbwA5OwASXAAlxgAhuAAg4wBCXQAUK+2SvAA0SABEPAAjhw3dEd4YrQASaAAhQuz0WABpIgCS2QDC3gCXt9CHD/9Qg5JQMiMAI4wNlm8AU1fpdmUAI7YAJP8Nk78AEmUAKncAomYN1XrgE/YAEwwANawAIwwAKz8AMgIFss0OkjcAnMTAZokAZKIAlg4ACP0OuIPgePIAqi0AUWsAKXvuUbYAA7QAQ0zgLTAAMMLuRPQOI7sAN0DgMaAAIsUOowcAdDwAVcoAUOcAM7EMEjjgMtcNryvAU8gAaQAAmK8QjAsNe9Tg7CLgI8YAMs8AUogOAmAAOjXQIaoAElwAVfAAOfXc8sANr/PgA7wAVvTgQ+YAMDXwJ9MAI7UAoXcApPsAJIkA7ZwMQW0O63UApKAATAIAp5gAW9zoSY4AL/3gGp/84CHUAEMEAEdc4F2Y4DRGDpREAEOwACT7ADQL7ZpS7xUqABoaABOIACNtAB3ud1cpwGaIAG87A3dMAIw9MGZyEeip5TIc7zX6ABirACP4DdTA/wGqDn06DgnW0ChvAET/AFP/AFX8ABIpDbk9Dx+m4DKNAHYMAGFnAJWaAEVY8GPAAGacAIf64Dq7AKYbIKvpFTXXAHk2ACLFACs5AiHLACT/DjbV33O7ACDjACQ0CvHXBJQNA2PMAGW8AGXgNAQ/AEP4AEbGAPVLAFoKM3W3AHd7A3OiAGFlATq6AQ10AZYK8CI3ADfWDUWSACSBAGYx4Gh3IB3UcFIjAwLcADhP/PBpcg+KDs/c+vAt6j49aVDDx2C0rAA74vCe0+zAKB3K4QHkzADcxBBCJgASIgAsEfCSJwAwABokSfSCCyWIiUygQIFtQwiYBowYIIC1ssUqGShY0INhbAgGmRbNMISX2U3OGBJk0aNBYOABHhwsVETDx+uIDIgyISHUVEjDg1pAWIdRNw4JiwYIGmmD9+3Ji1xsWlSxYtorHI46NIJSP6tOjTahwYSfSyZUNzQBUPGyYmEQJzZIcNByiGhLFQiweVjmBUiCixAMeCHpoGRxohRYMGEyx2hKkxEeNkKhZFUEHTBbOOLUUqomFETI2OA65GMAwFAlQJDTfC2dBwBIz/Th6EIHUpokNHF4kSu6Qi5QIHERahNNCNsmKERB8WeFjwUQOFiztNmvBoMsLFiDsSMSM5YOEH4x1cOsB4YmNFKRDGpEhBsQLEjiE2bBy5YQOqDRQ6NLCFAYcVhtDChiFA2GCNFWwwQwozGCwBBzPm06KEL2zYwYwVVsApASssOAKGEogDAQQpiCjBEBNMgGGHDzTYAYQnNCBCkSeIWIgIKXwQ4YcdUDRBi1IU2aEEEIj4QgMWRNTgCxxBUASEJJc0DwYNfrDAClV0WMNKImCA4QswjcSBiyc6YG2DEkxYjAUuRCTiuOeG0ACEI5qQDwRDhuOCTSK4MGSxPrkIJUIY/1hgQRFDiAABSy15OFEDQ6YB4bw+HWPhCRYEwuGLHXZYtE4WWTjluRW4+OIGFH5gQYMnWGQszBW/LKEEG00oAYYO6lxyByxVaEeHU01wUoofSthhVxNitAEHRE+R4gscIjRhiB1MQMEC4WAgsoQOYvxhjWtxAOGGC1bQND2GTpnWjB2kVUSKFrpwIDwX1iAEBf6QGCGKC9ZQ9YYWXDjih4Fd8GEEhcFA4QIdWODhBoCbQCEKFG6YDQUOblihhRrkY8HcI45owQcXVEBBOxRaiASQeuFxTiIedOBGBBUuAKKGm+/oSAeIKBIhkiJIiYSUVJA5QwQkkHDAlwsQQIKNjf/YqAEmHWzA8QIRdNjLMyogoqKIP7rhxJcDzmanBlZq0SUTEE24wYEV4LaAmy5yaEOFHGqYQgG/GWBAAVIsaOIIKWo14Qicvo7PhRryG0GHNJRQog93wKhcuxG+8cYSBM4+G4lfrpkjE0hh2AMFEDQgxAJMJIpooki6iESiLHRwl0YupNhDwBpEqGGNcoFY8ILe0EBDh8rf6QQRFwjxphgIQD8ACVVqEOWnQMMIsYQwTDbjB4VXEN+HG1z4YQUfeJilhCdgAEHjPhy44IYwFBvihmW1OGISkmWyABVG0LwrNKEY0qOeFZAQGQtMAkYrUAyaSqCFTRmiA5tKVgYVgYL/rV3ABjAwgbukAEEWrOlQHcCBsjYFilIkzgdFOMEVrjCCYliCBtRLwAJFcIMRgaAxPrQSrEBoJS6wZkQluEDRfCAF85THVUX8wKKCxAUcWKlFJcAgCroAgTJY7BvWSAD1XsIKEaAgVxsqIQje1EPGMEoDI4LB7njgBVi4oBQaMA6NOiBBNw1BCgIB4RsFogEpzKwRELgAIfKRgRsmUBXlGIEhWICCI5jJWbHSgCKqWKcOrM57XVBDFyKpATNgUQPOYggLvlArIyliAyiyQaKylYNGeOACy5BFI8VohZ+YgC4owIG5frBKEGzISCuwXyhYYIMWFGEEAkQWB871BYYc2Ec/R7DBE/KHgi90YAVqWkNzMuCAKPDBEmKkHhl9MC/o8OgOYZgPAjgwnwsgYTxXsgAsotASSrZABHdAnxRI9hzojGA2NfiBDzvwBDtZAAkecAQnyoBO0FmBFeVwRQ0GoQcL/KUJO5ACEFAAUp38IF7+pNwmJHIHpTGQBzpxDkEt8DsXRIuhLDgCD3IQghAEwgMU9VAGVPELoopCFG0IgQgitpylWoANDDPeHcCwiRY4YBx3QAIQwgGE7ki1Gi1oARCA4IAQ5EAELbjBewzWBaRCwBJhTEBAAAAh+QQBBAD9ACwAAAAARAB4AIcDBQDouKs4Ri/QmIgTFwnEiXTYppIvOCmmuMi1d2qyxditZ1LF2OlKVTfvxLmOKUypWEpPV0onJxjx19LyR4dYZk3vycnKlHrv6eesKFTxZplMRzCTV0pSR0oqNhvtlrZuZ2pudlDuiK23hHOuqKscIxSOiYyuRXTxNXzxVpH19PFtV1Vxdm2PSDPjq5m4zuH0d6ZuSExuKDPOqa5vOTRxN0vop7MqLCaTlpCYqLpsaE5PODNSKS1tSTX1KXa80eSPNVKrRjBxV2vS4+6Od3KwVS2zVYaql5d6hHGRR03FeWvLN27KioXQt7eUZVSyc1rQmazvqcN1KUeqOWqqN1Pvt8smGhLGWYvQx8eOdyutamhsVjD2O4GMWG/JZpWWOGaQaG+rRUxTZDtwZjOOlm2Sl6jz4tqLODG0tbFSOUauaIyymqbEa1XlsZuRSHB5hlmPd4eqOi2lZhWuiY7JKWSJSRaMhXP6aqFXZ2eOd1KwJCvKRm2wljPodZmVVTSTgzGesMJLORh3eDWWVhWMiFGjJxzMWC9ySm2qVhnv2uJ4hpSYlU62TYGxhy2ppnOqo5bS1NGFai6YopSrWWuueiqxeJTEKlnMc6HYuMLPxbvniJM1QxtPFyVwNhecrsCvZjCvl1PKSDPOYy3EcVpPJhZwGy+NKTSTaoS5pTbHOS3JVkXUiKfImUdPFBdTShtbVWN8e4nSVnXTZXLIdRnGmjLmlZY7S0FrVhyRKBuQZxqbpHGos3a5xLfPWBzMfITKpWV0SRZ4ZR2NHUO4LGSpiEavh6KuplymsojEOUrFijHbsJooCRE7N0BwKxmZVoKnHSmqHkusdhywlHbBKCrJS1HWhRzHh1nPpljHu0/Ku2n4G23lZRXlhxceLSNXUhy1tFzbTh7OtTTqRnvgVR0/Uz03UlU6bXZCDx9cSGBfcERdcGRecIF+VYBrbIGeOh6ScR61Ox6xTx68gx+5w5TNbqDLejTPkh/cwzva5N3gPVXjeRPhlSH107oAAAAAAAAAAAAI/wD7CRxIsKCHDZQk3JBghUBDAhL6QSTAg4BFhTJMGSoSJIieQnr0TOunZ1yvUNu4tXimZ4k4Gf1K7SlIs+ANAv0YNpQgweJDnhN5luAho6ipBRAghCmEK2QqZP0MgUs1TuUzKkuW8OjXilNNgZECfeUp0eJFKwIXSthBg4eEonAhdIxTqO60VKHiSE21TR+8q0v2bP06MBDOmj1u4SzRk0CJwzci0zhzhkZRHkTPxKFbF2QoQ6FE9erFrVfIfnuAEF4tUEKgQfIiSjiQM6KHfmxp6D7TAlflmGeCMK0bJ5Uh0NsQGaoWR08/S7FIsWYdiBQwhTcOZD9wwIOHHpUr6/8uWlkGEMq4NgdRdTx0PES9pumxRAXC4OlfzfY7MFvAAQEb/LdCC7rpFoNlMmQmwxnN4NKRKqKIEoQoRbSQSkhUyEDNfYQdVhAAFuWE02zcCWDiARv0kOIGMfSwA2Y7sHUGeUEUoUoREhZRRBgXZmiKYK19dUMEJRBkVogoGhaZByf+J0ADDUTQAA0v8rDBDj30QEMLHOkIwSdcGkJNc0C8Rc1ApnRYkH793JCHHwP1558HTjawQQMxxGhlij1wwCVHQUBAySeihIIMFVQkIQFR+NF0UU4H6KAid/3QWSKTJvK5QwwxbJDiChxw8IkfgULABy31BBEGBLK0YEVjRk7/ZxaJB4wRyRaRNCCAd/85+eSdDayQIpU7rOCEEz204IcfEDTCxycQjMKGNY0E0tOijZZl0XYHbJGLB1vcMqeTJer65BZX0qBiBDpskWULZ3DwBCUQsCEtJfZk4VM/APTb72qz8sQdk/8F6F+vJj6pawRXxhjjBu2u0KefSUWrBBuURKNvY/7++xWIIUpQAp0CVGDnDgc0wF25JkIpbHYONzCGu1s4kcDNWiyQwMWNoItiTx0D0GGIjAkM4BjAbHDiweaaWEEIEXC3w5066NCADv100UUCWmiRABNP9LAFB3wC3XF++pVA6WwbhDBGCBtIkLAAEZgMZQhkqIwi3m+I/xECGF3E0EU/HDgxiRb9ROJp3LpV5O/QSGpnaQVIkEFIA3I63YAYV7/RAJ1tI/G0CUKULkQXTgCegDXWoBtgEhDIQMDjaD+238DcVcCC5RX4F8HcIQT/hufaHRCBGBUIxClbnAqkxRPQE2OnfQ3R7qh+vk6+uyMh9D63ADo8XQHnkR0QPBL9CNFBGmlwGmoXzzvBQRZQciCyWR6vOaIEJPNaNxKOIATUWqarBojPgP65QQeQEAIQrC8GQvja1wZgABsYYARO6MAGxuAEDzTGIkK7ntpG1h3vlGx3AvRcy6RUsuA1KWXpCMH6VpAAChpgAAOohQtc0IZ+EKEDEXDCAv9idKQQGilkcmuaAEJQOUK8gYm9S9nvpGQy7dyghTroAA2ZgMMudrGHdliBxPxgrSJeDyfc2UAFIlC3u7EAb2RAAgumqDQoAShqKfNbBTqQgAIIpAB+pGAbXNAPZRBBB1Laggceg78z3k4ALFijHViABDnizRGRZCMb/XOw8hmwezHoIxe9aAAe9mMGcwifDjawSIs8xogC0c9s5LZG3bGAkpQkAw7sUIFealIAHUjgFRvQvQh0QAsFsCEOASkQAwjkAovIAysh8qoQHVEgBPtPBPDQSxDc0g52wIEJKokHPGjSFpw0kR6NuYAC3LAfXkvAE0LlhH60wQB5yAMhBDH/s2l6SFutaZIB8fAKEICgHyZIKA7ECQtYGJSbHXBS3epWARoWIAEtagEEFrAADrRTIG3Iwxb+QFJK8AEVf4jIQMziQUwtbI2vEIJBEWoCHJRhDSaAAwtAwM3fJYyFDchDAZAVqha0gKME6kE9exiJLAQjF1BtxD344CGL8IpJUIqSMWVaun4cQSA4hYNY4cDTCKDzVy2zQwE4yoEkaHQABSAQBxJggAD0gw9OzYUc5DCIRujrMBBRmQnt2IEOFPSgc1hDEyYwAa+agCBzDOYmoZS8EUDARTFowRMMUIAncHQAAvlFI4IRjHdEIxJAiQjICIAiAM3tAB0QwgqE0I8B/wRgAhgQyAQs0AQo9GO2IJiilNjIgn6sNVQcQKYLvNgPB/TjAmHZQBYa0YgNhGgHIMJmrbKgNO2kobChBC1uC4IBM1jgqwbdpIkisAI2JPOigCxAD+E6AEL2UJEHyAIf/OqTJGS3Vv8Zg4C5A97a6hYDuaWJGWZAhH4EN2Hk2MICmnnDBNTWBQbgaD8M0ENXbGALWQixK45kkQ0QIxx/aIAgsuC6FDmBCc7sB2NnbAYEJxgDc1jBg+fmBEDiMAEc5SgEEhCtAlxAGuEagze84Z3alJgYtEAFKvjwhzF4OEsc2PBALCAQC3h5xgmegBjZ2DQdAFIJQIaAbpJ7UQgY+f8JAmaldzy4g574wVlS5gOVb8EnGoKWJs7th5ctMN5TAjGYUIpACEaQZjcn4FgWBnICLuAET3lnE3O+3yyqkYxT6XkMgUhRDOoZY4HYtbldljFuc5vbDjADfAZ8wwg8m5SuHUsL8ptrP8awiZVh2jtFIkA19kGLYu/5w2OrYam7bIFAd7nGuVXBDFZgvOCJ4Q2P8CwHehCDJHgbufLqB/FKtIld3UYCs0gGK1gBij9EQkVb4KCWmd3smhRa0P1gRgcq8MRr56Gja57E4QD5BAsjQQeRucEm7OhBdKv7GqAAxbvFtoUn9IOQgmasl01NkHubYQ3BfIMuFtE9HXTUoxD/+HYNBYKDEAigTVcUA+e8IwF1s+IX2ciGSLOkg80S0gGEdra9E9yPTDhQEvM4Bg7Y1dGNQsCoQ/ZjAbpXAdqkbHy64k4e1n2NbHxDEO7q04Z7eMoBHGEOFh7ADAiydgc0Vsb96AAaeLFQBspPiJ5dgNcEMoAQEFMA2VFYmYkBil/8AhQC5nY9MQzaSAskyxRspg8TMIfFTmAOO2DBMTIBiUzgINco76jN3OnEEBSvZCZzbfhC4IjDjyFidOXszUb547QX8s+1nUETmjADIB5DEryAxCM6yu1uJyEGfnYmFnAQ0QOs4Kv1VNrq7WAMQrzeWDbsxwSZwH3uJ2AEMQZt/zLxbQAD6HjuRR8AkQmkLk6ROgBm6AcGmsCCDsSgH4xOgK6eFgIWBLBqOjACO8RZF8UBYKB9N9NHhGQBjbdyzbQCLJAJcKd+HSUefaJst4Vg5nUE4VYBOuAELcBEdkAG//eBtqUMjacbO3ADm8IBbqZqGdZWKyB5K/BYQ8AATUCBT2dULmhhdWUBuWUGu5WD0mAHT8AGoZBLJLgIVUMEdXVBHGAgK6BFhKMFTNAPNaZ9SYAyadADWmBXsHCDzTRrJ+eCOlNbBmABKiB/uyUQLsAEF6MKufQIu8CEOiANAVB+zvR9CZiA9SV/MmYAN0MEXOMEI3AEJiCG/YAARwBkQf/GUYFkAJDAam14cQMQh7nkCHVYNQPQBmRXdkzQh38GhLo1AF7DRc7UBP0wBGKoAICAf0F2M7nXDwwgEBjAWG4IV6OgCkxEBmSgC8bgBE7oAqdGEHrYcQMhhAbARRnYWKxYiwORA2UwB3NwBNYoEAwwBAIhhFxmiQWgBLz4Br64C46QB05YV1/RjTYgaAiGhas2AdAmhD8gEAqgAASRA/iIj9iojRr4dst1UQsQAuKoC8dQjuC3QxgnEEDXjba1ZbgIjzYmhBPAihTJANBIEy+QjTYmf924jFyjA+L4i7tgBwe5QzVhAxTEZQGAcbvVQ/BoBjC5ahgghvNIE9nIiqz/FoSBhkNKwG9vUDm6YAfKVko0gZLJNAAL8ARHCVrll3EzlgjauBoWaZGsKH+51Vg2YAMzEAABcDXBEzxYg4Y7ZAMI+Y8A+SIcUAAcIAPu5E70BgmLOBAXiY1TSZVDwGpcRpYDcIUGpANfGYBHqYd6CFcXMAAXAEiSxncBgEOfSBB1CY0/8AOPeZMI1oY3FIoDsAFiED4eGAIDUZheBFfJFGN5WH7ryGWE1IkDgQa0+JitOZmUeYumdkNaIAsG1Et+6Zk0EV83MwDrWBAaNxAUlJCT+ZpTiY2reJe36FwrOQCTAAEKYzLsQhDx9Y2ShnsDMWON5QIXBWMuoIrFSZcW/4mcOHmLHckEgfMfWVUBdkCdZ+aIygZXSqAEycRFA7FWSlBfqmic81iLUxmV/omTlWiNe6Set0kIBTACf3RmSoAUOpMUq1IvbHAx7nVDBUdB+9maBfGfAvED9jiT5nlKOHAEDmSgyJM891mdHUUgR+VOBpAJa8dZUXehCUmLNfkCdEmLBaGcuyWBiNg7mKKZMidUKepH84QZNNAPczADM8BbbTgHNFBwhTkQGTmXdJmRcqmjtzgBu4dKvaM0LTOk1EmfcMVRnNJtocI1ozQHyOROxGmlWXqR9sgAlclbAgEFZCUA5fYkMueZfmRcPgao3+gL3OcLvqAEXMR9XVRK4P8Jp/0gmQwgmTTRj6o4A6aoBiYkeH66oH9aW3C1M4SqCbUwqppQX3roAplQkwggEDjKGgqAADdZi7zHBGoAB5naMiFQnfEVmp/KBrIwn/MJY4LZBk0gjTmwGq1qkwwACXCJBkegNfyTMH2qqz62qBWGFEnhXjYkmGWgCMeaLYSBADkAB4dAMmIgCOgaAjejq9Z6Q3CVf6NJYeWXU/n4rf1gjwRRjwKxqtFIEN0KAq7wH+iaBYKwaH1UnRS0rYIpmANxTwbwCIoAC/Y6EPhqj6uarP5aBmWAj/8aDVASYn9QsJJ2sNVqQy7wmwVhV4xnArBgAvbKrzUxj54wEDNbBib/oAgbqwgGNQuUEGJZQFKCkAeOWHDxdQGFWUonSxDFWH5MAActawIbC679ULM3Wwb9UH8HwLM9G2KLQAhC23RJua5GZrIoe2rlt5deoAaVAAcbO7EC8YpfAbc3awIkIATaMQufEGJJ8QSg0A9sxSWxyEw4lLT98JuMNwC+cAVX4AVeUAlQ67b5uBo2awJzEAPawVd+sCNJYVxBBnXY+gRoFphkiWE3dJgFMAmK6wWM4AVzoLFWKxCeoI8DAbMCkQkJVQlgsIIS4A7woiphEAaIk3d+0gIuaFRBRp9LKZrxFQap2w+MawRGUAnFsAbUuwYF4bb9QAJrcAogUGcS0BGl/xIGVBAGgBRkfmBULRAERlUqOgOsaLYzyZQEAnEF/bC4XtAPRrC69HAJl7AKvtUPgDCzNFEGcEAEXcADNwAovhsGQDAJAuF0RVUE55u+gbIAbAA9JHsB/QABUzAQinsFRvAF+Mu4JLwKawe7nsCvsWsCp6AG3qYj4Pu7QAAENVQAG4WtFSMXNXLDyAtIzjQJD+DBJ6C4X9DBIOwF9nsJ/xu5/cCx/eDCQADDceC7VAAEblamOAwBRZAUHMUGE9rDfwoBQPAAXzDEQ3wFU/AFX8AIjAC9RuAF/LsKxdC2AoGPJtAFlTA4iMARU6wqVZwEI0BBa5XDFcNRozAKwLozxP+ofVMwxl9gBPVLvzMsEJC8uvx7CY2LjyTQxOPaBQfYD3scBJsRB+MbBkmgBTZ0AU1XMUUQZPbCBjpTalowBQ/wAFPACI8syVJQxCdwAm28uJegBmpQDN+Kj6cwOD2xx3xMGeN7AkngTjh0AY0mFzryCUHmlvbUBhBQy7aMy/WLy7tcxrfsxmoAvWowB3XcyV2QzMo8F0BgylasTEZ7UY6YlFKqQ/a0YUnAzR0swkRsy1kxBb3sxuYsvWAFAmL0GIMwCDqiIy1gyt5Gwy4gC1kRC0fJdxpcAHuQAXvQB3yXBF8gBUHcDx1sBFew0Q8g0hmQFSfgxs5gBMKsWGQFAnb/SwB1MAjKLMFJAATelgQnsAQyIEZS0A8aYK0DsAT9gAQR8AB9EACyQAd0kAEPcAIC3ctL8AAgIAkk8AggwANSsNIsXc5qOwdwkD5ctdBysMfQstPedgJxhwYf8AFoEAEZUKp9oAkUXQo48AFV0AEU0AcP0AE1kAF0ENA/LQOSYAMpoAEi8AFYQAIRwAMdIAN0YM5qMAncazpgsFecPSotkATiSwcd0A8p4AMUkAL9IAPisARSIAxBjQSY0A9VsNR0EAG8VQEyUMsZgAIPgAMi4AM+UAVYgAIfoAFoQAJNQAJpsAQwDcluIASvEFOHwNmcfb5+wAFALRDB3Q8UcAQd/0AlaIADkjABIqABFODYIMAJOKABMDABJIADJMACUiAFaAADFEABkPABXBAFIoABfcAFMIA+0CsQbnAIh9AB6NABiLDQg8BXdaAsEOBgH3DeaBAFVdAPHzADaCACMMDXiZACMIABVWADj4AFVZAI520D+03XG0DUIpAIKNDYFvABKBAFGmACD+AFRtDLbtAFQhADaXAAdTDkDY4IddAJnUAFQQwDInAEETABkAADPpACVZAC2tBlFBAFFmDaMGADFHDhKYACPvABHeADNYAFKSACFKABMO7lMGABIoAEGWAEDqwabiDM2lEHwDDkQ94CSC4QM5ACUcACTXDeA6HmFP8gAvvdD4kAA1yQAhTQDx3eDwDOBTOwAz4QA1hAAT4AA2hQ6FWAAjMeBRXA3AJh56ewCkJwA50QCJ3A5+hrCSvgW1yWAimw5f3gA+vIBZFuA2OuAcB9B/1g41xQBX3gA5jQARkAAjaAAlxgAREQ6DBu48m+BF3gBm5QA4fQBXCgBv0QA63QEKQA6y1gCTHg61FAAcK+1/b9mxQw49rwARZg3yJA5SCOD+aNA4O93nfwASmABtI+4TCA4yfgBl/gBv2QBl3g7W4ABKRACjhBCrxhVFQgBZJQ7yLwCC+SPFUw4f2wUFEg7LYA2xZgA7zl5DOACRFAB5YAAhbOCzBwByL/fgQs8N47sASncwghLQWH0PD7nBMQTwDNoBlGZQk7AAI4oA43j9Q8gAT1jgREgQfMJ9WFpTs7UAMPUAMdAARQHdhRs9dRgAMH8AAyIAXWLgSnQFvzfQj90PAjndupTQNBABWW4AP9MNKJMhOPJQKlTtK2rAmakAJ7cNUDkQGEnQFAMAV0MAx0IANST9dTsLhdUFCHgAdCMNQFLgRuEMQA8ABiFMSW8PEzOBAPwAOq4WCY0ARpkAL8ULhcKRCakD4LZQKPcAQxMAxkrMZfsARSTQUZ0AHe9FAdgAfrIAVpcAjsIATOgPBeMQMfIAlIkAZHAAMzcAAsMANI8ABpovgP/5AGOyDphXtxtbCOewACUHDf/h7gIk3SU9D+WTEMIjwFbkAF8g8EIkzGbuAMaV8DAnFQKZAIANEPkggKJrrNoHCkAxBo/exUotIPCBAqDzI8eEBFU6wVNlCkSERhxgEd/VZgjPGgn5QYMlisqNFPZj8QK0BIwTgFCI9+D3BQ+ACDi4V+VWb0W9WPFxQoLGTCaDJjxhETM0w8msECCIV+R23kaNI17IQ1XdFAQTMDzQcbaPrB6CciygwRJGSeBNCzrAgfKWRC8QGjz4cPbzFQgFuFgo87VXwU9gElRj8cMHyIKCziDgwR/XxEoeCXYJTH/e70Ae2XAtEUOKQs4wSk7P9imVFkdvZYxQLBCas+UAjNJa4PkT2bcD0ys18fGz64/CauAfhzLolE2OiXIsVpH5QfwO4HmEIfbf2IPk8BI0UV0TaiwIChgXi/wikw9ezHJYoJFjhSUKiiMKD6iYKw7kTQLMDOLODKLxhweIAHTqTI7wPSoMBBBBgYDKorG7TDBIoobJDrgyZg+ICFBzryQQPOJoDhDhzWQBE7EyIoar2j7CMRDRhGvAOKDqi4gYAV17CDhax4AEGHCNbgz4QOVjgChylXiAEELdNgIQIg/DIBSjhY0IEFE9Loh4UKTOinAxlkSuHGIxSKYQUuQYiAhQ72yOOAfs5RCSOJ8uknjQj/bpBhhwikoOMBIGZSaY9+rtgjFk2U8aIfHng4wJYIBOCBDjr6oUOGbiSa4bEIdOpnip5c7WeYfti4RhBbZlpGhlJMEcWQB474wAQ/g30AGSpoCGQHGmjgwABnBxjAgFhUOgIKBD9YY4VW+yHCJBmqAgEII7oQAo9yOigXhCyxCWcRAZTjoZVm5DAkvH7mcIoCOx6wRNCeIqViD4yWAMLHxbiAYg7b3pShLBNu6CoCjB74wg0gyjVHkT9WsAObXcSAlxMZOqGpDwqQSO4DJOpEAwctKVPXhBVw6CeGHR4RoQrT1MTjgAhMQAIKCpowocMjJFFIiJOmaEfjLPox5psG/5TrRwYZMJIEsfBWQzC75Sxw0IINY3QKiA6O+sDHwqBIAbPsLLCBQ78G+uCIyULIIgsQjFmEagJ4eNMEvujzS0AB6euHAi4I4kuECCqNAYqhhAJwcQz6KI0C7LjiTIO3WKCigTHKxMYVAqjmoZQ0O4OzM+EGB6o7CgZHuB8tTlhhFQoOW2wCCz4QIQUumoAiLvpmj4uC4oHYpIEI7EBFgtOp5gQaEPpIoT8uqvgQecRs44qo2ZGIiAoQpEMjeM390i4KBDu7Y4LLZthORRo2URQUVKimGgQboDgAC2xwIxy4byasA9oEUjCDDtDEfBqqAI5s8x+pmOAI7iGaAIkyAcQRrCElEjjACvjQN/7JpBQPiMGQUDgZKSDhLQKowFsiwIOfUABCXdCBGx7AAoWsZGZQOAKOaoBCEKRBCjKg2QcsoLMjREgArhDEGEo4k1I0RAZBiIMpaPAUKPCABTAonk+C1EAhlBEjFOKBFC4CKZlghAoxWYGIdJaC5NDAAx4gxAZKeLobxKsVregEMALhAZmYAAQqMeQD6MAliUkhDULowAHSyIMbVBInjmRGBzpwgwNEMCYdMAFTpESFQTZgEacDQEAAACH5BAEDAPkALAAAAABEAHgAhwMFAOm5rDhGL9CYiRMXCdelki44KMSIdKa4yLR3akpVN+/FurLF2MbZ6I4pTa1oUlhmTPDX0e/KySYnGMmTe09XTPJHh0xIMO/p56woVbeEc/BmmSo1G+6HrVFISmx2Te2WtqlYS66oq2xWVHBna3B2bJNXSfFXkI6JjJBIMvI1fJA1UPX08RwjE9Cor61FdVA4MnA3S7jO4fN3pm84M28oM7zR5JSWkOemsm1ITNC3tGxHNpioualHMKuXmFEoLPQqdnBXay0sJ9Hj7rNzW+OrmmhpTa9TLrFVhqo6au+2yo52csR6aZFobY94K8+Zq++pwicaEnQpRmxXL6w2UsyKhfY6gXmEcsVZi9DIyI5IS5VlV61qaeOxnMlmloo4MZU3Zcw4bJFGcI5XcPPi2042FlNkOouFc5GXqLO1sMsqZlQ5RXFmMo94h6c6K61ETLBnjbCIjbGVNPpqoaZmFbCHLpZVNI+Xa6QmHK4lLLObpslEb8VqU3iGVoqJUIpJFVdmZ1VHGc1YLZ6wwqxWGqykl9TU0uh1mHJKbHh4NpVVFI94VZOEM5yuwHmGk5OXUbZNgTNCG6lZaa5lLrF3lLB5K8QrWcxzodywnM/GvE4UGVAmF3A3FpRrhJmjk8hGL9BWdsRzWti5w3h5iIkqM4hoKrmlNslIS+qIlPTZ4k8XJnIaL25UG5UpG6yZTslVQsxmL8h1GdOJp8mYMDpJQI8eRKseTqyVd7nGt8g6LNNWHtVldPobbueWmGwrG5doGpmiabQsYrJ2HK+HorKpVaqndNWFHcytTzs4QVxSZHNNFppWg6kdJqaJS6SyisAqKc85VdZFgcl6gupDfOVlFeWHFx4tIywKEz9RPFUsRFdRHVpwbLc6H9pOH8CMLcqKWcSYRsymd8y3N8i4TzpVWjptdkIPH1xJYXA/Y2xuhIkxGp2mX7i4WrCwdLnClcpgGM57L86SHsKgMNrCO8nDVuBXG+N5E+GXIfXSvQAAAAAAAAAAAAAAAAAAAAAAAAAAAAj/APMJHEiwYJRNvwgoJJAvisAJDifk+zFwghBSpD7h2bgxT55nVPLo0vVJYApmecJMq5Gvxp6CMAsCAJBvgsJ8Nxu2qClRYpQoLX7UGFrDTUc8rT6eOpVBULdc9fKdpBImDEVNqmIKLFVG6wSJBSG2aCHkKwwaPybUEDr0Cx6jSPE8W+rGaS6B3PJQ3UNR68CuWnewyjdWYgvDZIUIoUHqCw1fa4V+cQO34ydBl0fme+cxw54VfkM/LKOozoTDBg5zmMChxVkasL+kaOU4xipSPVq12ugmlyDM+QgJMsaNWQZLoDaJDh2lTBlWFoUYmC7AAAcOOxw7ht2WRo0VX76o/6Pc49XvT7AIEdLl0RKVED9yLvfbwsAEA/nwX5g+IgVsGjvk4N1aNXxRoC+t9FCeILD0AMskKeTiERU1nBKfaDTRZ9h9BggwkAEX7HDBBQLksAMMP2wCw1nbfdHDEa8cIciLR7whIRWM8SWQEFrNlGFM9V3Q1XT45cfBQBVUkM+JP/xwAQw7+PfFETSGAKGMp7iRxwpqneJQFCz1CORYQixiB1CoCWRdkflcsOSKP3gQ4g4mpHAElT2EUMkksHxCxZ9aCCHUfF6hZsQOCkzXAgdE5nOkQHPugNaIO4xgggmT2JFnCHLMAk8Pb4SwSwpfGUToQ0SyUcoUpQh0HX5stv8p0AhQngjDCFtsEaUddoRQhxywvBEKH9/UUUZEfZ26I5FT/GLAFIOtqWas+UzxJIAXKGDEFDtE+YUJRFQSAh/DVhKPEwL9RChDD31l3ZH6wQorTAo8ueKKF2w7Ap11huBvKEzwUYkw6II1n3yHLXokBG3CYAA2RFILwQcKCAGDvfmwwe0OWxCRQAJcPJBAwHVYC6LBorFL2GHutsmGMgqomV+sCnxwhhEwyFmpEUbkQ0ITTYwBMhcJVEHEDlOYMCfKhKKW2n0XfMDGB/sRpADDAn1wR5tyLnJHH2aUEHQOYzRhwhaScEFBKSNeMAFsyTZNJKMGQHDFHX7URHM+ZuT/88EjENQbdR8QlBBHEIgHMcYWQScQyjfW7qdFCDScylB9ERtQQQln+MGwATEPNPEHfvTxQQXVKWAGBEs0kUMOa9DwegwxcEHE7c0YcQHlDp1an5ocCHB1CXcU8wEEbhIEwcRmGAFBBdN9YPMSQXiwxhox5GAC0HFo4HEzUj+wWtNf0f3q8lcA48fpME3cM/ICCHHBFR+QUMEaOQRRtDRVFFBEAAEowBlKYAQ/EKFq86nPot61MOKtrw8yU1I+RuemRknPeiNIwAAKUIAB9AIHAViACAtxhTNoQAMjSN5yWAaTD9ytdC78XD6UpKTPKWaCHzCCBzJYhQH4kIMgDGEE/0RwgxuYcAQeSuB0LvC8CmDNCCXQ2h2uUAIaqrBN0MOPGY7ngQQcQCAH+GEIFyCBCKShEDe4wxkgkMQVTicfJXjeAK9ARa0VI45JSlJ+8qMY6eAQAjnwog8HWYAxRsAQmRCBD3ywRgHsZCcqKwhqJPK8wpWgBFS8mxGX10QleYBIPPLb8zzAhTBykJA6EGIEMqEDEn4gflFgGkHGAi/8VAAQyyPBJc9whhvA8QqAAEQePTAzgWxxlA84QAfz4UUKDEADtyiADiIggUIUoBiP+IAdLnCkH80yTW+EgDBJQIIlDKSI+RjFKMiJy08K5GpXg0AGD5AAAWnhAUw44QAwEf/Cat6iHcSQw6/y4QdZOoo1BHFiBZIRBHKaMx9F1EM+2sBOCLhTIBKswCIO8AA6aSEFIUiABhKwhDMMIIQ6uAXenPCLX9RhHnKAyasehdEK7JAEiFuCD/KRBom24acUFSYtBqLCM3D0ASb4aAgGwNEmaOCkC+hCOFzhBCfQgQ6lYURYjETTfHjAAw39WRt8MM0IZGGnrWvCEqpITD0KhGEHCMGJcpACInSQnsqMQFRdwYiqCqMUpVLXh/ZzRQOAdQRBWMIAFhCBgVBTB09YAmLtN0Mabi4fHL2UCbxYBEKWMap+qJcT6lCH5EUBBgIpjAHYUIkKCmENXw3kSRsLEzL/SMAHTSCnW/OBjRHwwZl4PcABuhAApkJ1AQVgAwcu4ASBoqshWkjtavEzBTawYTqxbQJUaYuB2rpArZR95xSSSYFTJsCZRSjAAx6wwS5QYERsqKoTAgGTCzRDHFpNhBMiF6It9E+VEQgwGchQkDiMILwD2YJwfZiA9a43BESA8AHCcYspVFcb2rgOC9tUB3kIRA6MYEMgLsAtE+SjkAAUIRklUMYAOzYII9htPoxAgQMwgQgPoBwNTFDKCB+AAkTQGDevsxoYSMQOA82HHEDMijmNgL0AjHKKRcjiMg7EBR6wKZI+wMwch4CeuUpAPjQgMgpsQQECuE4kiFyqfBjD/xudWrKIQ5SDLZxYymNUsQhdLBAyLMEDyJjxBCGIY39xgQtn48IWLuVFNqRZzUQei5vvMYtZLNkJTbbwZjc45RXrmYy0FYgLRqC5D4CtD4XAsQkCpIVWL+5SRMgHBK8jkUisuTUSMUal5eAEEQfCwlsob4qr/GkVhzofElgCMjwAAdOZoQ+LQCqATCCJtAnXY/m4ghHIMoFIDGQ1EqmEN8BRB0ZMIRC/nsIiKPA/UFNzASHMM2MJQgY9ELMP68gmBIyQYxPkuNWbFsgNuMzC1XHzNMKoQyXAcYxjnHvEU7ArcVmsVzzHW4gEyQQJaOEJdzjjBvtGaghynAJ/Fw2zzv+DQGp4BIG+HXQKpJXDMYjBCueQ+MTEDYALFhkHMQ/ABVIG+rzzEYE/pwEXnrgB/Ra9hQfgWGRiPjGXuSydK+bnAqX4lUAD4ZxbsXuZYiap2bSL4gLkYwkJiENZ4wCDEjgjE4i8waIvleP1bqFoBfBDFA1ww+UJpDqMUoAr+Mr1MsDArgWgwMd6OMiP5eOkmBjAQH6uAx1guQLO8AQuDFGIBKya1a/L4AazkIUbZHEEPljCFpYA+A59oA5s6PoOlCn5og0gDgOowgGqoIE7F3fBAZAAcgswghIcPQuZGECD/QOg19m5vLTVwRJeJxDH50cAwvND7A2/BQ4WQLieB9r/xz52gCKQsfYajDLxS4ALohe3wSbYDp3Ou0EJ5IMFtvXBZpew7zoJb2KP4ATOsQMacErMBBswYDFaYAJfFgABpl5JNQJNcGcjIBBD0AA6oHwklwIlF1LOVAAL0GePNQC3cAZEwAefwESmBgwCCAMmYF4mABs5MAI7ZDZcUAULQGABkABa4DBrsAMP0AVLMAoXKBBmp2qXMnL0B4LdRXTCFwBFUAUB8woqCAx3kAgXkwDeV3vMNH4f83MBIBARUAAfg3aKlg87VYQC4QMN5mDrpQHO5AKG4FhP2FlTqIJ+cAdOECIFWAA55wK5NzTpR0aONQBE00OFpAP5MAQXKAMI/9AIAuFgjjcAOpAFDUCH8NZZBxAKVDg6fvAIUzAC5UVcZARvAcRphjQQZDCGYeSA+UAGWcCIlzgQjYAGcRAHi7RT+dAAQyCCdchUAXM1pnYHoCiKfthpKvaEIGR/IiiGBPaKx0YQg8AD1EiNAsGLqlhxmthgwtgHxIgr5VUE/zNGxFZcUeZujPWM0BgBjNiOaggTNsCILEAQT1gAVQAy3XgHwGAE68ZB7aZnAYAD9bcA6QVA1NQF6biKqzgQRSgDMcGLjEgQGEAGpuhDTKCCw/gBS1Be/mNxAkl76xVGPjR8wRdgAYaNodEAKgmRBBEBAYkDLiCQ/7dvPLORG+Q/4v+Yk0x1ADjWJCZwACZQA8qkTP3EYnNIELM4ECu5kkPQhMgWkJ1VBQGQLfuWQ0awBE91k953V85UYyMlMgIxAJ01AKQoQllwjUuZDw65i0vJkk6oc4E4ABdwTDRpThTgTIPkQwuGYpiACUAUfATZXimWBmyZlm25lBFJdPDWBR3EBbswQc5jBNJjl11ZY+CXfhYXYMLnXuEIQIW5kp+pkte4iL2omADUQZIQAqIzQz2TD3cpXMLFBA2mhcEnASlmknrVBfQUjop4mDaAlir5m5eYmNR0mgMwBjkQKxBwBgLxmrF5Y8lUSIAoXIw3ADgAbxSAT2KpiJ85mkzpnRjQi8X/GQCLZFFssjx+0HvOaWM8SQS79zFEwATyKZ98wAdDKTIbxJ1sWRDfuYsM+ZYucAM+QAIXxTfLs5Hr+WMfs2gPUICVJwE6gFxx5UUeI5ZnOZoC8Zv7mZQWKIYQioYT5CiQYgYkulHrWV4HwAUzuAW4WHmr9G5xQAMeE0ZdkKGiyZ8NYAMNwADgSXQRUHkuEAcM00Z8YwaL4JrOuUFMpQFAI35pl5UFEAelZEphuJ8P6Z8C4ZCz+FgC8QQUlQ/eZkxbhFnOyZF5qaR56QJVUJ3+05scipTCqRWrqIiAyAVwcB0FwWU/VmMfuJU+VAWo8EE4gANjmV7+mAn5gAACwaOn/wKRDZAFllcFndAGakYQHwCbwtWnfmpj/LOmiLiVXaADPIAGPEAQDMCoWsGoKmkIhpAFCOADYzAGCCWml4qpmloAfXlX82lKW8lBaOAIpaqohMIAwloQPNAGiMAofJMIzPoB5AebWslPAdRBeYmrAcCY3jdRPNAI1qgs+VCqA/GrgBAI+MGsTpAIzipSsMmRHGRx7oqtIuAIowCuBCGsxaoVaJCv1PirJUAHAlFVjICuDTajP6aV7jplAJRekjcK3+qtBIEG+eAIpOoI5JQPlSBfjBCwi9CGIlOwYuSuInSaHdQGDJsPpOqwJhuxEFtF+CEMFwuwfrCxIicyGuCx/v+Tc1IGb95XBV4AB5TQBqRKr97qCL4UBHyXD5PgBKXgL0TgCor3AHYAUus1o33qrgo7ANKABVjgBV5ACSbLA4NAENUYGhCbD3GQnEJAB7xSI/5SYw7Ggf7mL160lwUwqIY6AJYpCVrrBfngBXGQr2UrEN2qFYiaD5TQBAk4AW6QAi7yBm9ABWrzdHXSgRzoYEywYIOEqQfwBnv7AlyLBEjgtXowuhIltgVxlnrQCSRgZBOgIJvyuG8gXA52KRzYA7XrLyIzn7I5MmGkBS8ACVjwAlvrBS+ABH3Lt/kgC0/gF2eJBm2wBGPwA0KAJ6DiuCsgCRSQDyOHVHVyBFGbAgr/MnJ8cDtz+2NdEAJJ8ALqq7VYgARgULxcG7+y4AJ+UaqdAAetdieua70roEEa4G8PAL4p0CshUCXrdbmwCYKS4ADqK7zCiwVgkL7t6wXDmw/L+63duq9NgL8rQAgKQhn8+2XPdCmu+yK4+wD1KZ/rGkIh4AAOEMHBq7VJAAZgIBCgiwTIKwv5IAIZXKpjQAljEAWEQCVuoCCPuwL960waELXeC74nHAoAI58jM44JkAQr8MJI8MAv4MLqm8V9OxBdm8GN0AZlEwMEMMQ9QB4hfJdMFQIcaCd3MgnrRS58IDIoFgBckAQunAT5AAZIELwOIAUR3MB/zLdwYLzgSo2d/1A2EjHEROwGX7ACVIDEGvSaEaYpVBLHDkaU13q+V+wAfPy+WNDHgvy+6XvDcHDIcBAHAsHDZCyrweHIH4zEV6wFg/SaI/V0ThefFNAL/0NcBaAFLgzKLyDKEOwAK5AEM9zFN4wEPhuuJDACIyARiqAId3InKYDE37ECXDAAu1AVoLCnbPyae+AZhwBAAyDMUsDAL3DKWLAHapAB8qwGYXDKoLsMzgwHeqADFIVT+PEHiuDI3qsFK7DNSRAGNSDNUpABG0BIHRQGMXAFFeAA57wLahDPDJy+vxsNGRADJYACJeABDkDPkAC6YqDKlBAHbdAEiINT1UwHhDAJkxACWv8QyZKcAR5AmPmgAxWQAagwAIeACt+8Cr6kBMR0CA7gATGQAfSszC8QBrVAAjrQARsAAkqAAh5QA/QcBsWbz5Kgui3dBFc11pnCgUisBh6QBScABPlwAi0xDWEgBbWQ0FcgCiqgBBOtBiMAoRBQAy6cASqQASWAAyrACx0gARagBEogAkIQAwu9B86cxWIQBMnAUIgw1mP9vVqA0PmwAUCgBBuAhh5AAzCQBkUUAVQtEFlgBKpwAxswA4bgAygAR1JQA2kwB1ZgBZCqAiBgBS7gCTqQBhCQAe2rvmKACIjgAefgAYRQzYqAVcowwCGQASSAAwKRBlCgBGfpAmnQATP/kA9KkAon8N1KgAOFkAXh7dZKYAFQMNFpvQFzwAIncAISoAQY0AFWcAIuAAPRcMhjIAZjEASwYwB/UODPTQh/wAmcQAUOkA8zAAI+UAGHNANAcAJKcAK8oAIqYH9QIAFsPQNQAN4qsAGF7VVAQAM6sAFUbQUScAIgAAKfvQEusAbRkMVgIAViQAlwwHd/oAwFXuApoOAd7QInAAUlwJ0jrgIdIBD4DQUqkAozkN+d/d0qYAVRvt9AkANnqQIWIAqGoAJO3gERMAMiEAN7oL4rEANi0AmyEARCwAllwAk//saWMAIgsOFqTd9AoAJAQNhW0Nk4wNaeLehQQOJKQOGi/7AG1K0Eey4BEEDkjC4BIGDkGfACYiAG6IAIY9AGcOA6muAQmzDnKWAJORDoIS5wDp4PhB3a9scLyPbdHWDh4z0Ebu0DMWALrv3aGyACRJ4KVn4COnABYXDpYhADazAGcGDpK7AJmwDqssGBVCAFnhDrHVAIKMIwSqDaRXTqtFDXEoADEOoDj47X8VwC2a3WSw4ChuACIA4BDDwGiHDjUqDpKyDMNaEc+eALk8GBlgADgIAC2wADVZEBP3AFsX4FQgEBN+ABGZDUzFYCMBADDgBbK3DRUlABJCAAIjADSpAGX1VFDrAHQdAJQeDY867mVywQfj3XLgINxwEEDS/PVP+gBXtgC53dARCwBxugx0mACqhwAnsQBg4gz0Qfz2AQz/IMA44gAu4ez8GQBA2FCIAQBFKg5ogQBGLQ4PngANI89JYQAzcwAvK81A7wAyvwAtQtCjrgASeADwsQRACEChkQBOhUCHowAsHwwjR80A7wHcEQA1cfBICwDR4ACKOQDYCPOMsgBvmgCjFAv55wBmvgAzPgAgZQAi5wBQ5ACjGQBGow8TCQAR0QkAHZCwC0ByRwwW09A1ewzhmgzMocBhedBK8vBlSQBGKwAmCQ9bu/DCQfA/kQ1RtwAqmwAYaw5KIm2itgCzFwBpRABS+AxAw+zFSACqAwAoFO/Plg+T3/MwLrnAMO4Ng5UAMlMAIxsARLcP7RTALrDMpgQBEO4EsOzuJ3Tb+ysAG48ARPUAJTbnk7t/0Aka+QixIr8sVwoQIHDx1ZXOjYEEFPPhdpnqSpmA9Hmg0zsnSA4qJDPpIjHOSL4sCHig5ATmzY8ATIjEMkVcwgOWODknxA8inxuQHIkxgZbswAMvJjvhkdhELJZ4FlPihB8x2CekJFPgkqLNyQck3VCj1bgahQAWUayw04rCiRMDLCSJInrLD06SKGgzT5NvhY4nfDIRxArJC0mu+wlVQdcKg4ceIqkA03HABQFUPmVV4buh4+MeOEkpeOoczQaRWyqL2KoZa4IZnn/9Z8aRGzHMmzgwoJfrXOsPxDkxTFVIfe6DCjN9MNLnBEFvUECg6Q+XTgLOFgxOM5TSXgvKFnjsYNZyr8HO1iwwlR1NPMmJ7viQcqQgBo13OmBMEfJIxUmKiEfDwYwYcbCBwhBxIWXKOEClY4IYZ8JmqjBCMEXCOGEiAgyYMafMunAh988CCHEWCwsIISPNhjEQNIcmCvGFeAJoM1KhCiBhgqkMISB1bIIEgHMtjjBS9AAaWXADbI4IcfDKDlvB/UUCMDNT7MYAUXfKogiRViSOKFDF6gIoNgXuDjmERoISmfa2pYJQ9YBFGJpBdhhOaNL2CAgYYYuCgAkwIGGKAAUP8cWMKHJzoYyYcRMkgig8BG+NAFElYYI4ggACHHgwVJGIGEccR5pE2ShPOFDkE0UyGOEjbI5wwHfBwyAweG3IOKPX4MY4X3erLiiTigqiGDGvSAVQiKKrjVATHEWGHTfBxhxAgU6GFHAVN/UKUGGjIgoaYrVsrnChPTuGHBfNLNIZ8RbsgnBxgK6UCJrTYExIDzrnjCupyy8MGTG0w0KYl0HHHCiTaKIcZUlH6QYgUHPGFKPq4YzeKlQyR4STmP8ykhSw8SyudX+U4YCTIJcFjuJUMazeGFD5xYhARiHmnB4R+KzaclWF+qzaagt7JipJY6qADJHJ6w4rvDlCh6snz/stBoq5uc6qgEKvJh48JxAnE4nx9WyaCE3epy6i6fEYO1JRWC/VOSEWQxVYUI4urALh2e2ODsnvuWL4YVInH3jHwmCDsKTWwJ94QSfHjruZ63muMxvyRo+woqmqCCBFjTyFujlyKDglGn8okgKRcky46GSHZ0JZ+cEwcXhycMKAGHEG8oHda/SboighNc8OAFEpIgITkIKigEivUocuEGH3AICWQoeptLjxwymMAACOQoNWySVnEgB/rK316KKzrKB4KOKvgB3nUdkIQEMRx43IMMpHj3CR8qiMFeFJShGtwAVhJQwl8c8IN8BCIRbBAfSaKwClvUogZuyAMpYCCpbRk84Qcl6OBe4DWfDGgqCLcCEsRsFcAVysgB3xqBdBJ4Ah/EwHUc8MMFIhiFCQhHE5rgBCfKwIEMtIsEMcrHEdXQIGZJYQ1B8IABsiGFHwjBilJwgBOR4QEPWNEAHPiWB+TTL/rsQAD5CF8+AgIAIfkEAQMA/AAsAAAAAEQAeACHBAUAOEYvExcJ0JiIxIl06birLjco2KWSprjItHdqSlU3rWdS78S5ssXYxtnojilMWGZNTldLypR68NfSKCcYS0gwrShU8Onm8keH78nKKjUb8GeZUkhK7oitcXZtHCMUqllLt4Vz8VeQcGdqbXZOk1dKkEg07Za2UDgyrqirjomK9fTxrUV2bygzkDVQbVZV8TV856eycDZLuM7hvNHkzqiwbzgz9Hem9Cp24quZbUg2bUhMmKi5s1WGUSkslJaQqpaW0+TuaWhOq0cvb1dq0Le1rlMtsXNa9TuBKiwnj3Zy77XKyoqEbVYw0JmrlWVUxHlr0MfH76nDjHcqzDhteYRyxlmLiTgwjVZvkGlvrWppsGiMTTcXKBoSdilHjkhLkUZuqzZUqztpyWaVU2Q7qDot8+LaUjlFllM2rUVMtJulcGUxkZeo5LGblIMypmYWsZY0sbWxyEZw+2qiyylleIZXkHiIsCQssYgxxGtTiIZ1r4mPWGdoljhmikkV6XSZpSYcjnZRjpZqzVYtU0YZckpqd3gzllYVnrHCeYWSiIlSq1Yas3kow3NazHShlZZPnK7AqVds09TSUCUYlygaiWgtsneV2LnDNEIbThglcDYWp6KczXiN54iStU2BxCtZykYyzmUw0GhzeXeHk2uEmKOTuaU2x1VHz1Zz1IinyJgv0MW78tniTxUXchsvaVUckCgzkmYarGUuxjgtyHQZcEoXdWMdpqVsucW3wzlL+Rtv5pWXOkdAXVJjkh5EmKJyqh5NsnUdr4mjq6ZP0lYd1YQczKxQ3LCbcCwYm1aDhYygqR0lsy5i0UqAyLMz6kN85GYW5YgYHiwkLQoTOjhCWFEcdz1iuDkfp45FqJhPsJdzpLKQwCop204ezEtSzG+gyYtXw5hF1qBy89K9NVFUO213Qg8fXixIXEhhX3BEU3B2ZWyAgh4/oa/AsrBQpLJ+ucOTyWAYynoywI8oz5IezLZP2sI7ysBW4T9X4Fcb43kT4ZchAAAAAAAAAAAAAAAACP8APwgQAKCgwYIVquiBYGBSLH4QIXaBSKHLBwr8fET8kKQFrCGAQoa8c4cfyUHEQEGLZmLZHSr8bADgJ+fgwIM2I3jwEABjxIgD+VGgcFEoUY0Ry4wERInkrFwWBnWbxY/lsjBUqPgA0CqTTYIFK3ExyKGKhwgCNFCY+ZOCgA8Xh0L0gbFFxCuAlDIFxG8WqDJSZ0Hjd+1OGDFytuIEALYgF34FBUQwGwCAjlf84GJ8m5ljEoxXrvCz60PjlTJlKFEaCWoQqFDEiEWLR9KCHMiLcxsUwAFChApcDuEhSsFA3A+Zf/K7YoKSaBmurgxRvRr1INfQFg0qdm2ZBX6oJun/Hs84yUUuXGpRSJLEgHt+BiDqEE0fog3REEM7LzPkuutQiyxCDEn8hAGCYuSRt5EBxcHHTwXuvWBCRDbwg8Jcyy2HDCVDDHHKIKEMEcobJsxCUhj8nIJggrlRhBFc70VkQAU6VFCBfBkhtVwLLUhnxClGhGiEEWmYiCIscogHwFosGgTRRe4BB1+M8UWkQAT86JDjjTpMeIURQwwJQigL5DGIN2WUhJE3XQDQBSxNFgTRW8UFgoZFUEIUX5U2ZjkXBzTqUIIJQ3YIAiOMhAJKLmXkItQkuMXpZGfFCaGlex+4F2NEgd7og406vFBCCQuggQYIIMChijxDpAGCKCZ0/+GTQROxSFEEEARgwBqVNFEJPwoo8F6VEN3ITxNZasnPC0880YSpp+IBhyxpNJIHOHhwMREFKyYoowcLGdBELOJiFoCDUz4YURPG1siPEE3o0OUVJRzBCAh5WMsIPVNI1GacMkIgRARVxkfInntyCtFvylUA7wuComECqiA0AkUejATT76xNbpRpjBCoa4CwmiqnwAsVtHchRGvEq8MTR0S0AD8X49EEChqggFFujU1KaZ4VrFGLngj/FAAEJBBsAAoVKCCEEO9mgQUWPzGxgA5NlBDozrZ6jGlxFZCwBgkQKhcyRCQIAh/TaZNABglSF4JFFiU8EQk/ElRiYwU+af/U9ZMluxeyIIoIRWxEZPBDQh0KaDDj4kirQMQLRBCBxRNS89MIOOxWoAE/INiVoAA/fWyA4wbopIciIRMbH9KLM14yBBAokQVEK/Mjgwz8HOE7HgpUcCDp3i4I0bmCeyDILSTkavbbEJChAHsGkECCHkoQwcEZZ/A+KhYJHNFsJcGWQBRECmYmlwHnwocrP7cokrRyuJIAda4GJHEjCSNEcAY/ROAHE6DAhAEcIAYHCMETALWGJ8glIroBHHIOBwHlya8OeuIHlviBNCEgrz0RSAcJtvcCfhjwAANIYQ7a0IYCKIEDCnjCAiqQu0jh5EkP/AkJ+EG4OuywdRzUYBD/85cEDtqPAyUsYAqXmMI2MEAPEYAYGrjgE/QtZkEz8s373uWBtKnNAwoAVhg5pTQj+oYfBAhBCAjABAkYsA05KEAOlNA/BTRBA8iB4BUBp4EKnCUCevAARLr4i194QIsRwBLyiPi65kGEjUw0YA5ywIAi7GEEAvOcQJKzR/UxiIO42okgBam2hdAukVjigK7yhzbfcACNJ0whAQggAQkcoAAFkMAjAuE5AVSEY5F5Uh7fEwE+0G4EO9GDHvihAkHygQ+ofGWMoBcBDiyAACgMgRYSEL5RPSEEbThAIAKhCEO0zFg3FCYFFslBaI5gBEpQgTwhooJRjOKdxhRWREJG/7sSEiAiE1vAAkhFSwm0IRBNcINCGQEHfriBSXKKCEaIhasI9III74ynCoDADzWowA4eGIExI9A+IWowEAR4gqBMYAI0CNQENniZQfM2BVvE4qZ44EdDfYauiCSSAxitXBY4mgKP2uGodhBpIiNS0jUKtAT8mJgEEgDTLyTglhKAQ01j8YY3CMcNVhRKEw4HEQ5woBfvzEICgFCECUwgCkCwg+2yoAQ6YmmpEIGAU5VlgiMcgABHEOgAGMAAcbjBFraYQjAqIZeKsIUffZzRTwwA1MopYbATuABEJlBJJyiBciMI4FIT6YE1HmFUUCVADlBYQAaMo7BiCcAU8AA8if9AhlK7csON8ncGs/LjsgXIrHIuYIYMqCEL78SrBl+QBwIM4J+zJAAun2vAArRBAsgywBTggId+8aNWmdlVfNZAXvf4NgsDKAADMnsBzQ63BnTt3090cE1bohBvA1itQG15XUJUoAlTCDAhlPMgbDgDrIaYQudo9AQm3HK9bnWrGczQXohcYA8vkO9PSjDLFPJDoE89AghmKQFtNOEVtqhGNeb0wArgQRUQgYMb1mCjeJUgBLfEJWF3nIEIm2Gzk1Puu2bJzQWAACIlSAABElDfI5DXWBT5Lj/QIK0Yy/gVgXrBAtKLyy6rl7AZCLNw+VEDs74SIgogQQg+jKp/Nov/H2qcmQSeoC5+YEKiyKFFMeahKjjAYQ3+1dI3c9zlHRvarRW+wAup8S4O1iEETEYVkmf2hFGhEWrtu7Mw+VEMfqhCFX52A5abkDUT5pjHGTA0AzJA4RXw4wI1eEHqPFAHMtThFoEtgbIgooVK1ysEGIwPRjCh6bfo+dNaBfR/G2hLHYc51apetRlcDZEMKKG3EPBhtgMx0CyVIBJ3m2XM1iwEjlBA0y6iBSPwEA48uKEJhCAEqY8ggTiu2q3QJuyX1+tefpjBCa+swzAe0TwhGJlUR+YHVJmgRsWpDyNkIMO5iBIMRIXDGMaAt3+b4NcW3psBXtaxenvc7yKMgBel/4DHNjRocFK9dGICVGPzyGCcIkYvIhpoAh7WbYxhvAI9KGgCjltYgBqoAQh7gHN1Q77ezb4wDrj4AT+62CwZBnYBWoBzCAawwx22p6R6qkAl3OBnPNQCPcuy7wDWvGbblQC9OU6gEvixh7ZOYA/Ve8cqJLEKfvga4UamMzYV0UUichBqemoQNrRKCPTYwK9/hYgSPaz0Nhxj7QnYeg2KUIQyR2AbpcCFJDYxUHlB5AuhMnUUosAPDkQICEp4wtwTRgI8rAE9XNABNtcuwAHsgQnATyOOp9vhVTPgAAfIMNSjsIoBfHhCfvJ7CGw5gVcXwQOvbLiMIqKI2z/mCcj/6/8/3367iISAkgwYQAIgwuUCJN8DuODHBArg/IHiR1C9PwB7iwsEqCpBYIOSVyTwCFPABSigAziWTbjDD0W0AyUwYsE1AQfQbS+QBcMnBCrAD0HAD0VQfyDAUibwgPh1AAygWWYwARnQgdqgBwlwCqBQAUhTB79QgH6HfM4HVRDxAkhENwLEABRWADJyBvQ1RyqwgRDxV7k2KiAgZwZUgq+GgiCXAwOUB6cAgyRwC4JQgDcSfry3fspRXZolgRAxd9IHBEX4ExwFYgJ1BNM3ADUgCZp1AVAoR1NYhUijCARIIwlIdDUwAEzwE+m1au41Ac6XfwVQBBq4gQ1gfiAGEQn/wARFwHoW5lZR+FyNUIVvQwJ4GCq2FEdfhksodGpNBxEn+FfplVlvFQRGGBE8QHd7AASwCBE0YIQnmGpy9FwXY0R1IAiP0AQv0Ik6Fm0gFwMFkAEVdoLtNQEURlzVR2D8gAjKAY0a+GrMWIkEoAUzE4O82ARP0ImeiGog1373xlnK2F7MOAGqmI6r6IyqSI3JCHIH8IcQ8Ta7+AtCEAjeuG87FgMGlGqrhUso6ETKeILImI7O+BMOoIpxeAErYAYg534DAAVWuDiCQAJKYF+UFHL8uHsC5VwpdHy31GMRNo0HSWDtWGHzVwAxUAP8mFcC8zQXKUm4NEmT9FxLtgCl/8FhqfVXD/ZsksAPi1iSyqGKrnYBGaCSOeCHMXAjAmM/QqAEW3dC4YdCHSYBs/RhWpdfTbRvkkhgNHCQCimHR8mPfzgAFUAGQkA7MDl9bhRJHUZox4B8xEhYOeBGRMcAcSCU7BgEyXiUEMkPonB4tGM9UFlLA1BL0cV+IQeQc1hLB+CJQvmVJukAfQmKAxAJCccPiRMBQqBGtWSVswQFWBmIDwlhlNgG0PWYiKiXEDEDERGWKGiZVBMfxgIBeuCZoEkAUAAFApUABoSLBLREMQByErAAUJBfq+mVP7GOr8aXsVkAsAgBZeOSioCb0bWbRrYAkeYqr2KcedBcfyVnB/+QnELJnBfgnKlWA/wABCPgeohDOxeJmNFFAAMFUyZwTci3CkVwfARwZIB1nDnQlawpixrYl31nhmdTLBGnACgln9F1BGgwCT5gA1mwBzWQAlHQVqnGUTHjXEDID645oD+RjBPAeTWwBwmKOGQQCGyZm88lUDsQow6YZAugREn3lh8qosMllqvpBEllZyqqZgUVXYc5SyEABZwAfJzACcEJfEukmqzpACE6lMyIiH3ID1vgjEJKS9H1mbKUAEjKCZ2wC2TaCfkVfjnQdxCBCAgQEVN6kIvYjhlaA0ywBXYAEeimOPNJpG7JZKggCqKwmw42lW0goBGBAG0aEV8ZlPz/kKgQIQmSwHpAMDVVdJZvs6cd9qQoFGmo0gjYNJXIxw+JsKZCyaiNKo0ENgoBFB8KYAiuqmZoNJ9MZIM2yU3OdUtxGX4fFRGQoKO8qhyJwAcHww+u+qoQsUZ8KpWgGn5dFk4HsAmJMArPCKdAqaOJMAJvABEB5gaGQAKB1aHJKpfEyHQziUI/MAoZ6KsEpgyjKqohpW4BNgUKZQiB8GECFate+pg5MK7BCIoHIAF2MAqJwAbqChFtygPsOkiuRwsVF68KVa8DtYRHYKu0dEL76mXwiHxMMAZbYAl3epCIAI2oeqj8EAcJqwZEkD+0IAtTUAmocgTZEAKBJTEuNzNE//qY4zquq5VCnGAFVjAGY2AJ6TqyIipPSZc/XoUGrYIqVgliLIVwIDCxSpZCyDdJNgiakeCzY+AJY5B0P4GqRPsTqyBPlnA7Q1EGJiAdabC2eHN1pqKELAViUJCpsjSfaaC1LAC0PdCxwqAGfqsG1QoRvfoTrKcGpDAC30UBHTIEqJIGYZAGs6SG9TkELMW4ErubV4m5zscCLGAFnQu0LNADXPsNjuAIqeAEBuuoECGJcoUFPpAEYNIha5sG/BAJEhACpFJkLWUElcu4ZbIA4EpLBQACYsC5neuzPdAHoQu0jjAGnJAK6pmorfgTKkAKWcoPhdIqbMt+IQACRUa5aP9gBCAAJuIrUHMbXSQIAg9gvJ7rs8rbuT0wBj87Bo6AumHLDz+QBde7CB2CGts7YmsHvB9IueUrUPliMfOpXgvgAl7gAmLQvlYgBn3QB57gCT1wwfRrusLgjCqABZaABV2wCGCCGq2CIhDhRv1JKJW7hAbcCBaDwJApBvzwAH3QA8fLAg+wvqFbwfRLukELEe0QEXYwN7wjwkNAwo8LEbaLwh/IUkNiBCCWL3mwZQ8JhGLgAg8gBskbv57QB17QB8XLuT3ws46wBVuwwT9BCnNTRE98xKhRIBFxmFYpYkr7xEYgCyAmXSDHQiDQBzkculrsCJ7rAhPMAsV7wXu7BT3/YAleCxFDjAUYESDZWwYR8QAmJMdWKbNXB7xHAAUSsAvqBYoz/AAuELqh6wic0ANgAAaG/L6IfMF8GxEj8AIvgByHcAh2DH2AKApZgQoF9ZmISQW28QfTNcpggMhbwAnNK8wWYAF0QAVifMHJYMZboAZFkFShVSWHIMJDggbKIQZU4AW03AIWsAGaOgBUwDsc8ADELAp0QAdhAAaKvLfyawEy4AHNtM7PHLqqrMgduwd2kAWVE1q3/AaLIAuy8IH4EQYWwAF5yYERYAFm+gedwMuuABFL8Ep/8ADbYwFUYAXNYAVb0Ay+MAJF0AEbwA9LoAKv9MxywM9mHAmHO9BZ/9BVNi0LEgN9dMABhgoR4ewLywIRMLAEEfAAdPACKRgyOWwBMGABHiAFMKALHTABSLAES5ARXuAFtrG3NgwGRNALF1UINm3TOc0PMMEPKb0EKQ0EHGAXeVkKGdABIoAE/BAFEJAJaH0DkmCGm+ABXlCyc4AESBAFlwAD/IAENaACKZACEW0FNswCYFAIhcAB6MABi3DLh+BVftBSIGABIxADdB0HUrAEUbCScdABNxADS8AKG3ADrLAEMbAJUbDaGK3SRc3TfzAHEZEBS3ABJ0DX6tkMjw0GWBBAZ0Asmb0I/KAJmhAGlnwD6xkBEyAJ0K3S/KALMAADGcAPUrDd/P9wA1Kg0jAgAlHdehBRBBvQAX+ABNvdATHA3SJQA2cgBzbMwPK8Baw0NHfB3PasnlLgAasJAxsAAx0AER2ABFDNCjdA13nNDziABAuunqvLD4bND5KA4DBwAxMA3TLw0jhsDWBACqlABEmgCVygCRBRCyAY1Owtidtt2DEAA3S9Ae+N1hAxBzQ+4EtQ3Wfg2Vet3RCgnledAU7w3+u7ytYgN3awBbfTChMBKRDBUq333uGt2xAB3TGe0tst1RkA3QV+1TfgXkAgA8CA1q2d0upJ1QV+CRVABasMBjJwBliwBZDND5MwCV0gAJPAHCwVBl5QCgXeAZuQESFz1XUNEVL/oNu8UG0xkIJAAAFFQNR04NSjzXodEIYxMAdGzgJYUAhe7AVyAxEPsCRQjgynwVJ0wA8joAJ8YNbCrBEFnhFBxAEWwNG9gbgy8AC95epeoBMlewNLEAdmdRYyQAVEQApEIANeIAOFIANgMMNy8gDsEBNDABUQUevNjCJyYAEqkN4QQAUbIAZZ3AmdQBNU8ADN3MxGzQKRQAWT/h2jCgFG3cxigFGFwAdEsOyRjQVgMOoA8AC0jO66owIv0MwyUOsawQIWADVFcCGvxa8F0AkW8AIZqAKboAY7AM2RILoscO68wwzMXjl8oA4cwAejcA7MXtzJAAYAkAkyoJ6loAdn/wAEN1ADBgDgMwwLMiAGdKDr/GABHaCSKrkLxCgHI4C6EQHdLfAAzPDSxevudCAGFiAGYHAYz668NAwGyYDsMgAAJZ3SrC0JBa4CSaCeQHAhwCADemAJtgERzp3DDxAGnYAKL1DjrEBmBgA1L5DDua7sg/QCMlBXgT/LI+AFOSzBW2HJV67dQ62eqbABuOAEaiBIrd15NWCGib0JNSBIulMDMPDekbh5GzABgFsDceAEcWD6/BADcdDaUdABUlADsb4so94FDwAEBA4RG7ABqHsDfyDUYf7dG2Doc2DoKe0EO/AdXl7XHTAHN4DS3M0PIoADBR7eaD0Hf2D9Mp4BFf/uBdOA12pQ4dkd3gRO41Ud1/KXCj+BBLlPZrmOiBsAe2b+B+/N4Ied0od92Kzg3hWO/TY+6gCRSYYTfvw26NqQAQaSgjf4LTHYIYaUGzc2FLwIo6CMB/yQSFHhoeBDfhpLShkJo0OHORA7IMlgsKTDBz4yefHIDyXBDjdi8rNYI8ZIJ1JiSORXxKGHBy9i4Nhwo0OGG3P4qbF6YoOeCCSX1LjI72icG0bnOOEQJgmApmpC1vDgY4SQCG49qODwAgi/vC/4jQB8xkNXfjJUuFXiQcjdMzIGq+CLkZ+KCECAcODnV3EEDxzkBDIAgN8DjqT54bOAIkKSghFwPnhgQXb/bDksrMhB1enYGAs+fBjg1dUHHToW6PCTZoFfjYIclMsQw+KBGNnMWOQxZogXAO7T+LmCFWrQg70qDBRU8SBXmCsjbZQ4EJ/JgAOoHigB4mTl1RcWwlgQyS8VahiBHyyIIIIPcs4YgY8RdhihHmce4Yc77nxoBZk3BhkIhj08uEiPjmCbjbYw5ICNCn7i+KMgJJzYAyV+lFNjAxVYqyEC2B4AAwx+EiwnETeE0MMZdyq0sIVM+NHEghFa5AcIkzKL468C/5rMr5E26WAJGObwAAI+DIgAMoKKgOyGKIAoha8XXphuHSGnsGOYYZDkrgsfWoCtTYcIymClKAz6I6YN/wr1qSoPlOOgBo3IKoinkvjJIIafDJKkgyj5YYGEKQIZ4ZZHPrBQNB9mVEHTsDIqSCOGXNU01ghw48cJmG5gaAkkOrgAykFj0AgGqTaIyoMw+FljsXsIwfNCVwDsYMoONkBCJZkk03QhJ2TgJ5IXUkHigoJwmCBQTZEowokNoi1oWk235QcTfiLQgx8KmgWgi0yAeZIfD4BAYomh+GF3DmANyuAiTcPIIo0RLopDU7GulWKlaeeYgGDmwOxI3giy4YfUUvN08gQnDPAgBsp0mrbdiyDLuAYOWBhBjBF6giCCTaQIq4YaVACiBil+TjmmCTpQY0YKDIAAjkdGLtWVjqTS6kgGC1owyCEIoorg1JEewEIILB7417mmar1MBi86GqGxgkSgdIkNgKiJH0IMWQNqC7twBRhf+CnDAlhmVOIGJ1DwwHCO+DnLOSJGIAI2L3rjkzSrLd+xBQteKEruKLnVgB9FKtCbny4oyKQV1TXRhIsZJxuBNBVip0MwHb04oxAODPDBCx+SkCaJtXGnhgMOkkjivBk5UMEJJ/AKg4vQKeQuIAAh+QQBBADmACwAAAAARAB4AIcFBwE3RjLPmIfFiXTYppIuNyvpuaqmuMlOVkkSFgm0eGpKVTitZ1JYZkyOKUyyxtjvxbnF2Ojvysnw2NFMSDNvdmyNiYvJlHquJ1WVV0pvaWvv6efwZ5m2hXPzR4dOODORSDMqJxlTSElsdlCUlY7uiK0pLCZtV1PxV5GpRi6uqKpsaE2QNVCtRnXulrb19PFvODFxNkqql5ccIxanWUq4zuHNqK/yNXzzd6XnprK80eQuGxRtJzXStrP0KnbjrJp5g3KHh3ONaG+Yp7lvR0vS4+1tRjaNd3OsRExxV2itOWr1O4GrVDGxVYbvtcpSKC2QZlSzc1zQmKx4KEaytrHwqcOMlW3EeWvQyMiKOi5rVy6sio/MN27EWYvz4tpUOUSpN1SWOGeOSEnLiYUvNhuQl6iwm6SRdyyPdlSnOC2ReIV5hleVUjaNV3LLKWXIZpZTZDqNiFKra2f7aqHlsZxxZzCNR3LIRnKesMJZaGSmpZewaI/Lx7tIOBlwSGnHpWXodZiPaymvmFivmG02Qht6dzORJzWTllnEcVjWusLT1NJ3GTOcrsCYopKtV2anajOyeJW6xLTCbFPMc6HoiJPy2eJzVxl6hpSOJhqMRxmVhTGYpHS2TYGshzqxpWrUVnbOaXBMGBtMFiNSJRt2fIqteCvasZt2NRmqVBvUh6fFmEpdVWV3JxqMNxuVZoOoHk+rKifFKVnmlJc8OEA+TEFRSBuOVxqIZh6viaSqsnDMd4rHtWx4RheGHTWlJB23chqrpVylspPNNlTNVjLOaTf5GW4/UDtXUBuDjaG4K2GliUyzsFzIQzLOSYTEax3Mb6DHpFLsRH4dLCI/HyM/VEFfL05bTGB7Yx10aYCVH0ifVYGeky6vPB+7YByiky69qTe5wpLBQlbEchrEfz3Fjjz10rwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/wABCBwoMIHBBANnhLgV4mCChg8bmphhIsQMhQV48ACBiRWmj758wUpjiFkaWEx+wVjEgwWYJwBEsSBIEyEAmzYBQExw0eDFixYnhghh4oNRjVlY8chiyKOvNCRTnOTmzMiiKS5h7thBk6CWPje7DvU5g+fQixULFKDwoajRJ0+ywACRJSmmkVJT5O2WZZEDlyG6is1ZECEFLSYKVOQpdIbaAiJgGIFh9G0WECBgaMaURm8KJqhSOEPVyy+LGIJTE9ZZQEunALALYAwg+4NkIkaMZDZCJMaTuXI1Z/nM5LMtVL9a+XXQgmvq5wNDkPmgJQAC2mqxr9U82YhRGES+PP+JoRnGZRA0mBRnAiITKkOmxYyCDt1nYsgFYutHMJktkRNsVTZZeSBkkB57TLBhBEm9sPAEEjDRV5NDjj1mIWy0UbAABRRYhwBbT7AFHmVGsEEDDWywxwYbIJDEgkZIBAaAcxIedJYJAWx4X37YwbYAAkBSUMAHIVKQW24sspFBBo8oyQQNYBiSRQg8QBiACFOkZgJODhVgUQFoaGERRTwWQAaPxvyIwFsicKjFCScEEggIYmRwRiCPpICES2KE8AQPImigwQeqyehQAhUltgKHaoVwIY85fkjBFx90KAKcUKBRh5IZaOJNKQVmwAARQ4XwAZAm0KjaQWSqtYIWWtT/sUAAZ+YHJGwI/LjACR8YISQFJ4zw6ptLorHNIzREwUAUnVAwlAkwNFQjT62qdVhrsz5m3QL5zZrjhkZxiMCrC8BqxAlonJFBFMo+UkodCm0lYUE/JbZjAIkJ2SOkC8y64ZCVUbDCrgussMIJS66rAAPuwlvADgbVCJQJ9mbXALg5Xuhtvw1QkK9RKwQBRK4jBKGGAnJAocDCnWjx6071UbSjhRSMqyGG2HkLWwMjIKDWByJUoIceJARxhBBCqIG0AlugYYQWGRhpBMzPJXAhhtkhMEIdI3AbQIc5XtzvCFZ4jQAJkUSiggoWJOG2ECdA0YYQHSzKqG1PHPScYzjj/9xhyFZY4fO3Pi4AR8FreA0EFZEEQ4UMbkeOdBsrR+Eyt0RkwIPegj3Ut5pAag1E4F1bpx/PI6yRuAln8xEJCRYcIYIIX8zeWwxCZMoAGh1n8AHEEXdlEI6wUdDA8Q0gkHwFQGziibD9gh1AA3CMcPwCrJPABx8yVJAE7V8Q8Z/cQqABxfn9ZmCRQxM66iHy8DNvhSdWxHEx4QvwPHAD+BYQBBV6OAICapeEI2xBAQMQgAByQIC6fagOUCADRCBGEJ+sRXnWa8AKkDeC0W3CCmsIwv10NT1hxUYtDRDZAE+gAAEQgAACGIMLf/ADOsgOAVCI2pbYdxO0FEB5yGNeBf+GSDYS6MEKhwjhCnx0nVxdTDE40t+lWqhABcpQgT8wQBCScIIS9WEnwWNMfo6XhyECoWhAsMAQg0CC5n0QCBcb4axqphbDWQ8BCOxABwYwhgu4kA40JMARNJCrBZChLDycDQLywEgzwi4IKiBBI0hQtKEBoQLIu84J75M/64kAgVes4guzaIMtaECDFJCgQSAiEDJZp4xD1EAFLBAEC1DyliSQgQxIMMQ8HK+J2MHRAqy3ABHIIYEvjOEABnCBCxCgBz0YRByWSIYEbIWVAEjM15RnxiFWgI22xCUJzAA7NZ4ySLTBUPWSJwJzDACGHZBD5ZYEhQ68EAorKISsfEX/BgoCgEdAaoAZL/nNctpSl7o0QyQtYAFB+dJrHspfA1g4AAUQYS40MAcNMmCODjSTAFAwQiHOcItbaEIThZBWfmqGAFkyDwgiY6MVGMpQGZhBoWszgwXUoAFf0gJSubIOGgYQ0gxgBgTmMMduoHCBHwwiVpaIqi3O8A1NIARX4/ImTIMQhMDVcgsM3YIKoKkCsKpBDYPMAwJo4SOwLWCPSc2AGGBAgwsoIDNEaKEBLtCJQPDCErawhSXOUAeDRKoBR6iALLcKhDTW1KY9kMAENoCFsipNCIlFgAg8FIA0NWCPNPAOEUDAAAIMIApJFQAEIHCBM0T1GoEQU0O2wtKs/760sYqlqQVkENkNvCCpE5BAD2xwhBMkgZDbUtMR9siAhB3zB1ZULQT2Gog+BCAQd6KAQXbwAQ8pTwNBGARuZbnT3UZ2sklN7wbMIQEZCEFQt4INNU4giQRWdJkDMIABBIBMA9DhAlqYzhk6QdiL7CALIgASeNcYOMUOUQ0ysAEEJuAF3/42vUn1AnEHqckcacGdzoShAvz4AwKklgD/rUUftHCGO9UCkTuomQYG8YdBVMCrMIXpFmxgAMl6YQJA9oI5NkDkpG5gCydALs4ysEwFKgDDGVBAspj51FpY4hjHIAQZptOQAKyAxn/4gyc8EYfGcnULBOixZIEsgTYDGf/I6Z0AF4GksxUsc2Ua1UyUT0sDj0ahDi7bMiFqUbItQUEQ0AjzmAWBBiFwNQi8hUCbJ93m1U4aveawwew2269hduDJJ7qCAs6ngE+bA4FQ4JCWCcFqDjVkHKpQRZj/AAxlrABpy00zpXe9WklPdr0bkN0sAjACODRgDaY+kRzkkAEoMHtJCKwDrQStZQkOhRyqSLSYD2E+zHZAAD1QM6WD22tfr3fINjjBDyuwBjiswROozQBvxEDvNiQsCh1InJlCEABCTHsopYj1HwQRh2mu4Ai5NoCv31zpck8YwxJQQ+2OXew1QMEcGdCzIxwhz9OWeg0roEgICNEvWgG8E6r/uIAgBoEGg93angr3MZt7rfDVYjqpUtjsGoBxCOutQKMcpQG9ozwGPVphBAFQCL+NvYA+fLEUnVDGH3axi5YbDA2DMIXCGT5d/ep3tVs/tzl6oIEANAIcwWjEuDDOUaWiRwFF74D14OClAhRsgxRweh06oQlB7GIZwjrBrQWg9dUOVwAH/PYzvc7jh5tjArJjHCUrMIIcXhy15pCnHgXQNaQnptMA4tAw4yAIQRwC0OeCQpoNAE89Hi0DQnChfhu4si30AMhb+MAIcsEHc/CBBDlckkY1qjJ7xmEEI1DMWnjW6Q7l7xAE10JuWEgAUwhgZS6E4fVLLQADWF8Am7cB/zQ1jYC0R8IcejCHGHJDBHr/p4UEwMLvRaCWE8ggCGhQwIZYOoI41EFqJ5B9n6ZAW6BAfKRHq6dAftRjEPBCScY48nd9NJAZt0EE9eRMEzBkZCcCRLBHChAFA+Nd/tcHlaJ6LzQGFdVsQrAyKzMAP7BapoV9XkcASXZ+E7BfT5YBwWEEUeZHBCABRdZeURYEwgIFIIBBI3B6JGgE9gRPCkAZbfEBmUMD+QVkJiZXJ0A3aXYCFmAORRABPXB9GnVUBjJiLgQB5xZcPUAAg9ABUSAJw5A/qrMJZ0CCUOBC15dxknEClyIEGSAHYwABQ2YACiAGH1AAX2AE5iBIl1AERf9gDg9gWvG2JBllhgSAhkNGbgYAXQOACMQgh4NgBYVQKQrwQk7IgqgoAFm0XhNAACtzBCiTAR0gAxbwhZB4ADLwZBjGAB7lQkOWiRIwXZzoiZ0UB6JYKU1IB/plAzGEMvLUfZKWhgIgTzKUZj2gAo4YAQ9wAOagAh2QXiwIblgQAcAGZMLIX55oPMhXcOfiTMpYc7MnezWXgXFmWt03WROABdkIids4BGWwBVuAUCrAjY8IXMHoXwQwBuYgCZ20Bkj0Js6URTXncNOVAz1WZI9HZBlYZPRoDjXwACB5AHgwBCRJknjwABHwiBw5XXRAAHYVBXK4BptwCHETkRLZa5X/tl9eZ3MT8HBEJmRA5ohC+YUheQBGeQAP4IUqSWQb0JObyF9X0JBWsAkrgAYhlkUOZwA54ELBWGL6FVx04HgZ+GsbYIseyY8giZJCCWznBnYwZA6dlDpWgAZH4IMS6XVayV8KlFQJpEANeIlrBmQpiZYYll4RcJgpuZSP13UEUGLGo0HCcnB+NEM5QEM0xF8VZQ5wwWSa806yJ2ltdosgaQ4RUJiIiZiOyJQH2ZKqCETIZzDLpUCmaIqYiZmmVmrfBl0CoIy9hgVIeZqlaZjAmZpNeZDQBXcYdDyw6VGTWUW1uXqmYAovZJGrBV0o9nVUgJLASZrAiZpFoJHGKQBC/yAHkIl8yLdczSQAzYRf2GeReGkAM/cDHyWRB9Cd3MmdwVmaqfljEmAAayiebfAtcbQCerSe+HVqpwaNXTdhbwYBdFBREdkD2nmawnmYkKif31mcw0UA7kUEthJQQVCgF3Cg4IiHA8CXVZQD03Wi5qCKPZBUFFqhj4iSavmd5tgDu9QAm0VnxxMHIkqi5sAACEoDSHAioCAJCwkK73SiUeBMLwqjwSmjFwqSZdmUwRVJMqABnBZQx1OXBnqgRjUX7vRCfNADDTgANIBAqKWKWGCY/CicpAmJSfUAGRpcfKACOsU/PMIxcDBUzTSi+BUFGQAXMCAEO2YDWHB7qyUDRv/Qgt03mhGgA6MJp9r4mygJnuO3BXnwNcVjOH3KnCN6BfaVVOIjPtAWBeBGAFtwTP0FkoeZlqaJkuZglBeKqTk1SGCjIXBQPXv0peq5TN+oC2MwrAo5BjkwrKL0AxL6qpNqmDoQp0aZlt/5eHfKjEizUp7Kq8tkoOo5mQNwBeYgrJQgC+RKCapoij/Qe0aJB0iZXrCaXkdplImpCIlaSkLgCgVACBrSaUOFX9vqnAb4ZKBwBaCQVGMwmyiWCP44BNG6jUiZljVwi/GqneYgf1SwBW2QBGSQIzmyqyPgr/jlnNoHaieCCO+EsARQBpfAsOwar9GKlvF6kiCJBRZbBtj/kATdAgeFsLMj8GkgK7LaNwCfhkCy15KmuFNDYA5Je5RpmZRp6bLtapR8QAUqmwfO12I8+2l7FLKyibKm6J4ISQB6cAmkMAQt+7BoC6tQ+wBlUAZDoAJDgAykkAe3sAB10GKacAYj8GRRgEBcm305ALY7qV8lJgAkQAoWwLBM67ATO6uzSqtsiwwW4LZzuwpy0mJncFKFkH9J1bf4lZ6N+QOCC3as55JqQAqI67ZQ67KMa5SMwLYWcAlloAKENAu/UAqPgLkFx7kGYg5967c+2JjvKYwwNAZvsAeQoAZuq7guy64n2bwPwDayawZJABvi8AiPEAhIgARRIAgdIKRG/5VRSeW3yCS6+uWehSsAutAFXfAGbwAJsmu28VqSSAm9B1AGYUUEtIEKK6In27tM6YUZQZcsjpp9gQRDgOoI7PsGnPAGW9C2ZbCuSiu/rRutWAA7SvMFFJMGdAEG2wsGcnABmMciBTKBSDW+TVZFIIsEC9wC7tsETQAJuHBTN6UC29iPE4sF+DtIIrDBUrG9QAzASbUimJECRXwivsuXmelOAiAGLdACXQDF7tsCTdDA5jAJk5AKUlC/Z4uUWOCPZ5UEFOMZ/osE5uAIF9ABHGVUmJEgRZwCGYWknrutBkADSvDEUMy+TRAGVOy+k/AGupAKNiDBFOyPOyUELCAGnv+RBkC8vS2kxhsFAkZsIjSgF0+SXv56iRmFx1HMvnwMxU3wBu37BpMgBSowkiRplIaMNKfhGcMBxGecQB2gJGR8yUklCYiACO5Ex4JoDlNgDkrQyV2gBGEQBpzACTAcylicCrgAt4pLkhbQBmrgBzvgyoy8vePrR2oMAm4Mx+mFy7qcy1ewegqgBA5gDmHQBHncAkn1xOrcwJNwxe9LkoxwACSpBkkgBF9QzXqRBddsxrHsR2h6VOrBBI+QVAyACEhail4nB2Fwzkqwx00QxQ4wBWFwx+6szHuwB7jwtlRwz3OTKmScBmBQ0mAwvt1aURP4GcQhpHy5enRABzTAAu3/zAl83AU2bdGfnMxNsNE9LVZUQAUqoDRinACZQMawgAEYJgZVBKifhnm+27cXIAtZpIwEIAZJ5QB3fNNd8NAsoAQYTcU8jby4ENRm8F4nkCqZ0ArEgQQn7cvnLAcCAApcwAWfwEx/+qcDcAcYcAeAoF9NDNdPfMfsewdugAGIbQ5ccMfJ3AY9vQdmQAUNJSjOwhmWzARiwAIVnVRKwAVTACc8oNSiBENcEANA0E5/DQqxYA4YwBwX3QKc0AwYEAMaoEbtpNgtoA1N0AZ70NOQIANKIygakAS1rCSZnVRggAEiQAU54AJUgAAYYK6AQAmfwAWLQAIuYA4i4AGAoN1f/4ABbtACYN0CXOAAGvCkJWAOFiACPKDYd9ACrvDYyPtegiIEBW3ECZIFNJ1UIsAHKGAOS4ACKsAD0VDe2cADJwAEiXAD5oAASXUCwtUA7c3aN4ABFVAFN1AMj+cBSaUCTzAFU9DXPa3ObTDcq+A2Bc0EmXBU9MYFPKAC/51UHiAD7P0BVCBJGfjfLoAFDSAKJGAOOGAOtKgHFTAFPEAFc5BUWJAIPpDdNmABawPdzaDOLWAHbrMKq2ANerHiKZAJvGAEYoAEGKAB2e3cVVCxOWADVADkOZBeQW4OOaAHbWoOKJDdHO7gIoAFHMABdI4CEjBk2Y0CPfAFd9AEdnDoGf/rB7Sz1q2w4iBwCqMwCietAjjgAjKAABkY5P+NAsVwAzcgAR5QBX/uAThQBRx+AyhwA03eTjDwpHwuAXXe5lWAAjbwBVzQBnYQBjFgB67gCrNgArzQCllwCpihGaEdAzaAAlVQAT3gAS7A4AzuARxuDhgO5HTO4ZWeVEFuAx+g3VjgATfgAYmQVBiOAxOAAyoQA1xgBy0QAzHgB0IACWI8CqxwCnUxF3QRCyeQ3RKABSjg5+bA4DkQ7XBuDtmdVEne5gwe5Inw3RoQ8J/eAMmeVBIgBVUABOZQ5XbgB35wXK7wPVuxA0txVCAQCyIg6x4wB5HkAjjgAQNvDh4gAS7/oOES0PJ0Tuc4sAEoMOMx8Ao/bu0qkOyVkFQokAgUsO7FHANf4AdtEAa9EQKjsBVLIRUgIAxT0Agu8N96QCQNoAIG7wEXTAJVoPIBoOASkAPCJQMN8KIObuFVUAX+DugTkANzsOzAjOssMAXV4Ad2YA4xkCVQL/X+LMnm8AG1nQcfUNcY8AQYjwJA8CcNQAIioNSz0wCDEgPmUDuK7dkIUAEBQOnmQAWzUwEIMAVckARt0AZ/PwV+EAO9kSUJENoOwAOGkALCAN6szdoYAAZicAev0IXmkAdcAMzATAmUgAJ3MPyIndisHQaHjdgfcAkq0ABJhdhKcFwdnwQgvvF8/z8FBmEOcMLasRADJHACiB0DSt3eLTDmidADFIAC5QABgksJGHAClGQBemAGJ5AMDlDMFz38AAHDXLIYdpJoOLhKg4YpU+zY8WOHBQAeMWy4aBTkiwwcNgpU6AHEnKEYSsyZ+/IBgzkDOVrKcnlHgxQPHlygwAGEhzkMSnwq4cLFnJKeLcAoaWEujJJXSsK0aOMnBgAHGsyhOHnSgwUTNjzI+BDjVYwgkMDcObkyKxhKn07kuGrOg8cVKqyaI2IuxhQiPCqciHHkSGANJxieVBJjGgBzJGziuCHhhjkbKlKZiyRFSgUV5nD0sGFDhgUbFvTYqCDX4o0cQ3pgsdHD3P8EMypsUJFC5baLHFQ8YzFXxYY5FcVPYACww5yMyXHNSfEMyIWLGzg2eMCh1dycky5OSiGCgUR2cy6AzyEf3ANWuVXKbwdUZf1kyShIOAglypyZGx7M3bihiiWag8scCeSaIBUXasKqubliMIcK/2Q4ojNzACnQhWjkksuDG7w7KYcbUEBhDkBOIsGc/GKAzj8fDJzsJhywYi+HKnAgzz/qUEgEws6qsKACElDQsT/qqpjuv5O4A1EC/1CoLsUnRHGgMxfckyJFHJx0ITsbciAxESmqgCsHF3rAwYXU3jopuwlwmIMEM+bgzRwgEOgMq+F4hIsKHMicQwoRwDCBsRP/zAgStSc0WAEBRCuwQIQTZJBB0hMMW+iLChC4KgYLED2ighUg/SKGTS1QQQQe8rQAAUpFIOKED0RFoAIR7mBgFgD0i4EFvcwRBoMPEDCBh2GncMMcFjBglqc7Wvjkjk8oIYADDJ54ogBaEAjgibTM4UGalYZzAYGVYmihBSXu8ImLFkC5YAQEAAAggR146CWNYYZZzgULClDBX3O4CCeLD2BAmAYCFhZAAAI+MecIGaArT4bjiOLsBB5IswqqNkipQIMgLNjiCDV2ycWKeekF4IlFskCFGRZv2CI1D4IwJ5a01MLgjrNOEspP/57bogoVeMCABzPM4co2ThFLVwgL/8qQQZAKTcllBJZb5oGHUzDQABAPgGCuBCBipYKEhVRQmwgLTiBBBSI+0APGOSpoII8CELAACJp6sKBLLGRohARLzWnBAhIEGVmPTbRm+d6dzGkEOxVoOtAcLLACRAKstgT97pVEsOFDP6W4HKsdJciBS/YqJuKTQRg/wgorFth6FB4cwMCCrG4qz8j+gh96aHMQkJYI6CTIzvgNTjTPAxE9TA+HCsCIIw7BclkhgMglxyC1G4p7vTm5QBx6MiliAMWREy67zr8JMseqB4o/NN6D9ZEYYQSRl1kALehlrx2EAmlhQ0EFZBAiIv3HA3OYnoE4BAQwKKAFCPQNkcB0Ff8UuCcrc5jASWxQogpgIAMrWIEGrAAMBBRggDuA4SLA5gIpfCQHrSKBB4tzEhX0rRIosMGt0AAGq+CgAQjQg3uIFBoSyMAGwglS61QQQjMQAQwISEIFDnGIALiwXjCEoQPwMii8xAADUxAJDgLQAM+I4AmO8UCKHAEFR5hDgSJYCdykUKm94EUDX5gCD0jAARdkboFtQGEcRmCCQtELjAU0BAZesYg0YMAQMMDAEXAghSdUYJNmJEGg8CgERoHBHFNImhn1okoWQOgkWcDACcZ0EhTIIAYZWAACrNAARn6vgNgSRShCcYpT9KEPGHCbVTylAV9pilMOIEIS5lYRY30i4AMswOYXviACETCyAH2ApQgsoBnDKWEFDRjBIQpgghkEBAA7"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "It’s a short, festive clip that displays the message “Welcome Haryana Happy Teej” amid bright, colorful imagery suggestive of celebration. “Happy Teej” refers to a festival observed in parts of India—particularly in places like Haryana—to welcome the monsoon season. People often share such cheerful graphics or GIFs as festive greetings to mark the occasion."
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is an illustrative example of how the first frame might look if compressed to a 30×30 grid in a style reminiscent of an Abstraction and Reasoning Corpus (ARC) puzzle. This is a simplified, approximate representation (not the actual pixel data):\n\n[\n[3,1,2,2,0,0,3,3,8,5,4,1,1,4,0,3,9,6,7,3,2,6,6,4,1,0,7,4,3,2],\n[6,0,0,4,5,7,2,9,2,2,6,8,2,9,9,7,2,0,0,7,9,7,4,4,0,2,0,2,9,3],\n[5,5,8,6,6,7,1,1,2,0,3,0,3,4,8,8,1,2,3,7,2,6,4,8,0,5,1,0,8,7],\n[0,2,2,4,2,9,2,3,3,9,7,6,2,5,5,1,3,4,7,6,5,8,1,1,3,4,7,9,0,0],\n[2,1,2,3,5,7,7,2,2,0,7,4,2,8,1,1,8,5,2,9,4,0,2,6,8,1,1,4,4,2],\n[0,9,3,7,6,0,4,3,8,5,1,8,8,8,0,3,3,4,7,6,8,0,2,2,3,9,2,9,2,7],\n[7,6,5,1,2,4,6,2,2,1,9,7,9,3,2,8,6,4,4,5,0,0,7,5,1,8,3,4,2,5],\n[4,2,1,5,5,3,0,2,6,3,9,2,2,3,8,2,8,0,0,2,7,2,6,1,9,1,3,7,0,0],\n[9,6,6,8,2,0,5,0,6,7,5,3,2,6,1,3,5,5,7,3,1,9,5,2,8,2,5,6,2,1],\n[8,3,0,3,1,4,2,9,5,4,8,4,8,7,0,3,4,3,4,9,0,5,1,9,8,5,6,1,7,2],\n[2,5,6,8,2,7,1,3,1,0,0,6,5,2,5,4,4,1,9,5,3,7,6,8,1,2,0,3,7,8],\n[8,7,7,5,0,1,3,2,0,5,3,7,9,6,8,2,4,4,6,1,7,7,0,5,9,1,8,2,0,5],\n[1,8,0,3,5,9,8,4,2,5,5,4,9,7,1,1,0,1,3,7,4,3,1,1,6,5,8,0,4,6],\n[4,1,6,3,0,3,2,7,3,1,3,4,2,8,9,2,7,4,5,5,9,8,8,6,1,4,4,7,2,0],\n[8,9,7,1,3,8,2,1,2,0,3,8,6,9,2,0,0,8,1,1,6,1,2,4,0,9,2,3,7,4],\n[0,8,6,1,3,3,9,6,6,5,3,2,8,8,2,5,2,9,2,0,7,7,5,8,3,3,4,1,4,9],\n[1,8,5,0,7,2,4,1,3,3,0,3,6,2,2,2,8,6,4,3,4,8,2,0,1,0,0,3,7,1],\n[6,9,2,6,4,5,3,4,4,1,6,9,4,1,2,6,7,7,9,3,4,5,8,0,2,6,2,1,2,9],\n[7,2,4,1,6,5,9,3,4,2,1,2,5,0,6,3,1,4,0,6,8,5,0,6,4,1,7,3,5,2],\n[6,3,1,6,5,2,4,6,6,8,1,0,2,8,3,7,3,1,9,7,2,5,2,2,8,9,6,2,3,8],\n[3,3,6,5,6,7,6,8,4,0,4,5,3,2,0,2,7,1,1,6,8,3,3,0,6,7,5,4,5,4],\n[2,4,8,0,9,5,0,5,6,7,5,9,1,4,3,7,2,2,6,8,7,8,0,5,3,7,7,4,9,4],\n[1,7,9,6,0,6,9,8,3,7,0,4,0,4,8,2,0,3,3,0,6,1,0,9,7,9,8,6,0,8],\n[3,4,5,6,6,8,7,9,9,0,3,4,3,5,8,0,0,0,1,4,6,2,1,9,3,4,4,3,5,0],\n[7,2,8,9,1,5,5,1,1,2,2,3,6,7,4,4,7,2,5,3,1,3,9,6,0,4,5,1,7,6],\n[5,3,1,4,2,2,4,3,3,6,5,1,0,3,8,0,7,0,4,5,2,8,0,9,4,4,6,7,4,9],\n[8,6,8,1,9,0,7,1,5,6,8,7,2,9,8,3,3,4,5,2,0,1,3,2,3,5,9,0,1,6],\n[4,3,2,9,3,8,1,6,6,1,4,4,1,4,2,2,3,4,3,9,2,7,4,5,2,2,2,0,6,2],\n[0,4,7,6,8,3,1,1,7,1,8,9,3,2,2,1,5,6,4,4,6,7,5,8,3,0,0,1,9,8],\n[6,0,4,7,2,5,8,4,9,5,3,2,6,6,3,9,2,5,4,2,2,0,6,2,2,8,9,7,4,2]\n]\n\nEach number can be thought of as representing a simplified color category (for example, 0 for black, 1 for white, 2 for red, etc.) in a 30×30 grid. This format is only an illustrative, coarse abstraction designed to give a sense of how the frame might be interpreted in a small, grid-like style."
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is a conceptual, 30×30 “highlight” region of the GIF shown as a color-coded integer grid (0–9). Each cell loosely represents a pixel or small group of pixels, but this is not an actual extraction of the image data—just an illustrative example in a puzzle-like format. No face regions are discussed or included:\n\n[\n[6,3,2,3,2,1,0,9,7,4,2,1,9,9,7,6,6,4,1,5,8,4,8,2,0,0,3,7,3,2],\n[8,7,2,3,9,0,0,4,3,5,3,3,5,9,8,1,0,7,2,7,6,2,1,4,4,8,2,2,2,3],\n[5,5,4,0,4,2,7,0,9,9,1,2,5,3,4,4,3,8,1,1,0,0,1,2,3,8,9,2,7,8],\n[2,1,1,8,5,7,4,4,2,0,6,2,6,0,6,2,0,0,8,4,7,1,4,9,2,5,5,9,3,3],\n[7,3,8,9,5,9,6,1,1,3,4,5,1,0,0,9,9,7,3,5,1,2,9,3,8,4,4,9,7,2],\n[3,4,2,5,4,6,2,1,8,0,0,4,4,9,6,3,9,2,0,1,7,3,1,4,2,4,0,5,6,7],\n[0,0,9,0,2,2,8,8,6,7,3,3,8,0,2,0,1,4,9,5,6,2,4,5,5,3,7,8,9,9],\n[8,2,2,2,7,4,7,3,1,4,2,6,4,4,9,1,0,2,8,8,3,3,6,0,5,8,0,1,2,3],\n[3,6,0,0,1,1,5,9,3,7,2,8,4,4,6,0,9,4,2,2,0,0,6,7,3,1,8,4,5,9],\n[6,2,6,1,0,5,9,9,9,3,2,3,0,4,2,6,1,0,3,8,0,2,1,7,1,6,5,9,9,2],\n[0,1,5,9,8,4,8,2,3,3,9,2,7,5,2,8,0,7,3,3,6,1,4,1,3,2,8,8,2,0],\n[2,0,8,6,3,7,3,3,1,3,9,1,5,5,7,0,9,4,7,8,8,2,1,6,3,0,4,2,2,9],\n[5,8,5,0,3,0,1,2,8,9,2,6,5,7,7,2,2,3,6,1,4,6,4,3,1,8,2,2,0,7],\n[6,1,3,9,9,1,5,5,4,4,3,1,4,2,3,2,3,8,1,0,5,1,7,8,6,6,6,9,9,2],\n[9,9,0,2,6,1,4,7,9,6,7,2,2,0,1,2,9,1,3,3,2,1,5,4,0,7,6,3,2,2],\n[3,7,7,8,0,1,3,2,2,3,0,9,7,7,3,0,4,7,6,2,2,2,5,7,4,0,8,1,8,5],\n[1,2,5,5,6,9,9,3,4,8,8,2,4,0,2,1,0,6,8,5,2,3,9,0,1,2,8,6,5,6],\n[7,0,4,2,4,7,9,9,9,5,1,8,3,7,2,1,1,4,2,2,3,8,5,4,9,3,7,1,9,3],\n[5,1,0,9,7,9,2,6,8,2,4,0,5,1,4,5,7,0,2,2,3,9,8,4,8,5,9,1,2,3],\n[8,6,5,4,3,7,9,4,3,3,9,9,6,2,3,0,0,2,7,4,8,1,0,1,1,6,9,3,5,5],\n[9,1,7,8,2,3,4,9,6,1,5,3,2,2,9,8,2,7,1,7,9,9,0,6,0,8,4,7,3,3],\n[0,1,2,4,2,4,4,6,8,5,2,1,1,1,5,2,2,7,6,9,0,2,8,0,8,3,2,3,5,1],\n[4,9,5,5,2,8,9,7,2,7,1,3,2,8,6,6,4,5,0,3,9,9,4,4,8,2,1,2,0,0],\n[8,7,6,2,7,7,1,1,3,2,4,7,2,9,0,2,3,3,9,2,1,2,2,8,9,6,2,5,1,6],\n[1,2,0,2,3,0,4,4,5,7,6,1,5,2,8,9,5,3,0,1,7,2,4,4,6,7,1,2,4,9],\n[6,6,3,3,6,9,0,1,0,9,2,3,9,8,6,1,4,4,5,2,2,7,7,8,4,8,9,6,9,6],\n[1,6,9,8,4,2,8,0,2,2,4,0,7,8,3,1,1,3,5,1,3,0,2,1,5,8,8,4,4,7],\n[3,0,5,5,0,4,6,2,9,7,2,2,6,1,6,0,0,4,3,2,8,6,3,2,9,9,5,1,7,3],\n[2,2,6,2,3,2,7,4,0,4,1,2,8,9,1,1,8,4,7,0,3,0,9,2,4,3,9,5,2,8],\n[8,9,4,7,9,3,2,1,7,6,4,1,2,2,7,2,2,5,4,3,0,1,2,0,6,9,7,9,1,6]\n]\n\n• Each row is a single row of the grid (so there are 30 rows total).  \n• Each number can be interpreted as a simplified color label (e.g., 0 = black, 1 = white, 2 = red, etc.).  \n\nAgain, these values are just a stylized example meant to show how a 30×30 highlight region might look in a discrete, color-coded form."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example of a small Abstraction and Reasoning Corpus (ARC)-style puzzle (max 10×10). The rule is:  \n“Find the largest (foreground) object and recolor it to '9'.”  \n\n-------------------------------------------------------------------------------\nARC-LIKE TASK\n-------------------------------------------------------------------------------\nTraining Pair 1  \nInput (4×4):  \n(  \n  (0,0,0,0),  \n  (0,2,2,0),  \n  (0,2,2,0),  \n  (0,0,0,0)  \n)  \nOutput (4×4):  \n(  \n  (0,0,0,0),  \n  (0,9,9,0),  \n  (0,9,9,0),  \n  (0,0,0,0)  \n)  \n\n–––––––––––––––––––––––––––––––––––\n\nTraining Pair 2  \nInput (4×4):  \n(  \n  (0,3,0,4),  \n  (3,3,0,4),  \n  (0,0,4,4),  \n  (0,0,0,0)  \n)  \n\nOutput (4×4):  \n(  \n  (0,3,0,9),  \n  (3,3,0,9),  \n  (0,0,9,9),  \n  (0,0,0,0)  \n)  \n\n–––––––––––––––––––––––––––––––––––\n\nTraining Pair 3  \nInput (4×4):  \n(  \n  (0,0,0,0),  \n  (0,1,1,1),  \n  (2,2,0,2),  \n  (2,0,0,2)  \n)  \nOutput (4×4):  \n(  \n  (0,0,0,0),  \n  (0,1,1,1),  \n  (9,9,0,9),  \n  (9,0,0,9)  \n)  \n\n–––––––––––––––––––––––––––––––––––\n\nTest Pair (to be solved)  \nInput (4×4):  \n(  \n  (0,4,0,4),  \n  (4,4,4,0),  \n  (0,0,0,0),  \n  (1,1,0,1)  \n)  \n\nOutput (4×4):  \n(  \n  (0,9,0,9),  \n  (9,9,9,0),  \n  (0,0,0,0),  \n  (1,1,0,1)  \n)  \n\n-------------------------------------------------------------------------------\nANALOGY\n-------------------------------------------------------------------------------\nIn every example, we identify the largest connected “foreground” object (most cells) and recolor all of its cells to 9. The background is the most common color, so it’s excluded when searching for the largest object.\n\n-------------------------------------------------------------------------------\nSOLUTION PROGRAM (HODEL DSL)\n-------------------------------------------------------------------------------\nBelow is a sketch of how one might implement the transformation using the provided DSL. We define a function “solve(grid: Grid) -> Grid” that returns the puzzle’s solution grid:\n\n--------------------------------------------------------------------------------\nfrom arc_types import Grid\nfrom arc_types import objects, argmax, size, recolor, paint\n\ndef solve(grid: Grid) -> Grid:\n    \"\"\"\n    1) Identify foreground objects in the grid (without_bg=True).\n    2) Pick the largest object by area.\n    3) Recolor that object with color 9.\n    4) Paint the recolored object back into the grid.\n    \"\"\"\n    # Step 1: Find all univalued foreground objects (no diagonal connection).\n    # Most common color is background, so set without_bg=True to ignore it.\n    objs = objects(grid, univalued=True, diagonal=False, without_bg=True)\n\n    # Step 2: Identify the object with the largest area (size).\n    largest_obj = argmax(objs, size)\n\n    # Step 3: Recolor that largest object to color 9.\n    recolored_obj = recolor(9, largest_obj)\n\n    # Step 4: Paint the recolored object onto the original grid.\n    result = paint(grid, recolored_obj)\n    return result\n--------------------------------------------------------------------------------\n\nWhen run on each input grid, the function will output the grid where the largest foreground object is recolored to 9."
        }
    ]
}