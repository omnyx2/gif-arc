{
    "uuid": "d343381f-1201-4167-b280-511519a965c6",
    "created": "2025-04-15 03:58:11",
    "description": "아래 설명은 제공된 GIF를 몇 개의 주요 프레임(장면)으로 나누어, 요청하신 대로 시나리오 분석과 객체(등장요소) 식별, 그리고 2D 배열 표현 등을 간략화하여 예시 형태로 정리한 것입니다. 실제 GIF는 더 많은 프레임으로 구성되어 있을 수 있으나, 여기서는 프레임별 대표 장면을 추려서 설명합니다.\n\n────────────────────────────────────────\n1. 전체적인 시나리오 상세 묘사\n────────────────────────────────────────\n이 GIF에는 실내 거실로 보이는 공간에서 (1) 기저귀만 찬 아기가 기뻐하며 춤을 추고 있고, (2) 오른쪽에 크리스마스트리 일러스트가 겹쳐 있으며, (3) “Christmas Is Coming”이라는 알록달록한 텍스트가 장면 위에 배치되어 있습니다. 배경에는 가정집 식탁 의자나 그림 액자 등이 보이는데, 아기의 춤에 집중하게끔 전면부는 아기가 크게 부각되어 있고, 텍스트와 트리 이미지는 축제 분위기를 돋우는 장식처럼 나타납니다.\n\n1-1. 시각적 패턴 중 패러디나 은유(비유) 대상\n- “Christmas Is Coming”이라는 문구가 “Winter Is Coming”(미디어에서 유명한 표현) 등을 패러디한 것으로 볼 수도 있지만, GIF 자체는 크게 특정 작품을 직접적으로 패러디했다기보다는 “연말이 다가온다”는 의미를 직설적으로 보여주는 축제/유머 컨텐츠로 보입니다.  \n- 다만 적당히 해석하면, “~ Is Coming”이 여러 밈(meme)에서 흔히 패러디되는 문구이므로, 이를 ‘은유/비유’ 혹은 ‘패러디에 가까운 표현’으로 간주할 수 있습니다.\n\n────────────────────────────────────────\n2. 전체적인 시나리오에 관여하거나 보이는 모든 객체\n────────────────────────────────────────\n- 아기(생물)  \n- 크리스마스 트리(삽화/이미지 그래픽)  \n- “Christmas Is Coming” 텍스트(글자)  \n- 거실 내부의 가구 (의자, 탁자, 뒤쪽 그림 액자/벽 장식 등)\n\n2-1. 작은 객체가 모여서 유사한 큰 객체를 만드는 경우  \n- 이 GIF에서 “크리스마스 Is Coming”이라는 글자가 여러 개의 문자가 합쳐져 문장(텍스트 객체)을 형성합니다. 굳이 요청 형식에 맞추면 다음과 같이 볼 수 있습니다:  \n  {  \n    참여객체: [‘C’, ‘h’, ‘r’, …, ‘Coming’의 각 알파벳],  \n    참여방식: [단순 텍스트 배열],  \n    참여숫자: [각 글자 수],  \n    유사객체: [“크리스마스 Is Coming”이라는 전체 문구]  \n  }  \n- 트리는 단일 일러스트로 나타나므로 여러 작은 객체가 모여 새로운 객체가 되지는 않습니다.\n\n2-2. (예시) 현재 이미지 프레임 하나를 가로 세로 비율로 맞춰서, 더 긴 쪽을 30으로 축소했을 때의 2D 배열 표현  \n여기서는 실제 픽셀 데이터를 정확히 표시하기보다는, 각 프레임에서 주요 객체의 대략적 위치를 간단한 기호로 나타내는 예시를 듭니다(실제로는 프레임별로 23×30, 30×23 등 비율에 맞춰 긴 쪽이 30이 되도록 배열을 구성해야 합니다).\n\n예시 프레임(1번 프레임)에서 주요 객체들의 위치를 단순화하여 표기(가로가 더 긴 형태라 가로=30, 세로=대략 23으로 가정):\n\n- 아래 예시는 초기 프레임이라고 가정하고, (x,y) 좌표계로 설명하기보다는 2차원 배열의 (row, col) 형태로 간략 표현합니다.  \n- “아기” 영역을 ‘B’, “크리스마스 트리”를 ‘T’, 텍스트를 ‘TXT’, 그 외 배경을 ‘·(점)’으로 표기한 예시입니다.\n\n{\n  \"아기\": [\n    [\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\", ... (총 30칸) ],\n    [\"·\",\"·\",\"·\",\"·\",\"B\",\"B\",\"B\",\"·\",\"·\",\"·\", ...             ],\n    ... (총 23행)\n  ],\n  \"크리스마스트리\": [\n    [\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"T\",\"T\", ... ],\n    [\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"T\",\"T\",\"T\", ... ],\n    ...\n  ],\n  \"텍스트(Christmas Is Coming)\": [\n    [\"·\",\"TXT\",\"TXT\",\"TXT\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\", ...],\n    ... \n  ]\n}\n\n- 위 구조는 실제 픽셀 단위 대신 객체가 자리잡은 대략적인 구역을 예시로 든 것이며, 각 객체별로 “어떤 위치를 1(또는 특정 문자)로 표시할지”를 달리 나타낼 수 있습니다.  \n- 프레임이 변경되면서 ‘아기(B)’의 위치가 움직이거나 ‘텍스트(TXT)’가 깜빡이거나 이동하는 효과가 있다면, 각 프레임마다 2D 배열에 해당하는 행렬 표현이 달라지게 됩니다.\n\n────────────────────────────────────────\n3. 모든 프레임에서 등장하는 객체들의 상호작용 종류와 현상\n────────────────────────────────────────\n이 GIF는 프레임이 바뀔 때마다,  \n- 아기가 춤을 추며 자세와 위치가 미세하게 변함.  \n- “Christmas Is Coming” 텍스트의 색상이나 위치가 약간씩 변하거나 반짝이는 효과가 있음(프레임에 따라).  \n- 오른쪽의 크리스마스트리가 간단히 깜빡이거나 반짝이는 식(혹은 고정)이지만, 크게 움직이지는 않음.  \n- 배경(가구)는 정적이며, 아기와 장식(트리, 텍스트)만 동적으로 강조됩니다.\n\n이를 1번 시나리오와 연결하자면, “다가오는 크리스마스를 신나게 맞이하는 아기의 춤”이라는 전체 메시지가 일관되게 유지되고, 텍스트와 트리는 주로 축제 분위기(시각 효과)를 더해주는 보조 역할을 합니다.\n\n────────────────────────────────────────\n4. 상호작용을 구조화한 예시\n────────────────────────────────────────\n아래는 상호작용을 간단히 묶은 예시 형태입니다. (프레임마다 세세하게 나눌 수도 있지만, 전체를 관통하는 상호작용을 요약)\n\n1) 아기(춤) ↔ 텍스트(“Christmas Is Coming”)  \n   {  \n     \"관여하는 객체\": [\"아기\", \"텍스트\"],  \n     \"상호작용 종류\": \"시각적 연출(움직임 vs 고정/반짝임)\",  \n     \"상호작용의 파라미터\": [\"아기는 위치·자세 변화\", \"텍스트는 색/애니메이션 효과\"]  \n   }\n\n2) 아기(춤) ↔ 크리스마스트리(그래픽)  \n   {  \n     \"관여하는 객체\": [\"아기\", \"크리스마스트리\"],  \n     \"상호작용 종류\": \"시각적 연출(춤 추는 아기와 옆에 서 있는 트리)\",  \n     \"상호작용의 파라미터\": [\"아기는 춤\", \"트리는 고정 혹은 반짝임\"]  \n   }\n\n3) 아기(춤) ↔ 배경(가구, 의자, 그림 등)  \n   {  \n     \"관여하는 객체\": [\"아기\", \"가정집 배경\"],  \n     \"상호작용 종류\": \"단순 배경/전경 구분(아기가 전경)\",  \n     \"상호작용의 파라미터\": [\"배경은 고정\", \"아기는 중심에서 움직임\"]  \n   }\n\n────────────────────────────────────────\n5. 유사한 상황 예시\n────────────────────────────────────────\n- “새해가 다가오기 전 연말 파티에서 아기가 춤을 추며 즐거워하는 영상”  \n- 명절이나 기념일 직전에 가족들이 집안에서 파티 분위기를 내고 있는 모습  \n- SNS에서 종종 보이는 아기(혹은 반려동물) 영상에 축제 분위기 장식을 덧입혀 만든 짤  \n\n즉, 특정 기념일이 되기 전 기대감과 즐거움을 표현하는 유머·밈(meme)과 유사한 맥락으로 볼 수 있습니다.\n\n以上입니다. 실제 GIF는 더 많은 프레임으로 이루어져 있고, 2D 배열 역시 픽셀 단위로 더 정밀하게 나타낼 수 있으나, 여기서는 요청하신 “프레임별 시나리오 분석 및 객체 식별, (축소된) 2D 매핑 예시”를 요약·간소화하여 보여 드렸습니다.",
    "model": [
        "o1 only"
    ],
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "위의 GIF를 프레임별로 나눠서 전체적인 시나리오를 분석하고 아래의 기준으로 설명해줘\n1. 전체적인 시나리오를 상세히 묘사해줘\n1-1. 시각적 패턴 중 패러디나 은유(비유)된 대상을 모두 추출해줘\n2. 전체적인 시나리오에 관여하거나 보이는 모든 객체(생물, 물체, 그림 등)를 간결하게 대답해\n2-1. 작은 객체가 모여서 유사한 큰 객체를 만드는 경우에는 { 참여객체: [...], 참여방식:[], 참여숫자:[], 유사객체: [...]} \n2-2. 현재 이미지 프레임을 비율을 맞춰서 가로나 세로 중 더 긴것의 크기를30에 맞춰, 그리고 그 내부의 각 객체를 2D array로 만들어서 { [객체의이름]: [[...],[...],...,[...]]이런 형식으로 줘  \n3. GIF의 모든 프레임을 분석해서 등장하는 객체의 상호작용의 종류와 현상을 1번의 시나리오에 연결해서 간결하게 짚어줘.\n4. 3번의 상호작용을 이제 { \"관여하는 객체\": [], \"상호작용 종류\":\"\", \"상호작용의 파라미터\":[]} \n5. 마지막으로 1~4 이외에 현재 이미지에 대해 유사한 상황을 떠올려서 말해줘"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "아래 설명은 제공된 GIF를 몇 개의 주요 프레임(장면)으로 나누어, 요청하신 대로 시나리오 분석과 객체(등장요소) 식별, 그리고 2D 배열 표현 등을 간략화하여 예시 형태로 정리한 것입니다. 실제 GIF는 더 많은 프레임으로 구성되어 있을 수 있으나, 여기서는 프레임별 대표 장면을 추려서 설명합니다.\n\n────────────────────────────────────────\n1. 전체적인 시나리오 상세 묘사\n────────────────────────────────────────\n이 GIF에는 실내 거실로 보이는 공간에서 (1) 기저귀만 찬 아기가 기뻐하며 춤을 추고 있고, (2) 오른쪽에 크리스마스트리 일러스트가 겹쳐 있으며, (3) “Christmas Is Coming”이라는 알록달록한 텍스트가 장면 위에 배치되어 있습니다. 배경에는 가정집 식탁 의자나 그림 액자 등이 보이는데, 아기의 춤에 집중하게끔 전면부는 아기가 크게 부각되어 있고, 텍스트와 트리 이미지는 축제 분위기를 돋우는 장식처럼 나타납니다.\n\n1-1. 시각적 패턴 중 패러디나 은유(비유) 대상\n- “Christmas Is Coming”이라는 문구가 “Winter Is Coming”(미디어에서 유명한 표현) 등을 패러디한 것으로 볼 수도 있지만, GIF 자체는 크게 특정 작품을 직접적으로 패러디했다기보다는 “연말이 다가온다”는 의미를 직설적으로 보여주는 축제/유머 컨텐츠로 보입니다.  \n- 다만 적당히 해석하면, “~ Is Coming”이 여러 밈(meme)에서 흔히 패러디되는 문구이므로, 이를 ‘은유/비유’ 혹은 ‘패러디에 가까운 표현’으로 간주할 수 있습니다.\n\n────────────────────────────────────────\n2. 전체적인 시나리오에 관여하거나 보이는 모든 객체\n────────────────────────────────────────\n- 아기(생물)  \n- 크리스마스 트리(삽화/이미지 그래픽)  \n- “Christmas Is Coming” 텍스트(글자)  \n- 거실 내부의 가구 (의자, 탁자, 뒤쪽 그림 액자/벽 장식 등)\n\n2-1. 작은 객체가 모여서 유사한 큰 객체를 만드는 경우  \n- 이 GIF에서 “크리스마스 Is Coming”이라는 글자가 여러 개의 문자가 합쳐져 문장(텍스트 객체)을 형성합니다. 굳이 요청 형식에 맞추면 다음과 같이 볼 수 있습니다:  \n  {  \n    참여객체: [‘C’, ‘h’, ‘r’, …, ‘Coming’의 각 알파벳],  \n    참여방식: [단순 텍스트 배열],  \n    참여숫자: [각 글자 수],  \n    유사객체: [“크리스마스 Is Coming”이라는 전체 문구]  \n  }  \n- 트리는 단일 일러스트로 나타나므로 여러 작은 객체가 모여 새로운 객체가 되지는 않습니다.\n\n2-2. (예시) 현재 이미지 프레임 하나를 가로 세로 비율로 맞춰서, 더 긴 쪽을 30으로 축소했을 때의 2D 배열 표현  \n여기서는 실제 픽셀 데이터를 정확히 표시하기보다는, 각 프레임에서 주요 객체의 대략적 위치를 간단한 기호로 나타내는 예시를 듭니다(실제로는 프레임별로 23×30, 30×23 등 비율에 맞춰 긴 쪽이 30이 되도록 배열을 구성해야 합니다).\n\n예시 프레임(1번 프레임)에서 주요 객체들의 위치를 단순화하여 표기(가로가 더 긴 형태라 가로=30, 세로=대략 23으로 가정):\n\n- 아래 예시는 초기 프레임이라고 가정하고, (x,y) 좌표계로 설명하기보다는 2차원 배열의 (row, col) 형태로 간략 표현합니다.  \n- “아기” 영역을 ‘B’, “크리스마스 트리”를 ‘T’, 텍스트를 ‘TXT’, 그 외 배경을 ‘·(점)’으로 표기한 예시입니다.\n\n{\n  \"아기\": [\n    [\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\", ... (총 30칸) ],\n    [\"·\",\"·\",\"·\",\"·\",\"B\",\"B\",\"B\",\"·\",\"·\",\"·\", ...             ],\n    ... (총 23행)\n  ],\n  \"크리스마스트리\": [\n    [\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"T\",\"T\", ... ],\n    [\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\",\"T\",\"T\",\"T\", ... ],\n    ...\n  ],\n  \"텍스트(Christmas Is Coming)\": [\n    [\"·\",\"TXT\",\"TXT\",\"TXT\",\"·\",\"·\",\"·\",\"·\",\"·\",\"·\", ...],\n    ... \n  ]\n}\n\n- 위 구조는 실제 픽셀 단위 대신 객체가 자리잡은 대략적인 구역을 예시로 든 것이며, 각 객체별로 “어떤 위치를 1(또는 특정 문자)로 표시할지”를 달리 나타낼 수 있습니다.  \n- 프레임이 변경되면서 ‘아기(B)’의 위치가 움직이거나 ‘텍스트(TXT)’가 깜빡이거나 이동하는 효과가 있다면, 각 프레임마다 2D 배열에 해당하는 행렬 표현이 달라지게 됩니다.\n\n────────────────────────────────────────\n3. 모든 프레임에서 등장하는 객체들의 상호작용 종류와 현상\n────────────────────────────────────────\n이 GIF는 프레임이 바뀔 때마다,  \n- 아기가 춤을 추며 자세와 위치가 미세하게 변함.  \n- “Christmas Is Coming” 텍스트의 색상이나 위치가 약간씩 변하거나 반짝이는 효과가 있음(프레임에 따라).  \n- 오른쪽의 크리스마스트리가 간단히 깜빡이거나 반짝이는 식(혹은 고정)이지만, 크게 움직이지는 않음.  \n- 배경(가구)는 정적이며, 아기와 장식(트리, 텍스트)만 동적으로 강조됩니다.\n\n이를 1번 시나리오와 연결하자면, “다가오는 크리스마스를 신나게 맞이하는 아기의 춤”이라는 전체 메시지가 일관되게 유지되고, 텍스트와 트리는 주로 축제 분위기(시각 효과)를 더해주는 보조 역할을 합니다.\n\n────────────────────────────────────────\n4. 상호작용을 구조화한 예시\n────────────────────────────────────────\n아래는 상호작용을 간단히 묶은 예시 형태입니다. (프레임마다 세세하게 나눌 수도 있지만, 전체를 관통하는 상호작용을 요약)\n\n1) 아기(춤) ↔ 텍스트(“Christmas Is Coming”)  \n   {  \n     \"관여하는 객체\": [\"아기\", \"텍스트\"],  \n     \"상호작용 종류\": \"시각적 연출(움직임 vs 고정/반짝임)\",  \n     \"상호작용의 파라미터\": [\"아기는 위치·자세 변화\", \"텍스트는 색/애니메이션 효과\"]  \n   }\n\n2) 아기(춤) ↔ 크리스마스트리(그래픽)  \n   {  \n     \"관여하는 객체\": [\"아기\", \"크리스마스트리\"],  \n     \"상호작용 종류\": \"시각적 연출(춤 추는 아기와 옆에 서 있는 트리)\",  \n     \"상호작용의 파라미터\": [\"아기는 춤\", \"트리는 고정 혹은 반짝임\"]  \n   }\n\n3) 아기(춤) ↔ 배경(가구, 의자, 그림 등)  \n   {  \n     \"관여하는 객체\": [\"아기\", \"가정집 배경\"],  \n     \"상호작용 종류\": \"단순 배경/전경 구분(아기가 전경)\",  \n     \"상호작용의 파라미터\": [\"배경은 고정\", \"아기는 중심에서 움직임\"]  \n   }\n\n────────────────────────────────────────\n5. 유사한 상황 예시\n────────────────────────────────────────\n- “새해가 다가오기 전 연말 파티에서 아기가 춤을 추며 즐거워하는 영상”  \n- 명절이나 기념일 직전에 가족들이 집안에서 파티 분위기를 내고 있는 모습  \n- SNS에서 종종 보이는 아기(혹은 반려동물) 영상에 축제 분위기 장식을 덧입혀 만든 짤  \n\n즉, 특정 기념일이 되기 전 기대감과 즐거움을 표현하는 유머·밈(meme)과 유사한 맥락으로 볼 수 있습니다.\n\n以上입니다. 실제 GIF는 더 많은 프레임으로 이루어져 있고, 2D 배열 역시 픽셀 단위로 더 정밀하게 나타낼 수 있으나, 여기서는 요청하신 “프레임별 시나리오 분석 및 객체 식별, (축소된) 2D 매핑 예시”를 요약·간소화하여 보여 드렸습니다."
        },
        {
            "role": "user",
            "content": "아래의 전공지식 내용을 고려해서 \n\n 전공 지식의 내용\n# GIF 고도화 방안제시\n\n기존의 상황에서 GIF의 아날로지를 더욱 상세하게 분석을 하다 아날로지의 추출부분과 정확한 비트맵의 추출 부분에서 막혔다. 그래서 GIF를 분석하여 프롬프트를 고도화하는 방향에 대해 제안하고자 한다. \n\n분석을 위해서 기초적으로 GIF를 다음과 같이 정의한다.\n\n \n\n1. Object는 GIF이미지 재생 동안 존재하는 모든 오브젝트 이다.\n    1. 이때 오브젝트는 다음과 같이 2종류가 있다.\n        1. explicit 오브젝트: 물리량이 정확히 존재하는 객체로 정의한다.\n        2. implicit 오브젝트: explicit 물체가 모여 비유적인 객체가 존재한다. (사람들로 도형을 만들거나 하는 등)\n2. 아날로지 A는 GIF내 단일 a를 모두 모은 Space 이다.\n    1. 아날로지는 다음과 같이 3종류와 하나 더 얹어진 아날로지로 구성한다.\n        1. clear 아날로지(cla): 아날로지 중 상호작용에 관여되는 객체 explicit오브젝트이며 지정과 목표, 정확한 파라메터가 요구된다.  (중력에 의해 공이 10m 등, 도형이 나선형으로 회전 하고 있다)\n        2. ambiguous 아날로지(aba): 아날로지 중 상호작용에 작용되는 객체가 implicit오브젝트이며 목표가 지정되지 않을 수 있고 파라메타는 간접적이다.  (사람이 모여 팩맨을 만들고, 팩맨은 돈을 먹으로 다닌다)\n        3. Contrain 아날로지(coa): 상호작용중 제약으로 동작하는 아날로지이다. 객체는 explicit implicit을 전부 포함할수 있다. ( 그림상의 모든 물체는 벽을 넘어갈수 없다)\n        4. poeatic 아날로지(poa): 위의 세 아날로지를 바탕으로 생성된 비유적 표현의 아날로지이다.\n3. T는 GIF의 전체 재생 시간을 의미하며\n    1. T는 맥락(장면) 바뀌는 구간들인  $T=\\{T_1,T_2,T_3,..., T_n\\}$로 나뉜다. ($T_i$: 사람들이 야구를 보는 장면, $T_{i+1}$: 야구 투수가 공을쳐서 날아간 장면)\n    2. $\\sum{}T_i$는 전체 재생 시간 보다 같거나 길다. 이는 장면전환에 발생하는 시간에 의해서 그렇게 된다.\n4. N은 보조인자로 큰 고려대상은 아니다. 예) GIF가 자체가 가지는 노이즈로 이는 가우스 노이즈의 역함수로 정의한다.\n\n# 비유에 대한 정의\n\nGIF에 대한 정의가 완료되고 다음은 이를 보았을 때 비유를 정의한다; M. 비유는 전체적인 상황에 대한 비유, 객체에 대한 비유(implicit 오브젝트), 상호작용에 대한 비유가 존재한다. 비유는 여러 상황을 하나로 묶는데 동작할 수 있다. 따라서 아래와 같이 GIF 를 정의 하는 내부요소에 대해 비유는 관측되며, 이러한 관측 된 비유는 너무 완전히 같지 않고 너무 완전히 다르지 않은 영역에서 동일한 비유가 생성될 수 있다.\n\n $p_i(Object,A,T_i,N|m_i)$  ~ $M_i$\n\n$p_j(Object,A,T_j,N|m_j)$ ~ $M_j$\n\n$0.8 > D_{KL}(M_i||M_j) > 0.5, \\ M_i = M_j$ \n\n# GIF를 ARC 하는 작업 정의\n\n이러한 GIF를 ARC 하기 위해 작업을 고려하였을 때, GIF에서 바로 아크로 가는 작업은 다중 아날로지에서 하나의 단일 아날로지로 가는 동시에 시간에 대해 있던 정보가 유실됨으로 많은 단계를 건너 띄는 것처럼 보임. 따라서 기존의 압축절차를 단계별로 세분화하고 이를 바탕으로 점진적으로 정보를 떨어 뜨리는 과정으로 시도하고 있음."
        },
        {
            "role": "assistant",
            "content": "아래 내용은 이전에 진행했던 GIF 분석(아기 춤과 “Christmas Is Coming” 텍스트, 크리스마스 트리 등이 있는 짧은 GIF)을, 새로 제시된 전공지식(“GIF 고도화 방안제시”)에 따라 더욱 구조화하여 설명하고, 이를 활용해 어떤 식으로 프롬프트를 고도화할 수 있는지에 대한 하나의 예시 제안입니다.\n\n────────────────────────────────────────\n1. 전공지식 요약 및 적용 방향\n────────────────────────────────────────\n제시된 전공지식에 따르면, GIF를 분석할 때 다음을 고려해야 합니다:\n\n1) Object(오브젝트) 정의  \n   - Explicit 오브젝트: 실제 물리량을 가지고 있는 객체  \n   - Implicit 오브젝트: 여러 explicit 오브젝트가 모여 새롭게 비유적인 큰 객체로 나타나는 경우  \n\n2) 아날로지(Analogy) A 정의  \n   - clear 아날로지(cla): 명백히 정의된 상호작용. 파라미터(위치, 속도 등)가 구체적이고, 주로 explicit 오브젝트가 참여  \n   - ambiguous 아날로지(aba): 참여 객체가 implicit 형태이거나 목표가 불분명  \n   - contrain 아날로지(coa): 상호작용 시 제약(규칙, 물리 법칙 등)을 나타내는 아날로지. explicit/implicit 모두 포함 가능  \n   - poeatic 아날로지(poa): 위의 세 가지 아날로지를 조합해, 비유적인 표현을 확장하는 아날로지  \n\n3) T: GIF를 구성하는 전체 재생 시간을 장면(맥락)별로 쪼갠 것의 집합  \n   - 예) T = {T₁, T₂, …, Tₙ}  \n   - 각 Tᵢ는 하나의 ‘장면(맥락)’으로 볼 수 있음  \n\n4) N: GIF에 포함된 노이즈성 요소. (크게 중요하진 않으나, 필요하면 고려)  \n\n5) 비유(M)에 대한 정의  \n   - GIF 내에서 “비유”는 전체적인 상황(시나리오) 또는 객체나 상호작용의 의미적 확장을 가리킴  \n   - 둘 이상의 상황(맥락) 또는 객체가 “너무 다르지 않고, 너무 같지도 않은 수준”에 있을 때 동일한 비유로 묶일 수 있음 (KL Divergence 0.8 > D > 0.5 같은 식)  \n\n────────────────────────────────────────\n2. 기존 GIF 분석을 전공지식 체계에 맞추어 재정리\n────────────────────────────────────────\n이전에 “아기가 기저귀 차고 춤을 추며, ‘Christmas Is Coming’ 텍스트와 크리스마스 트리가 화면에 표시되는 짧은 GIF”를 분석하였는데, 이를 전공지식 체계로 다음처럼 매핑할 수 있습니다.\n\n(1) Object 분류  \n   ① Explicit 오브젝트  \n      - “아기”: 실제 물리량(인간)  \n      - “크리스마스트리(삽화 형태긴 하지만)는 여기서도 시각적으로 ‘하나의 물체’로 명확히 존재”라고 볼 수 있으므로 explicit로 간주 가능 (단, 애니메이션 효과/삽화 여부에 따라 구분이 애매할 수 있으나, 전공지식에서 명시적으로 ‘물리량’이 아니면 의문이 생길 수도 있음. 그러나 크리스마스트리를 ‘분명한 하나의 시각적 객체’로 여긴다면 explicit로 처리 가능)  \n      - “텍스트(Christmas Is Coming)”: 글자 자체도 화면에 렌더링된 ‘하나의 객체’로 간주    \n      - “배경(의자, 탁자, 그림 액자 등)”: 일반적으로는 별도 상호작용 없이 고정되어 있으나, 존재하는 물리적 요소  \n\n   ② Implicit 오브젝트  \n      - 이 GIF에는 여러 explicit 객체가 모여서 다른 비유적 도형이나 캐릭터를 형성하는 장면은 뚜렷이 없음.  \n      - “Christmas Is Coming” 문구가 ‘Winter Is Coming’ 등의 밈을 패러디한 측면에서, 그것을 “은유된 하나의 개념적 오브젝트(연말 분위기 or 패러디)”로 해석할 수도 있으나, 전공지식에서 말하는 “implicit 오브젝트”는 사람이 모여서 팩맨 모양을 만든다든지, 물리적으로 합쳐져서 다른 어떤 도형을 형성하는 류를 가리키므로, 여기서는 엄밀히 ‘비유적 텍스트 표현’이지 ‘explicit 오브젝트들이 모여서 하나의 배치로 새로운 오브젝트를 형성’하는 것은 아님.  \n      - 따라서 이 GIF에서는 두드러지는 Implicit 오브젝트는 존재하지 않는다고 정리 가능  \n\n(2) 아날로지(Analogy) 분류  \n   ① clear 아날로지(cla)  \n      - 아기가 춤을 추는 동작: “아기”라는 explicit 오브젝트가 중력/바닥을 딛고 움직이는 상황. 다만 속도·각도 같은 물리 파라미터를 엄밀히 측정하진 않았으나, 원한다면 측정 가능  \n      - “크리스마스트리” 그래픽이 동일한 위치에서 깜빡이거나 고정되어 있는 경우, 혹은 “텍스트”도 흔들리거나 깜빡이는 효과가 있다면, 그것들 역시 위치·색상 변화라는 명확한 파라미터를 갖는 아날로지가 될 수 있음  \n\n   ② ambiguous 아날로지(aba)  \n      - 만약 이 GIF가 “붙여 넣은 트리와 텍스트”라는, 실제 물리적 맥락과 달리 합성된 상태를 ‘비유적으로 연말 분위기’로 표현했다고 본다면, 이 부분을 “목표가 분명치 않은(단순히 즐거움·축제감 전달 목적) 시각적 비유”로 분류 가능  \n      - 따라서 “크리스마스 트리 + 텍스트”가 합쳐지며 표현하는 “연말 파티 분위기”는 명확한 파라미터가 없다(춤추는 아기가 어떤 동작을 정확히 해야 한다든지 하는 목표가 정의되지 않음). 이를 aba로 볼 수도 있음  \n\n   ③ contrain 아날로지(coa)  \n      - 일반적으로 “아기는 방 안의 공간을 벗어나지 않는다” 혹은 “배경(의자, 탁자 등)의 위치는 고정되어 있다” 등의 제약이 있을 수 있음 (벽을 뚫고 나가는 등의 초현실적 장면이 없으므로, 물리적 제약이 암묵적으로 유지).  \n      - 이 GIF 내에는 explicit/implicit 구분 통틀어 “기본 물리적 제약” 정도가 존재한다고 해석할 수 있음  \n\n   ④ poeatic 아날로지(poa)  \n      - “크리스마스 Is Coming(=Winter Is Coming 패러디?)”이라는 텍스트의 존재와 춤추는 아기라는 유머적/밈적 요소가 합쳐져서 “다가오는 크리스마스, 즐겁게 춤추는 아기”라는 분위기(시적·유머적) 자체가 poa에 가깝다고 볼 수 있음  \n      - 즉 cla/aba/coa가 합쳐져 “연말의 즐거움을 비유적으로 표현”하는 하나의 상징적 장면을 만든다고 해석 가능  \n\n(3) T(장면별 시간 구간)  \n   - GIF가 짧아 장면 전환이 뚜렷하지 않고, 배경이 동일하며, 아기가 여러 자세로 춤추는 것이 주된 변화입니다.  \n   - 장면을 굳이 나눈다면,  \n     T₁: 아기가 처음 웃으며 춤을 시작하는 순간  \n     T₂: 텍스트(Christmas Is Coming)가 강조되는/등장하는 타이밍  \n     T₃: 크리스마스 트리가 깜빡이는(혹은 고정되어 있되 시각효과가 가미된) 타이밍  \n     … 등으로 세분 가능  \n   - 각 Tᵢ마다 배경은 동일하지만, “아기의 포즈 변경, 텍스트 반짝임 여부” 등으로 나누어볼 수 있습니다.  \n\n(4) N(노이즈)  \n   - 큰 움직임에 따른 화면 흔들림이나 화질 저하 등의 노이즈가 있을 수 있으나, GIF의 고화질 여부에 따라 달라집니다.  \n   - 여기서는 GIF 자체가 저화질(짧은 해상도)일 가능성이 높으므로, 노이즈(N)는 “가우스 노이즈의 역함수”로 표현 가능하지만, 실제 분석에서는 크게 중요한 요소는 아닙니다.  \n\n────────────────────────────────────────\n3. 이러한 분석을 토대로 한 고도화된 프롬프트 제안\n────────────────────────────────────────\n위 전공지식을 반영하여, “이 GIF를 더 정교하게 분석하고 싶다”면, 예컨대 아래와 같은 형태의 프롬프트(또는 분석 절차)를 고려할 수 있습니다.\n\n(예시)\n\n------------------------------------------------------------\n[고도화된 분석 프롬프트 예시]\n\n1) GIF의 전체 재생 시간을 T로 나누어, 각 Tᵢ마다 Explicit 오브젝트와 Implicit 오브젝트를 분류한다.  \n   - Explicit 오브젝트: 아기, 텍스트, 트리, 배경가구 등  \n   - Implicit 오브젝트: (있다면) 여러 객체가 모여 만든 비유적 형상  \n\n2) 각 오브젝트별로 어떤 아날로지(cla, aba, coa, poa)에 해당하는지 판단한다.  \n   - “아기가 춤을 춘다” → cla(명확한 동작 파라미터)  \n   - “트리에 불이 들어온다(깜빡임 효과)” → cla(혹은 aba, 시각 효과에 따라)  \n   - “텍스트(Christmas Is Coming)로 느껴지는 밈·축제 분위기” → aba 또는 poa(비유적 표현)  \n   - “아기는 배경(의자, 탁자)을 지나쳐 밖으로 나가지 않음” → coa(물리적 제약)  \n\n3) 객체 상호작용과 시간(Tᵢ) 변화를 종합하여 비유(M)를 추출한다.  \n   - 예: “연말(크리스마스) 분위기의 즐거운 춤”이라는 전체 시나리오 → poa  \n   - 동작 간에 명확한 물리 파라미터가 설정되는지, 단순 시각적·유머적 표현인지 구분  \n\n4) 필요하다면 노이즈(N)도 고려하여, GIF 프레임별 객체 검출이나 움직임 추적 시 발생할 수 있는 오류를 보완한다.  \n   - N을 낮추는 전처리(예: 프레임간 보간/필터링)로 객체 추적 정확도를 높인다.  \n\n5) 최종적으로, cla/aba/coa/poa를 종합하여 “이 GIF가 표현하려는 비유”的 M을 정의한다.  \n   - 예: “다가오는 크리스마스를 아이의 춤과 함께 유머러스하게 표현한 밈(meme)적 비유”  \n\n------------------------------------------------------------\n\n위 플로우(아날로지 분류 → 객체/장면 분할 → 비유(M) 도출)에 따라 GIF를 분석하면, 여러 프레임의 객체적·시나리오적 의미가 더욱 구조적으로 정리됩니다. 또한 ARC(Abstraction & Reasoning Corpus)나 유사한 이미지/동영상 분석 파이프라인에 적용할 때도, 다중 아날로지를 단일 아날로지로 ‘무리하게’ 압축하기보다는, 단계적으로 정보를 추출해내는 접근이 가능해집니다.\n\n────────────────────────────────────────\n4. 결론 및 요약\n────────────────────────────────────────\n- 전공지식에서 소개된 “explicit/implicit 오브젝트” 분류, “clear/ambiguous/contrain/poeatic 아날로지” 구분, GIF의 시간 분할(T), 노이즈(N) 등의 프레임워크를 적용하면, 이전에 단순히 “아기가 춤추고 텍스트와 트리가 배치된 GIF”라던 매크로 수준의 분석을 보다 세밀하게 구조화할 수 있습니다.  \n- 특히, “이 GIF가 나타내는 비유적 의미(M)는 무엇인가?”를 고민할 때, 각각의 객체가 어떠한 아날로지로 작용하는지(동작 파라미터가 있는지, 비유적 표현인지, 물리적 제약인지 등)를 단계별로 구분해보는 방식이 유용합니다.  \n- 이러한 접근은 GIF를 머신러닝/ARC 등에서 다룰 때, 프롬프트 설계 또는 데이터 라벨링 시 “어떤 정보를 추출하고, 어떤 과정을 거쳐야 하는가?”를 명확히 설명해주는 로드맵 역할을 할 수 있습니다.\n\n以上입니다. 이와 같은 방식으로 GIF를 전공지식 체계에 맞춰 분석 및 프롬프트를 고도화한다면, 더 풍부한 표현과 명확한 구조를 갖는 결과물을 도출할 수 있을 것입니다."
        },
        {
            "role": "user",
            "content": "위의 프롬프트를 바탕으로 ARCprize 데이터 JSON을 만들어줘 인풋은 과 아웃풋총 3쌍을 만들어야해"
        },
        {
            "role": "assistant",
            "content": "아래 예시는 “GIF 고도화 방안제시”에서 소개된 개념(오브젝트, 아날로지 등)을 간단히 활용하여, 세 쌍의 (input, output)을 담은 ARCprize 형식의 JSON 예시입니다. 실제 활용 시에는 더 구체적인 T(장면 분할), 파라미터, 노이즈(N) 값 등을 세부적으로 기입할 수 있습니다.\n\n────────────────────────────────────────\n예시: ARCprize 데이터 JSON (3쌍의 인풋-아웃풋)\n────────────────────────────────────────\n{\n  \"ARCprize\": [\n    {\n      \"input\": {\n        \"description\": \"짧은 GIF(아기가 춤추고, 크리스마스 트리와 'Christmas Is Coming' 텍스트가 표시됨)\",\n        \"T\": [\n          {\n            \"id\": \"T1\",\n            \"context\": \"아기가 춤을 시작하는 초기 장면\"\n          }\n        ],\n        \"Object\": {\n          \"explicit\": [\"아기\", \"크리스마스트리\", \"텍스트(Christmas Is Coming)\", \"배경(의자, 탁자 등)\"],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\"아기의 뚜렷한 춤 동작 (위치, 동선 등 구체적 파라미터로 표현 가능)\"],\n          \"aba\": [\"텍스트와 트리가 주는 연말 분위기의 간접적 비유\"],\n          \"coa\": [\"아기는 바닥·벽을 넘지 않음 (물리적 제약)\"],\n          \"poa\": [\"아기 + 트리 + 텍스트 결합으로 형성되는 축제·밈적 유머\"]\n        },\n        \"N\": \"영상 자체의 약간의 화질 저하\",\n        \"goal\": \"초기 장면에서 주요 오브젝트 식별 및 기초 분석\"\n      },\n      \"output\": {\n        \"analysis\": \"T1 구간에서 아기는 명확히 보이는 explicit 객체이며, 배경은 고정. 트리와 텍스트는 춤출 때 추가적으로 부각되는 시각적 요소.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"같은 GIF에서, 텍스트('Christmas Is Coming')가 깜빡이거나 색이 변하는 프레임\",\n        \"T\": [\n          {\n            \"id\": \"T2\",\n            \"context\": \"텍스트 강조 장면\"\n          }\n        ],\n        \"Object\": {\n          \"explicit\": [\"아기\", \"텍스트(Christmas Is Coming)\"],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\"텍스트 색상 변화(프레임별 RGB값 등으로 측정 가능)\"],\n          \"aba\": [\"'Is Coming' → 추가된 밈적 느낌(직접적 목표 미정)\"],\n          \"coa\": [],\n          \"poa\": []\n        },\n        \"N\": \"프레임 전환 시 발색 노이즈가 약간 존재\",\n        \"goal\": \"텍스트가 어떻게 시각 효과를 통해 강조되는지 파악\"\n      },\n      \"output\": {\n        \"analysis\": \"텍스트를 하나의 explicit 객체로 간주하여 RGB·위치 변화를 cla로 본다. 동시에 'Is Coming'이라는 표현 자체가 대중 밈을 암시하므로 약간의 aba 성격이 있다.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"같은 GIF에서, 크리스마스 트리(그래픽)가 깜빡이거나 회전 효과가 있다고 가정하는 프레임\",\n        \"T\": [\n          {\n            \"id\": \"T3\",\n            \"context\": \"크리스마스 트리가 강조되는 장면\"\n          }\n        ],\n        \"Object\": {\n          \"explicit\": [\"아기\", \"크리스마스트리\"],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\"트리가 일정 궤도로 회전·깜빡이는 효과 (파라미터: 회전 속도, 각도)\"],\n          \"aba\": [],\n          \"coa\": [\"트리가 특정 위치(오른쪽)에서만 움직임 (공간적 제약)\"],\n          \"poa\": [\"트리 장식에 담긴 ‘연말 축제’ 비유/상징\"]\n        },\n        \"N\": \"트리 그래픽 변경 시 생기는 GIF 해상도 노이즈\",\n        \"goal\": \"트리의 움직임(혹은 깜빡임) 파라미터를 명확히 식별\"\n      },\n      \"output\": {\n        \"analysis\": \"크리스마스 트리를 explicit 오브젝트로 보며, 회전·깜빡임은 cla 속성을 갖는다. 동시에 트리는 공간상 고정된 제약(coa) 내에서만 움직여, GIF 전반의 물리적 일관성을 유지한다.\"\n      }\n    }\n  ]\n}\n\n────────────────────────────────────────\n설명\n────────────────────────────────────────\n1) \"ARCprize\"라는 키 아래에 세 개의 오브젝트(배열 원소)를 두어, 각각 (input, output)을 한 쌍으로 만든 예시입니다.  \n2) input에는 GIF 장면(T)의 구간, 객체(Object), 아날로지(Analogy) 분류, 노이즈(N), 그리고 분석 목표(goal) 등을 간략히 기술했습니다. 실제 ARC/분석 환경에 따라 확장 또는 축약이 가능합니다.  \n3) output에는 해당 input(장면)에 대한 요약 분석 결과나 추가 판단 사항 등을 간단히 정리했습니다.  \n4) 이 예시 JSON은 “GIF 고도화 방안제시”에 나온 개념을 최소한으로 시연하기 위한 것으로, 실제 프로젝트에선 더 자세한 구조(예: frame-by-frame 좌표 정보, RGB 값, 상호작용 파라미터 수치 등)나 태그(tag) 방식 등을 적용할 수 있습니다."
        },
        {
            "role": "user",
            "content": "2차원 배열로 구성해서 비트맵으로 만들어줘"
        },
        {
            "role": "assistant",
            "content": "아래 예시는 앞서 만든 ARCprize 형식(JSON)에, 각 장면(T)을 2차원 배열(bitmap) 형태로 간단히 표현한 예시입니다. 실제 상황에서는 프레임별 해상도나 오브젝트 크기에 따라 더 큰 배열이 필요할 수 있으나, 여기서는 “간단한 상징”으로서 비트맵을 구성했습니다.\n\n설명용 기호:  \n• \".\" : 배경(Background)  \n• \"A\" : 아기(Baby)  \n• \"T\" : 크리스마스 트리(Tree)  \n• \"X\" : 텍스트(“Christmas Is Coming”)  \n\n────────────────────────────────────────\nJSON 예시\n────────────────────────────────────────\n{\n  \"ARCprize\": [\n    {\n      \"input\": {\n        \"description\": \"짧은 GIF(아기가 춤추는 초기 장면, T1)\",\n        \"T\": [\n          {\n            \"id\": \"T1\",\n            \"context\": \"아기가 춤을 시작하는 초기 장면\"\n          }\n        ],\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\",\n            \"텍스트(Christmas Is Coming)\",\n            \"배경(의자, 탁자 등)\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"아기의 특정 동작 (춤)\",\n            \"텍스트·트리가 고정된 위치에 존재\"\n          ],\n          \"aba\": [],\n          \"coa\": [\n            \"아기는 방의 한정된 영역 내에서만 움직임\"\n          ],\n          \"poa\": [\n            \"아기 + 트리 + 텍스트가 주는 축제/유머적 분위기\"\n          ]\n        },\n        \"N\": \"영상 화질이 다소 저해됨(가우스 노이즈)\",\n        \"goal\": \"초기 장면에서 주요 오브젝트 및 움직임 파악\",\n        \"bitmap\": [\n          [\".\", \".\", \"X\", \"X\", \"X\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T1 구간: 아기가 가운데 부근에서 춤을 시작. 오른쪽 상단에 트리, 왼쪽 상단에 텍스트가 위치하여 전체 장면 형성.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"텍스트('Christmas Is Coming')가 깜빡이는 장면, T2\",\n        \"T\": [\n          {\n            \"id\": \"T2\",\n            \"context\": \"텍스트 강조 장면\"\n          }\n        ],\n        \"Object\": {\n          \"explicit\": [\"아기\", \"텍스트(Christmas Is Coming)\"],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"텍스트가 주기적으로 색상·형태가 바뀜\"\n          ],\n          \"aba\": [\n            \"텍스트가 전달하는 밈적 뉘앙스(목표가 불분명)\"\n          ],\n          \"coa\": [],\n          \"poa\": []\n        },\n        \"N\": \"텍스트 반짝임 시 노이즈\",\n        \"goal\": \"텍스트 강조 효과(색상 변화 등) 분석\",\n        \"bitmap\": [\n          [\".\", \".\", \".\", \"x\", \"x\", \"x\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T2 구간: 텍스트가 반짝이거나 색이 달라짐(x로 표기), 아기는 중앙에서 계속 움직임.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"크리스마스 트리가 깜빡이거나 회전한다고 가정한 장면, T3\",\n        \"T\": [\n          {\n            \"id\": \"T3\",\n            \"context\": \"크리스마스 트리 강조 장면\"\n          }\n        ],\n        \"Object\": {\n          \"explicit\": [\"아기\", \"크리스마스트리\"],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"트리의 회전·깜빡임(파라미터: 회전각, 속도)\"\n          ],\n          \"aba\": [],\n          \"coa\": [\n            \"트리는 오른쪽 상단 구역 범위 내에서만 변화\"\n          ],\n          \"poa\": [\n            \"연말 축제를 상징하는 트리로 전체 분위기 강화\"\n          ]\n        },\n        \"N\": \"트리 그래픽 변경 시 발생하는 GIF 노이즈\",\n        \"goal\": \"트리 애니메이션 분석\",\n        \"bitmap\": [\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T3 구간: 트리가 깜빡이거나 회전(‘T’로 표현). 아기는 계속 움직이며 트리는 특정 영역 내에서만 변화.\"\n      }\n    }\n  ]\n}\n\n────────────────────────────────────────\n주요 포인트  \n────────────────────────────────────────\n1) bitmap 필드에는 2차원 배열을 사용해, 각 위치에서 어떤 객체(또는 배경)가 주로 차지하는지 단순 기호로 표기했습니다.  \n2) 실제 분석에서 해상도가 커지면 행·열을 늘려 더 치밀하게 표현해야 합니다(픽셀 단위 등). 본 예시는 “상징적으로” 각 객체의 대략적 위치만 나타낸 예시입니다.  \n3) 나머지 필드는 이전과 유사하게 “Object”, “Analogy”, “goal”, “N” 등의 분석 요소를 함께 포함했습니다.  "
        },
        {
            "role": "user",
            "content": "잘했어 이제 아래의 프롬프트를 바탕으로 다시한번 만들어줘.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "아래 예시는 앞서 제시한 “아기와 크리스마스 트리, 텍스트가 있는 GIF” 분석을 2차원 배열(비트맵) 형태로 나타낸 ARCprize 형식의 예시이며, 제공된 함수(def add, def subtract 등)들이 들어 있는 arc_types.py(또는 유사 모듈) 기반의 전처리·변환 기능을 가정한 간략한 형태입니다. 실제 ARC 환경에서는 “train/test” 구조나 더 복잡한 단계가 있을 수 있으나, 여기서는 요청대로 “(input, output)의 3쌍”을 예시로 만들어 두었습니다. 또한 bitmap 및 transformations 항목에 간단히 함수들을 연결하는 예시를 넣었습니다.\n\n────────────────────────────────────────\nARCprize JSON 예시\n────────────────────────────────────────\n\n{\n  \"ARCprize\": [\n    {\n      \"input\": {\n        \"description\": \"짧은 GIF(아기가 춤추는 초기 장면, T1)\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\",\n            \"텍스트(Christmas Is Coming)\",\n            \"배경(의자, 탁자 등)\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"아기의 춤 동작 (명확한 위치·동작)\"\n          ],\n          \"aba\": [],\n          \"coa\": [\n            \"아기는 물리적 제약 내(방 내부)에서만 움직인다\"\n          ],\n          \"poa\": [\n            \"연말 파티 분위기를 상징적으로 표현(유머)\"\n          ]\n        },\n        \"T\": [\n          {\n            \"id\": \"T1\",\n            \"context\": \"아기가 춤을 시작하는 초기 장면\"\n          }\n        ],\n        \"N\": \"GIF 화질 노이즈가 약간 존재\",\n        \n        \"bitmap\": [\n          [\".\", \".\", \"X\", \"X\", \"X\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \n        \"transformations\": [\n          {\n            \"function\": \"canvas\",\n            \"description\": \"7x7 그리드 생성\",\n            \"args\": [0, [7, 7]]\n          },\n          {\n            \"function\": \"paint\",\n            \"description\": \"텍스트(X), 트리(T), 아기(A)를 해당 좌표에 채색\",\n            \"args\": [\"(위에서 만든 7x7 캔버스)\", \"오브젝트들의 좌표·색(문자)\"]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T1 구간: 아기가 중앙 근처에서 춤을 시작. 상단 왼쪽 텍스트, 오른쪽 상단 트리.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"GIF 중간 장면: 텍스트 깜빡임(T2)\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"텍스트(깜빡이는 Christmas Is Coming)\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"텍스트 색상·형태가 프레임별로 변함\"\n          ],\n          \"aba\": [\n            \"텍스트가 밈적 표현(목표 불명확, 단순 재미)\"\n          ],\n          \"coa\": [],\n          \"poa\": []\n        },\n        \"T\": [\n          {\n            \"id\": \"T2\",\n            \"context\": \"텍스트 강조 장면\"\n          }\n        ],\n        \"N\": \"깜빡임 효과에 따른 색상 노이즈\",\n        \n        \"bitmap\": [\n          [\".\", \".\", \".\", \"x\", \"x\", \"x\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \n        \"transformations\": [\n          {\n            \"function\": \"switch\",\n            \"description\": \"특정 색(문자) 교체를 통한 깜빡임 효과\",\n            \"args\": [\"(위 bitmap)\", \"X\", \"x\"]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T2 구간: 텍스트가 반짝이거나 색이 바뀜, 아기는 중앙에서 계속 춤.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"GIF 후반 장면: 크리스마스 트리 강조(T3)\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"트리가 회전 또는 깜빡이는 효과(파라미터: 각도, 불빛)\"\n          ],\n          \"aba\": [],\n          \"coa\": [\n            \"트리는 오른쪽 상단 구역 안에서만 움직임\"\n          ],\n          \"poa\": [\n            \"연말 축제 분위기를 상징\"\n          ]\n        },\n        \"T\": [\n          {\n            \"id\": \"T3\",\n            \"context\": \"트리가 강조되는 장면\"\n          }\n        ],\n        \"N\": \"트리 그래픽 변경 시 발생하는 노이즈\",\n        \n        \"bitmap\": [\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \n        \"transformations\": [\n          {\n            \"function\": \"shift\",\n            \"description\": \"트리(T)의 좌표를 회전·변환(단순히 시프트 예시)\",\n            \"args\": [\n              \"오브젝트(트리) 좌표\",\n              \"(0, 1)\"\n            ]\n          },\n          {\n            \"function\": \"paint\",\n            \"description\": \"회전(혹은 시프트)된 트리를 기존 grid에 합성\",\n            \"args\": [\"(이전 bitmap)\", \"(변환된 트리 객체)\"]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T3 구간: 트리가 깜빡이거나 시프트·회전. 아기는 계속 중앙에서 움직이고, 트리는 오른쪽 부분에 있어서 물리적 제약(coa).\"\n      }\n    }\n  ]\n}\n\n────────────────────────────────────────\n설명  \n────────────────────────────────────────\n1) \"ARCprize\" 리스트 내에 총 세 쌍의 (input, output)을 구성했습니다.  \n2) 각 input에는 description, Object, Analogy, T(장면 ID), N(노이즈), 그리고 bitmap(2차원 배열 형태)를 명시했습니다.  \n3) transformations 필드는 제공된 arc_types.py의 함수를 예시로 간단하게 연결해 보였습니다. 실제로는 paint, shift, canvas, switch 등의 함수를 어떻게 호출하고, 어떤 매개변수를 넘기는지는 구현 환경에 따라 달라질 수 있습니다.  \n4) output에는 해당 장면(혹은 프레임 구간)에 대한 “analysis(분석 결과)”를 간략히 기재했습니다.  \n5) 사용한 기호와 배열 크기는 예시로, 실제 GIF에서는 해상도나 비트맵 크기가 더 커질 수 있으며, 오브젝트 표기도 달라질 수 있습니다."
        },
        {
            "role": "user",
            "content": "위의 프롬프트를 바탕으로 ARCprize 데이터 JSON을 만들어줘 인풋은 과 아웃풋총 3쌍을 만들어야해"
        },
        {
            "role": "assistant",
            "content": "{\n  \"ARCprize\": [\n    {\n      \"input\": {\n        \"description\": \"짧은 GIF 초기 장면 (T1): 아기가 춤을 추기 시작하며 크리스마스트리와 텍스트가 배치된 상황\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\",\n            \"텍스트(Christmas Is Coming)\",\n            \"배경 가구 등\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"아기의 구체적 동작(춤)\"\n          ],\n          \"aba\": [],\n          \"coa\": [\n            \"아기가 방 내부에서만 움직임 (물리적 제한)\"\n          ],\n          \"poa\": [\n            \"아기 + 트리 + 텍스트가 주는 연말 축제 분위기\"\n          ]\n        },\n        \"T\": [\n          {\n            \"id\": \"T1\",\n            \"context\": \"GIF 1단계 (초기 장면)\"\n          }\n        ],\n        \"N\": \"뒤 배경 잡음 등 미미한 화질 노이즈\",\n        \"bitmap\": [\n          [\".\", \".\", \"X\", \"X\", \"X\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \"transformations\": [\n          {\n            \"function\": \"canvas\",\n            \"description\": \"7x7 캔버스 생성 (기본 배경)\",\n            \"args\": [0, [7, 7]]\n          },\n          {\n            \"function\": \"paint\",\n            \"description\": \"아기(A), 텍스트(X), 트리(T)를 캔버스 위에 배치\",\n            \"args\": [\n              \"(직전 만든 캔버스)\",\n              \"(위 bitmap의 좌표값/기호)\"\n            ]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"아기가 중앙에서 춤을 추는 장면, 텍스트는 왼측 상단, 트리는 오른쪽\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"GIF 중간 장면 (T2): 텍스트(Christmas Is Coming) 강조, 깜빡임 효과\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"텍스트(Christmas Is Coming)\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"텍스트 색상·형태가 프레임별 변화 (구체 파라미터)\"\n          ],\n          \"aba\": [\n            \"텍스트가 밈(패러디) 느낌을 주어 목표 불분명\"\n          ],\n          \"coa\": [],\n          \"poa\": []\n        },\n        \"T\": [\n          {\n            \"id\": \"T2\",\n            \"context\": \"GIF 2단계 (텍스트 강조)\"\n          }\n        ],\n        \"N\": \"텍스트 반짝임 표시 시 발생하는 컬러 노이즈\",\n        \"bitmap\": [\n          [\".\", \".\", \".\", \"x\", \"x\", \"x\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \"transformations\": [\n          {\n            \"function\": \"switch\",\n            \"description\": \"텍스트 색을 X <-> x로 교체하여 깜빡이는 효과 연출\",\n            \"args\": [\n              \"(위 bitmap)\",\n              \"X\",\n              \"x\"\n            ]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"텍스트가 두세 가지 색으로 깜빡이며, 아기는 중앙에서 계속 춤을 춤\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"GIF 후반 장면 (T3): 크리스마스트리 반짝임/회전 강조\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\n            \"트리 그래픽 회전·깜빡임 파라미터(회전각, 빛 변화 등)\"\n          ],\n          \"aba\": [],\n          \"coa\": [\n            \"트리는 화면 우측 상단 영역에만 존재, 방 벽 넘어가지 않음\"\n          ],\n          \"poa\": [\n            \"연말 분위기를 시각적으로 극대화\"\n          ]\n        },\n        \"T\": [\n          {\n            \"id\": \"T3\",\n            \"context\": \"GIF 3단계 (트리 강조)\"\n          }\n        ],\n        \"N\": \"트리 그래픽이 깜빡일 때 발생하는 화질 잡음\",\n        \"bitmap\": [\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \"T\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \"A\", \"A\", \"A\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \"transformations\": [\n          {\n            \"function\": \"shift\",\n            \"description\": \"트리(T)를 약간 이동 혹은 회전한 것처럼 표현 (등장 위치 변화)\",\n            \"args\": [\n              \"(트리 오브젝트)\",\n              \"(0, 1)\"\n            ]\n          },\n          {\n            \"function\": \"paint\",\n            \"description\": \"시프트된 트리를 기존 캔버스(혹은 bitmap)에 적용\",\n            \"args\": [\n              \"(이전 bitmap)\",\n              \"(변환된 트리)\"\n            ]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"트리의 시각효과(빙글 돌거나 빛나는 느낌). 아기는 계속 몸을 흔들며, GIF 마무리 분위기.\"\n      }\n    }\n  ]\n}"
        },
        {
            "role": "user",
            "content": "2차원 배열로 구성해서 비트맵으로 만들어줘"
        },
        {
            "role": "assistant",
            "content": "아래 예시는 앞선 GIF 시나리오(아기가 춤추고, 크리스마스트리와 “Christmas Is Coming” 텍스트가 등장)를 2차원 배열(비트맵) 형태로 각각 T1, T2, T3 장면을 나타내는 ARCprize 형식 JSON 예시입니다.\n\n----------------------------------------------------------------------------\nJSON 예시\n----------------------------------------------------------------------------\n\n{\n  \"ARCprize\": [\n    {\n      \"input\": {\n        \"description\": \"GIF 초기 장면 (T1): 아기가 춤을 추기 시작, 텍스트(Christmas Is Coming)와 크리스마스트리 존재\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\",\n            \"텍스트(Christmas Is Coming)\",\n            \"배경(가구 등)\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\"아기의 구체적 춤 동작(위치, 자세 등)\"],\n          \"aba\": [],\n          \"coa\": [\"아기는 방 안에서만 움직임 (물리적 제약)\"],\n          \"poa\": [\"연말 축제 분위기의 상징적 표현\"]\n        },\n        \"T\": [\n          {\n            \"id\": \"T1\",\n            \"context\": \"아기가 춤을 추는 초기 장면\"\n          }\n        ],\n        \"N\": \"뒤 배경 등 약간의 화질 노이즈\",\n        \n        \"bitmap\": [\n          [\".\", \".\",  \"X\", \"X\", \"X\", \".\",  \"T\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\",  \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\",  \".\"],\n          [\".\", \".\",  \".\", \"A\", \"A\", \"A\",  \".\"],\n          [\".\", \".\",  \".\", \"A\", \"A\", \"A\",  \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\",  \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\",  \".\"]\n        ],\n        \n        \"transformations\": [\n          {\n            \"function\": \"canvas\",\n            \"description\": \"7x7 캔버스를 0(또는 '.')으로 초기화\",\n            \"args\": [0, [7, 7]]\n          },\n          {\n            \"function\": \"paint\",\n            \"description\": \"텍스트(X), 아기(A), 트리(T) 등 각 좌표에 배치\",\n            \"args\": [\n              \"(생성된 7x7 캔버스)\",\n              \"(위 bitmap 좌표 데이터)\"\n            ]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T1: 중앙부 아기, 왼쪽 상단 텍스트(X), 우측 상단 트리(T). 아기는 춤, 텍스트와 트리는 고정.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"GIF 중간 (T2): 텍스트 깜빡임(Christmas Is Coming 강조)\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"텍스트\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\"텍스트 색상·형태 프레임별 변화 (정량화 가능)\"],\n          \"aba\": [\"\" \n                  \"밈(패러디)적 요소로 목표 불분명\"],\n          \"coa\": [],\n          \"poa\": []\n        },\n        \"T\": [\n          {\n            \"id\": \"T2\",\n            \"context\": \"텍스트 색상 깜빡임 장면\"\n          }\n        ],\n        \"N\": \"텍스트 깜빡임에 따른 노이즈\",\n        \n        \"bitmap\": [\n          [\".\", \".\",  \".\", \"x\", \"x\", \"x\", \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\",  \".\", \"A\", \"A\", \"A\", \".\"],\n          [\".\", \".\",  \".\", \"A\", \"A\", \"A\", \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \n        \"transformations\": [\n          {\n            \"function\": \"switch\",\n            \"description\": \"텍스트 색상 X↔x 교체로 깜빡임 구현\",\n            \"args\": [\n              \"(위 bitmap)\",\n              \"X\",\n              \"x\"\n            ]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T2: 텍스트가 x로 변하여 번쩍이는 효과. 아기는 동일 위치에서 계속 춤.\"\n      }\n    },\n    {\n      \"input\": {\n        \"description\": \"GIF 후반 (T3): 크리스마스트리 회전·깜빡임 표현\",\n        \"Object\": {\n          \"explicit\": [\n            \"아기\",\n            \"크리스마스트리\"\n          ],\n          \"implicit\": []\n        },\n        \"Analogy\": {\n          \"cla\": [\"트리가 회전·색 변화를 통해 시각효과 부각\"],\n          \"aba\": [],\n          \"coa\": [\"트리는 화면 우측 상단 (방 내부 한정)\"],\n          \"poa\": [\"연말 행사 느낌 극대화(비유적 축제)\"]\n        },\n        \"T\": [\n          {\n            \"id\": \"T3\",\n            \"context\": \"트리가 강조되는 마지막 장면\"\n          }\n        ],\n        \"N\": \"트리 그래픽 변환 시 화질 노이즈\",\n        \n        \"bitmap\": [\n          [\".\", \".\",  \".\", \".\", \".\", \"T\", \"T\"],\n          [\".\", \".\",  \".\", \".\", \".\", \"T\", \"T\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\",  \".\", \"A\", \"A\", \"A\", \".\"],\n          [\".\", \".\",  \".\", \"A\", \"A\", \"A\", \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"],\n          [\".\", \".\",  \".\", \".\", \".\", \".\", \".\"]\n        ],\n        \n        \"transformations\": [\n          {\n            \"function\": \"shift\",\n            \"description\": \"트리를 (0,1)만큼 이동시켜 한쪽으로 살짝 옮긴 효과\",\n            \"args\": [\n              \"(트리 오브젝트)\",\n              \"(0, 1)\"\n            ]\n          },\n          {\n            \"function\": \"paint\",\n            \"description\": \"움직인(혹은 회전) 트리를 기존 캔버스에 적용\",\n            \"args\": [\n              \"(기존 bitmap)\",\n              \"(변환된 트리)\"\n            ]\n          }\n        ]\n      },\n      \"output\": {\n        \"analysis\": \"T3: 트리가 깜빡이며 위치 살짝 이동. 아기는 동일하게 춤, 트리는 우상단에 고정.\"\n      }\n    }\n  ]\n}\n\n----------------------------------------------------------------------------\n설명  \n----------------------------------------------------------------------------\n1) 7×7 크기의 2차원 배열을 사용해 각 장면(T1, T2, T3)의 비트맵을 나타냅니다.  \n2) “X”→“x”로 깜빡이는 효과(텍스트), 혹은 트리를 “T” 2칸으로 넓혀 표현해 간단히 회전·이동한 듯 보이게 구성했습니다.  \n3) transformations 필드는 arc_types 모듈을 가정하고, bitmap을 어떻게 변환하는지 예시로 간단히 작성했습니다.  \n4) 필요에 따라 .(닷) 대신 0, 바탕색 대신 다른 코드 등을 사용할 수도 있습니다.  "
        }
    ]
}