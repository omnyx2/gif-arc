{
    "uuid": "ddee99c4-341e-4e18-9e1a-cd7cf48cd2cd",
    "created": "2025-04-06 22:13:37",
    "description": "It shows a young child excitedly celebrating the announcement of a wedding. The text “A WEDDING!!” appears, accompanied by heart emojis, emphasizing the child’s enthusiasm and joy for the upcoming event. The overall mood is one of playful, energetic excitement about a joyful celebration.",
    "response": [
        {
            "role": "user",
            "content": "I am ai and gif professor."
        },
        {
            "role": "assistant",
            "content": "arc is types of Abtract Reasoning Corpus, and you are professor. I should say things clearly and without fakes at all."
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi GPT, can you explain this gif ?"
                },
                {
                    "type": "image_url",
                    "image_url": {
                        "url": "data:image/gif;base64,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"
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": "It shows a young child excitedly celebrating the announcement of a wedding. The text “A WEDDING!!” appears, accompanied by heart emojis, emphasizing the child’s enthusiasm and joy for the upcoming event. The overall mood is one of playful, energetic excitement about a joyful celebration."
        },
        {
            "role": "user",
            "content": "So, this is gif, so time-series image data. Can you under-size the image by 30x30? grid style. You may know how Abstraction and Reasoning Corpus look like. You can follow that style, but no input-output pair, but image1 -> image2 -> image 3 -> image n  (each image has same size of grid 30x30) just show me the first image (it can be represented as array)"
        },
        {
            "role": "assistant",
            "content": "Below is an illustrative example of how one might represent the first frame of the GIF as a 30×30 grid (in a style reminiscent of an Abstraction and Reasoning Corpus). This is a purely hypothetical/color-coded transformation since I don’t have direct pixel access here. Each number could correspond to a color index:\n\n[\n[7,7,2,2,2,4,4,2,2,1,6,0,6,7,1,2,2,8,5,2,1,7,1,4,3,3,9,8,8,2],\n[7,7,2,2,1,4,4,2,2,2,6,0,0,7,1,2,2,8,5,2,1,7,1,4,3,3,9,8,8,2],\n[7,7,2,2,1,4,4,2,2,1,6,0,6,7,1,2,2,8,5,2,1,7,1,4,3,3,9,8,8,2],\n[7,7,2,2,1,4,4,2,2,1,6,0,6,7,1,2,2,8,5,2,1,7,1,4,3,3,9,8,8,2],\n[7,7,2,2,2,4,4,2,2,1,6,0,6,7,1,2,2,8,5,2,1,7,1,4,3,3,9,8,8,2],\n[7,8,8,8,8,0,0,8,1,1,6,2,6,7,1,2,9,8,5,2,1,7,1,4,9,9,9,8,8,2],\n[7,8,8,8,8,0,0,8,1,1,6,2,6,7,1,2,9,8,5,2,1,7,1,4,9,9,9,8,8,2],\n[7,8,8,8,8,0,0,8,1,1,6,2,6,7,1,2,9,8,5,2,1,7,1,4,9,9,9,8,8,2],\n[7,7,2,2,1,4,4,2,2,1,6,0,0,7,1,2,2,9,5,2,1,7,1,4,9,9,9,8,8,2],\n[7,7,2,2,1,4,4,2,2,1,6,0,0,7,1,2,2,9,5,2,1,7,1,4,9,9,9,8,8,2],\n[6,6,6,6,9,9,7,7,1,1,3,3,3,3,8,8,8,8,8,0,0,0,0,1,1,1,1,4,4,1],\n[6,6,6,6,9,9,7,7,1,1,3,3,3,3,8,8,8,8,8,0,0,0,0,1,1,1,1,4,4,1],\n[6,6,6,6,9,9,7,7,1,1,3,3,3,3,8,8,8,8,8,0,0,0,0,1,1,1,1,4,4,1],\n[6,6,6,6,9,9,7,7,1,1,3,3,3,3,8,8,8,8,8,0,0,0,0,1,1,1,1,4,4,1],\n[5,4,4,4,9,9,9,1,1,1,3,0,3,1,1,1,8,8,8,0,0,0,0,1,4,4,4,1,1,1],\n[5,4,4,4,9,9,9,1,1,7,3,0,3,1,9,9,8,8,8,0,0,0,0,1,4,4,4,1,1,1],\n[5,4,4,4,9,9,9,1,1,7,3,0,3,1,9,9,8,8,8,0,0,0,0,1,4,4,4,1,1,1],\n[5,4,4,4,9,9,9,1,1,1,3,0,3,1,9,9,8,8,8,0,0,0,0,1,4,4,4,1,1,1],\n[9,1,1,7,7,7,5,5,5,5,5,2,6,6,6,6,8,8,8,2,2,2,2,2,4,4,8,8,8,1],\n[9,1,1,7,7,7,5,5,5,5,5,2,6,6,6,6,8,8,8,2,2,2,2,2,4,4,8,8,8,1],\n[9,1,1,7,7,7,5,5,5,5,5,2,6,6,6,6,8,8,8,2,2,2,2,2,4,4,8,8,8,1],\n[9,1,1,7,1,1,5,5,5,5,5,2,0,0,0,0,8,8,8,2,2,2,2,2,4,4,8,8,8,1],\n[9,1,1,7,1,1,5,5,5,5,5,2,0,0,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[9,9,9,1,1,1,5,5,5,5,5,2,0,0,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[9,9,9,1,1,1,5,5,5,5,5,2,0,0,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[7,9,1,1,5,5,5,5,5,5,5,2,2,2,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[7,9,1,1,5,5,5,5,5,5,5,2,2,2,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[7,7,1,1,1,5,5,5,5,5,5,2,0,2,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[7,7,1,1,1,5,5,5,5,5,5,2,0,2,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1],\n[7,7,1,9,1,5,5,5,5,5,5,2,0,2,0,0,8,8,8,2,2,2,2,2,1,1,8,8,8,1]\n]\n\nNo mention is made of any blurred face here; this grid is simply an abstracted, downscaled matrix (30×30) to demonstrate how one could represent a GIF frame in such a format."
        },
        {
            "role": "user",
            "content": "Then, can you give me the highlight part of the pixelated gif with same 30x30 grid , you can provide me the matrix as well as generating image if you want."
        },
        {
            "role": "assistant",
            "content": "Below is a hypothetical example of a “highlight” region from the GIF, represented as a 30×30 grid of color indices. Each number here is an arbitrary placeholder symbolizing a pixel’s color or intensity in a downscaled version of the original animation (and does not refer to any specific facial feature). This is just an illustration:\n\n[\n[0,0,0,0,1,1,1,1,1,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,6,6,6,7,7,7],\n[0,0,0,0,1,1,1,1,1,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,6,6,6,7,7,7],\n[0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,4,4,5,5,6,6,6,7,7,7],\n[0,0,0,1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,7,7,7,7],\n[0,0,0,1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,7,7,7,7],\n[0,1,1,1,1,1,1,1,2,2,2,2,3,3,3,4,4,4,4,4,5,5,5,6,6,6,6,6,7,7],\n[0,1,1,1,1,1,1,1,2,2,2,2,3,3,3,4,4,4,4,4,5,5,5,6,6,6,6,6,7,7],\n[0,1,1,1,1,2,2,2,2,2,2,2,3,3,4,4,4,4,4,5,5,5,5,6,6,6,6,6,7,7],\n[0,1,1,1,1,2,2,2,2,2,2,2,3,3,4,4,4,4,4,5,5,5,5,6,6,6,6,6,7,7],\n[0,1,1,1,1,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7],\n[0,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7],\n[0,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,6,6,6,6,7,7,7],\n[0,1,2,2,2,2,2,2,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,6,6,6,6,7,7,7],\n[0,1,2,2,2,2,2,2,3,3,3,3,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,7,7,7],\n[1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,7,7,7],\n[1,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,6,6,6,7,7,7,8],\n[1,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,6,6,6,7,7,7,8],\n[1,1,1,2,2,2,3,3,3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,6,6,7,7,7,8,8],\n[1,1,1,2,2,3,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,5,6,6,6,7,7,7,8,8],\n[1,1,1,1,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,8,8,8],\n[1,1,1,1,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7,8,8,8,8],\n[1,1,1,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,6,6,6,7,7,7,8,8,8,8,8],\n[1,1,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,8,8,8,8,8],\n[1,1,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,6,6,6,6,6,7,7,7,8,8,8,8,8],\n[2,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8],\n[2,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8],\n[2,2,2,3,3,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8],\n[2,2,2,3,3,4,4,4,4,5,5,5,5,5,5,5,6,6,6,7,7,7,7,7,8,8,8,8,8,8],\n[2,2,2,2,3,3,4,4,4,5,5,5,5,5,5,5,6,6,7,7,7,7,7,7,8,8,8,8,8,8],\n[2,2,2,2,3,3,3,4,4,5,5,5,5,5,5,5,6,6,7,7,7,7,7,8,8,8,8,8,8,8],\n[2,2,2,2,2,3,3,4,4,5,5,5,5,5,5,5,6,6,7,7,7,7,7,8,8,8,8,8,8,8]\n]\n\nFeel free to interpret or visualize this however you’d like. This grid is only meant as an abstracted, simplified sample—color values (0–9) are placeholders and not a literal description of the source imagery."
        },
        {
            "role": "user",
            "content": "Good job, using concept you said about image, can you build an abstraction and reasoning corpus-style problem (max size = 10x10 for your efficiency)= 3 train input-output pair, and one test input-output pair.  \n\n    When developing a problem, please use the provided DSLs designed by Michael Hodel. \n    Your analogy should be solved by combining the provided DSLs . \n\n    Please provide the ARC-like task as well as its analogy as well as program with Hodel DSL.\n\n    Below are Hodel DSL.\n\n    from arc_types import *\n\n\n    def identity(\n        x: Any\n    ) -> Any:\n        \"\"\" identity function \"\"\"\n        return x\n\n\n    def add(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" addition \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a + b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] + b[0], a[1] + b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a + b[0], a + b[1])\n        return (a[0] + b, a[1] + b)\n\n\n    def subtract(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" subtraction \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a - b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] - b[0], a[1] - b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a - b[0], a - b[1])\n        return (a[0] - b, a[1] - b)\n\n\n    def multiply(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" multiplication \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a * b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] * b[0], a[1] * b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a * b[0], a * b[1])\n        return (a[0] * b, a[1] * b)\n        \n\n    def divide(\n        a: Numerical,\n        b: Numerical\n    ) -> Numerical:\n        \"\"\" floor division \"\"\"\n        if isinstance(a, int) and isinstance(b, int):\n            return a // b\n        elif isinstance(a, tuple) and isinstance(b, tuple):\n            return (a[0] // b[0], a[1] // b[1])\n        elif isinstance(a, int) and isinstance(b, tuple):\n            return (a // b[0], a // b[1])\n        return (a[0] // b, a[1] // b)\n\n\n    def invert(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" inversion with respect to addition \"\"\"\n        return -n if isinstance(n, int) else (-n[0], -n[1])\n\n\n    def even(\n        n: Integer\n    ) -> Boolean:\n        \"\"\" evenness \"\"\"\n        return n % 2 == 0\n\n\n    def double(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by two \"\"\"\n        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)\n\n\n    def halve(\n        n: Numerical\n    ) -> Numerical:\n        \"\"\" scaling by one half \"\"\"\n        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)\n\n\n    def flip(\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical not \"\"\"\n        return not b\n\n\n    def equality(\n        a: Any,\n        b: Any\n    ) -> Boolean:\n        \"\"\" equality \"\"\"\n        return a == b\n\n\n    def contained(\n        value: Any,\n        container: Container\n    ) -> Boolean:\n        \"\"\" element of \"\"\"\n        return value in container\n\n\n    def combine(\n        a: Container,\n        b: Container\n    ) -> Container:\n        \"\"\" union \"\"\"\n        return type(a)((*a, *b))\n\n\n    def intersection(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" returns the intersection of two containers \"\"\"\n        return a & b\n\n\n    def difference(\n        a: FrozenSet,\n        b: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" set difference \"\"\"\n        return type(a)(e for e in a if e not in b)\n\n\n    def dedupe(\n        tup: Tuple\n    ) -> Tuple:\n        \"\"\" remove duplicates \"\"\"\n        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)\n\n\n    def order(\n        container: Container,\n        compfunc: Callable\n    ) -> Tuple:\n        \"\"\" order container by custom key \"\"\"\n        return tuple(sorted(container, key=compfunc))\n\n\n    def repeat(\n        item: Any,\n        num: Integer\n    ) -> Tuple:\n        \"\"\" repetition of item within vector \"\"\"\n        return tuple(item for i in range(num))\n\n\n    def greater(\n        a: Integer,\n        b: Integer\n    ) -> Boolean:\n        \"\"\" greater \"\"\"\n        return a > b\n\n\n    def size(\n        container: Container\n    ) -> Integer:\n        \"\"\" cardinality \"\"\"\n        return len(container)\n\n\n    def merge(\n        containers: ContainerContainer\n    ) -> Container:\n        \"\"\" merging \"\"\"\n        return type(containers)(e for c in containers for e in c)\n\n\n    def maximum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" maximum \"\"\"\n        return max(container, default=0)\n\n\n    def minimum(\n        container: IntegerSet\n    ) -> Integer:\n        \"\"\" minimum \"\"\"\n        return min(container, default=0)\n\n\n    def valmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" maximum by custom function \"\"\"\n        return compfunc(max(container, key=compfunc, default=0))\n\n\n    def valmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Integer:\n        \"\"\" minimum by custom function \"\"\"\n        return compfunc(min(container, key=compfunc, default=0))\n\n\n    def argmax(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" largest item by custom order \"\"\"\n        return max(container, key=compfunc)\n\n\n    def argmin(\n        container: Container,\n        compfunc: Callable\n    ) -> Any:\n        \"\"\" smallest item by custom order \"\"\"\n        return min(container, key=compfunc)\n\n\n    def mostcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" most common item \"\"\"\n        return max(set(container), key=container.count)\n\n\n    def leastcommon(\n        container: Container\n    ) -> Any:\n        \"\"\" least common item \"\"\"\n        return min(set(container), key=container.count)\n\n\n    def initset(\n        value: Any\n    ) -> FrozenSet:\n        \"\"\" initialize container \"\"\"\n        return frozenset({value})\n\n\n    def both(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical and \"\"\"\n        return a and b\n\n\n    def either(\n        a: Boolean,\n        b: Boolean\n    ) -> Boolean:\n        \"\"\" logical or \"\"\"\n        return a or b\n\n\n    def increment(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing \"\"\"\n        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)\n\n\n    def decrement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" decrementing \"\"\"\n        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)\n\n\n    def crement(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" incrementing positive and decrementing negative \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)\n        return (\n            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),\n            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)\n        )\n\n\n    def sign(\n        x: Numerical\n    ) -> Numerical:\n        \"\"\" sign \"\"\"\n        if isinstance(x, int):\n            return 0 if x == 0 else (1 if x > 0 else -1)\n        return (\n            0 if x[0] == 0 else (1 if x[0] > 0 else -1),\n            0 if x[1] == 0 else (1 if x[1] > 0 else -1)\n        )\n\n\n    def positive(\n        x: Integer\n    ) -> Boolean:\n        \"\"\" positive \"\"\"\n        return x > 0\n\n\n    def toivec(\n        i: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing vertically \"\"\"\n        return (i, 0)\n\n\n    def tojvec(\n        j: Integer\n    ) -> IntegerTuple:\n        \"\"\" vector pointing horizontally \"\"\"\n        return (0, j)\n\n\n    def sfilter(\n        container: Container,\n        condition: Callable\n    ) -> Container:\n        \"\"\" keep elements in container that satisfy condition \"\"\"\n        return type(container)(e for e in container if condition(e))\n\n\n    def mfilter(\n        container: Container,\n        function: Callable\n    ) -> FrozenSet:\n        \"\"\" filter and merge \"\"\"\n        return merge(sfilter(container, function))\n\n\n    def extract(\n        container: Container,\n        condition: Callable\n    ) -> Any:\n        \"\"\" first element of container that satisfies condition \"\"\"\n        return next(e for e in container if condition(e))\n\n\n    def totuple(\n        container: FrozenSet\n    ) -> Tuple:\n        \"\"\" conversion to tuple \"\"\"\n        return tuple(container)\n\n\n    def first(\n        container: Container\n    ) -> Any:\n        \"\"\" first item of container \"\"\"\n        return next(iter(container))\n\n\n    def last(\n        container: Container\n    ) -> Any:\n        \"\"\" last item of container \"\"\"\n        return max(enumerate(container))[1]\n\n\n    def insert(\n        value: Any,\n        container: FrozenSet\n    ) -> FrozenSet:\n        \"\"\" insert item into container \"\"\"\n        return container.union(frozenset({value}))\n\n\n    def remove(\n        value: Any,\n        container: Container\n    ) -> Container:\n        \"\"\" remove item from container \"\"\"\n        return type(container)(e for e in container if e != value)\n\n\n    def other(\n        container: Container,\n        value: Any\n    ) -> Any:\n        \"\"\" other value in the container \"\"\"\n        return first(remove(value, container))\n\n\n    def interval(\n        start: Integer,\n        stop: Integer,\n        step: Integer\n    ) -> Tuple:\n        \"\"\" range \"\"\"\n        return tuple(range(start, stop, step))\n\n\n    def astuple(\n        a: Integer,\n        b: Integer\n    ) -> IntegerTuple:\n        \"\"\" constructs a tuple \"\"\"\n        return (a, b)\n\n\n    def product(\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" cartesian product \"\"\"\n        return frozenset((i, j) for j in b for i in a)\n\n\n    def pair(\n        a: Tuple,\n        b: Tuple\n    ) -> TupleTuple:\n        \"\"\" zipping of two tuples \"\"\"\n        return tuple(zip(a, b))\n\n\n    def branch(\n        condition: Boolean,\n        a: Any,\n        b: Any\n    ) -> Any:\n        \"\"\" if else branching \"\"\"\n        return a if condition else b\n\n\n    def compose(\n        outer: Callable,\n        inner: Callable\n    ) -> Callable:\n        \"\"\" function composition \"\"\"\n        return lambda x: outer(inner(x))\n\n\n    def chain(\n        h: Callable,\n        g: Callable,\n        f: Callable,\n    ) -> Callable:\n        \"\"\" function composition with three functions \"\"\"\n        return lambda x: h(g(f(x)))\n\n\n    def matcher(\n        function: Callable,\n        target: Any\n    ) -> Callable:\n        \"\"\" construction of equality function \"\"\"\n        return lambda x: function(x) == target\n\n\n    def rbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the rightmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda x: function(x, fixed)\n        elif n == 3:\n            return lambda x, y: function(x, y, fixed)\n        else:\n            return lambda x, y, z: function(x, y, z, fixed)\n\n\n    def lbind(\n        function: Callable,\n        fixed: Any\n    ) -> Callable:\n        \"\"\" fix the leftmost argument \"\"\"\n        n = function.__code__.co_argcount\n        if n == 2:\n            return lambda y: function(fixed, y)\n        elif n == 3:\n            return lambda y, z: function(fixed, y, z)\n        else:\n            return lambda y, z, a: function(fixed, y, z, a)\n\n\n    def power(\n        function: Callable,\n        n: Integer\n    ) -> Callable:\n        \"\"\" power of function \"\"\"\n        if n == 1:\n            return function\n        return compose(function, power(function, n - 1))\n\n\n    def fork(\n        outer: Callable,\n        a: Callable,\n        b: Callable\n    ) -> Callable:\n        \"\"\" creates a wrapper function \"\"\"\n        return lambda x: outer(a(x), b(x))\n\n\n    def apply(\n        function: Callable,\n        container: Container\n    ) -> Container:\n        \"\"\" apply function to each item in container \"\"\"\n        return type(container)(function(e) for e in container)\n\n\n    def rapply(\n        functions: Container,\n        value: Any\n    ) -> Container:\n        \"\"\" apply each function in container to value \"\"\"\n        return type(functions)(function(value) for function in functions)\n\n\n    def mapply(\n        function: Callable,\n        container: ContainerContainer\n    ) -> FrozenSet:\n        \"\"\" apply and merge \"\"\"\n        return merge(apply(function, container))\n\n\n    def papply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors \"\"\"\n        return tuple(function(i, j) for i, j in zip(a, b))\n\n\n    def mpapply(\n        function: Callable,\n        a: Tuple,\n        b: Tuple\n    ) -> Tuple:\n        \"\"\" apply function on two vectors and merge \"\"\"\n        return merge(papply(function, a, b))\n\n\n    def prapply(\n        function,\n        a: Container,\n        b: Container\n    ) -> FrozenSet:\n        \"\"\" apply function on cartesian product \"\"\"\n        return frozenset(function(i, j) for j in b for i in a)\n\n\n    def mostcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" most common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return max(set(values), key=values.count)\n        \n\n    def leastcolor(\n        element: Element\n    ) -> Integer:\n        \"\"\" least common color \"\"\"\n        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]\n        return min(set(values), key=values.count)\n\n\n    def height(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" height of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece)\n        return lowermost(piece) - uppermost(piece) + 1\n\n\n    def width(\n        piece: Piece\n    ) -> Integer:\n        \"\"\" width of grid or patch \"\"\"\n        if len(piece) == 0:\n            return 0\n        if isinstance(piece, tuple):\n            return len(piece[0])\n        return rightmost(piece) - leftmost(piece) + 1\n\n\n    def shape(\n        piece: Piece\n    ) -> IntegerTuple:\n        \"\"\" height and width of grid or patch \"\"\"\n        return (height(piece), width(piece))\n\n\n    def portrait(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether height is greater than width \"\"\"\n        return height(piece) > width(piece)\n\n\n    def colorcount(\n        element: Element,\n        value: Integer\n    ) -> Integer:\n        \"\"\" number of cells with color \"\"\"\n        if isinstance(element, tuple):\n            return sum(row.count(value) for row in element)\n        return sum(v == value for v, _ in element)\n\n\n    def colorfilter(\n        objs: Objects,\n        value: Integer\n    ) -> Objects:\n        \"\"\" filter objects by color \"\"\"\n        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)\n\n\n    def sizefilter(\n        container: Container,\n        n: Integer\n    ) -> FrozenSet:\n        \"\"\" filter items by size \"\"\"\n        return frozenset(item for item in container if len(item) == n)\n\n\n    def asindices(\n        grid: Grid\n    ) -> Indices:\n        \"\"\" indices of all grid cells \"\"\"\n        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n\n\n    def ofcolor(\n        grid: Grid,\n        value: Integer\n    ) -> Indices:\n        \"\"\" indices of all grid cells with value \"\"\"\n        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)\n\n\n    def ulcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper left corner \"\"\"\n        return tuple(map(min, zip(*toindices(patch))))\n\n\n    def urcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of upper right corner \"\"\"\n        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def llcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower left corner \"\"\"\n        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))\n\n\n    def lrcorner(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" index of lower right corner \"\"\"\n        return tuple(map(max, zip(*toindices(patch))))\n\n\n    def crop(\n        grid: Grid,\n        start: IntegerTuple,\n        dims: IntegerTuple\n    ) -> Grid:\n        \"\"\" subgrid specified by start and dimension \"\"\"\n        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])\n\n\n    def toindices(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of object cells \"\"\"\n        if len(patch) == 0:\n            return frozenset()\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset(index for value, index in patch)\n        return patch\n\n\n    def recolor(\n        value: Integer,\n        patch: Patch\n    ) -> Object:\n        \"\"\" recolor patch \"\"\"\n        return frozenset((value, index) for index in toindices(patch))\n\n\n    def shift(\n        patch: Patch,\n        directions: IntegerTuple\n    ) -> Patch:\n        \"\"\" shift patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        di, dj = directions\n        if isinstance(next(iter(patch))[1], tuple):\n            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)\n        return frozenset((i + di, j + dj) for i, j in patch)\n\n\n    def normalize(\n        patch: Patch\n    ) -> Patch:\n        \"\"\" moves upper left corner to origin \"\"\"\n        if len(patch) == 0:\n            return patch\n        return shift(patch, (-uppermost(patch), -leftmost(patch)))\n\n\n    def dneighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" directly adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})\n\n\n    def ineighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" diagonally adjacent indices \"\"\"\n        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})\n\n\n    def neighbors(\n        loc: IntegerTuple\n    ) -> Indices:\n        \"\"\" adjacent indices \"\"\"\n        return dneighbors(loc) | ineighbors(loc)\n\n\n    def objects(\n        grid: Grid,\n        univalued: Boolean,\n        diagonal: Boolean,\n        without_bg: Boolean\n    ) -> Objects:\n        \"\"\" objects occurring on the grid \"\"\"\n        bg = mostcolor(grid) if without_bg else None\n        objs = set()\n        occupied = set()\n        h, w = len(grid), len(grid[0])\n        unvisited = asindices(grid)\n        diagfun = neighbors if diagonal else dneighbors\n        for loc in unvisited:\n            if loc in occupied:\n                continue\n            val = grid[loc[0]][loc[1]]\n            if val == bg:\n                continue\n            obj = {(val, loc)}\n            cands = {loc}\n            while len(cands) > 0:\n                neighborhood = set()\n                for cand in cands:\n                    v = grid[cand[0]][cand[1]]\n                    if (val == v) if univalued else (v != bg):\n                        obj.add((v, cand))\n                        occupied.add(cand)\n                        neighborhood |= {\n                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w\n                        }\n                cands = neighborhood - occupied\n            objs.add(frozenset(obj))\n        return frozenset(objs)\n\n\n    def partition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid)\n        )\n\n\n    def fgpartition(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" each cell with the same value part of the same object without background \"\"\"\n        return frozenset(\n            frozenset(\n                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value\n            ) for value in palette(grid) - {mostcolor(grid)}\n        )\n\n\n    def uppermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of uppermost occupied cell \"\"\"\n        return min(i for i, j in toindices(patch))\n\n\n    def lowermost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" row index of lowermost occupied cell \"\"\"\n        return max(i for i, j in toindices(patch))\n\n\n    def leftmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of leftmost occupied cell \"\"\"\n        return min(j for i, j in toindices(patch))\n\n\n    def rightmost(\n        patch: Patch\n    ) -> Integer:\n        \"\"\" column index of rightmost occupied cell \"\"\"\n        return max(j for i, j in toindices(patch))\n\n\n    def square(\n        piece: Piece\n    ) -> Boolean:\n        \"\"\" whether the piece forms a square \"\"\"\n        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)\n\n\n    def vline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a vertical line \"\"\"\n        return height(patch) == len(patch) and width(patch) == 1\n\n\n    def hline(\n        patch: Patch\n    ) -> Boolean:\n        \"\"\" whether the piece forms a horizontal line \"\"\"\n        return width(patch) == len(patch) and height(patch) == 1\n\n\n    def hmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a row for which both patches have cells \"\"\"\n        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0\n\n\n    def vmatching(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether there exists a column for which both patches have cells \"\"\"\n        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0\n\n\n    def manhattan(\n        a: Patch,\n        b: Patch\n    ) -> Integer:\n        \"\"\" closest manhattan distance between two patches \"\"\"\n        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))\n\n\n    def adjacent(\n        a: Patch,\n        b: Patch\n    ) -> Boolean:\n        \"\"\" whether two patches are adjacent \"\"\"\n        return manhattan(a, b) == 1\n\n\n    def bordering(\n        patch: Patch,\n        grid: Grid\n    ) -> Boolean:\n        \"\"\" whether a patch is adjacent to a grid border \"\"\"\n        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1\n\n\n    def centerofmass(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of mass \"\"\"\n        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))\n\n\n    def palette(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" colors occurring in object or grid \"\"\"\n        if isinstance(element, tuple):\n            return frozenset({v for r in element for v in r})\n        return frozenset({v for v, _ in element})\n\n\n    def numcolors(\n        element: Element\n    ) -> IntegerSet:\n        \"\"\" number of colors occurring in object or grid \"\"\"\n        return len(palette(element))\n\n\n    def color(\n        obj: Object\n    ) -> Integer:\n        \"\"\" color of object \"\"\"\n        return next(iter(obj))[0]\n\n\n    def toobject(\n        patch: Patch,\n        grid: Grid\n    ) -> Object:\n        \"\"\" object from patch and grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)\n\n\n    def asobject(\n        grid: Grid\n    ) -> Object:\n        \"\"\" conversion of grid to object \"\"\"\n        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))\n\n\n    def rot90(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter clockwise rotation \"\"\"\n        return tuple(row for row in zip(*grid[::-1]))\n\n\n    def rot180(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" half rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in grid[::-1])\n\n\n    def rot270(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" quarter anticlockwise rotation \"\"\"\n        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]\n\n\n    def hmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along horizontal \"\"\"\n        if isinstance(piece, tuple):\n            return piece[::-1]\n        d = ulcorner(piece)[0] + lrcorner(piece)[0]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (d - i, j)) for v, (i, j) in piece)\n        return frozenset((d - i, j) for i, j in piece)\n\n\n    def vmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along vertical \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(row[::-1] for row in piece)\n        d = ulcorner(piece)[1] + lrcorner(piece)[1]\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (i, d - j)) for v, (i, j) in piece)\n        return frozenset((i, d - j) for i, j in piece)\n\n\n    def dmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along diagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*piece))\n        a, b = ulcorner(piece)\n        if isinstance(next(iter(piece))[1], tuple):\n            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)\n        return frozenset((j - b + a, i - a + b) for i, j in piece)\n\n\n    def cmirror(\n        piece: Piece\n    ) -> Piece:\n        \"\"\" mirroring along counterdiagonal \"\"\"\n        if isinstance(piece, tuple):\n            return tuple(zip(*(r[::-1] for r in piece[::-1])))\n        return vmirror(dmirror(vmirror(piece)))\n\n\n    def fill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_filled = list(list(row) for row in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                grid_filled[i][j] = value\n        return tuple(tuple(row) for row in grid_filled)\n\n\n    def paint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        grid_painted = list(list(row) for row in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                grid_painted[i][j] = value\n        return tuple(tuple(row) for row in grid_painted)\n\n\n    def underfill(\n        grid: Grid,\n        value: Integer,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" fill value at indices that are background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for i, j in toindices(patch):\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def underpaint(\n        grid: Grid,\n        obj: Object\n    ) -> Grid:\n        \"\"\" paint object to grid where there is background \"\"\"\n        h, w = len(grid), len(grid[0])\n        bg = mostcolor(grid)\n        g = list(list(r) for r in grid)\n        for value, (i, j) in obj:\n            if 0 <= i < h and 0 <= j < w:\n                if g[i][j] == bg:\n                    g[i][j] = value\n        return tuple(tuple(r) for r in g)\n\n\n    def hupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid horizontally \"\"\"\n        g = tuple()\n        for row in grid:\n            r = tuple()\n            for value in row:\n                r = r + tuple(value for num in range(factor))\n            g = g + (r,)\n        return g\n\n\n    def vupscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" upscale grid vertically \"\"\"\n        g = tuple()\n        for row in grid:\n            g = g + tuple(row for num in range(factor))\n        return g\n\n\n    def upscale(\n        element: Element,\n        factor: Integer\n    ) -> Element:\n        \"\"\" upscale object or grid \"\"\"\n        if isinstance(element, tuple):\n            g = tuple()\n            for row in element:\n                upscaled_row = tuple()\n                for value in row:\n                    upscaled_row = upscaled_row + tuple(value for num in range(factor))\n                g = g + tuple(upscaled_row for num in range(factor))\n            return g\n        else:\n            if len(element) == 0:\n                return frozenset()\n            di_inv, dj_inv = ulcorner(element)\n            di, dj = (-di_inv, -dj_inv)\n            normed_obj = shift(element, (di, dj))\n            o = set()\n            for value, (i, j) in normed_obj:\n                for io in range(factor):\n                    for jo in range(factor):\n                        o.add((value, (i * factor + io, j * factor + jo)))\n            return shift(frozenset(o), (di_inv, dj_inv))\n\n\n    def downscale(\n        grid: Grid,\n        factor: Integer\n    ) -> Grid:\n        \"\"\" downscale grid \"\"\"\n        h, w = len(grid), len(grid[0])\n        g = tuple()\n        for i in range(h):\n            r = tuple()\n            for j in range(w):\n                if j % factor == 0:\n                    r = r + (grid[i][j],)\n            g = g + (r, )\n        h = len(g)\n        dsg = tuple()\n        for i in range(h):\n            if i % factor == 0:\n                dsg = dsg + (g[i],)\n        return dsg\n\n\n    def hconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids horizontally \"\"\"\n        return tuple(i + j for i, j in zip(a, b))\n\n\n    def vconcat(\n        a: Grid,\n        b: Grid\n    ) -> Grid:\n        \"\"\" concatenate two grids vertically \"\"\"\n        return a + b\n\n\n    def subgrid(\n        patch: Patch,\n        grid: Grid\n    ) -> Grid:\n        \"\"\" smallest subgrid containing object \"\"\"\n        return crop(grid, ulcorner(patch), shape(patch))\n\n\n    def hsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid horizontally \"\"\"\n        h, w = len(grid), len(grid[0]) // n\n        offset = len(grid[0]) % n != 0\n        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))\n\n\n    def vsplit(\n        grid: Grid,\n        n: Integer\n    ) -> Tuple:\n        \"\"\" split grid vertically \"\"\"\n        h, w = len(grid) // n, len(grid[0])\n        offset = len(grid) % n != 0\n        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))\n\n\n    def cellwise(\n        a: Grid,\n        b: Grid,\n        fallback: Integer\n    ) -> Grid:\n        \"\"\" cellwise match of two grids \"\"\"\n        h, w = len(a), len(a[0])\n        resulting_grid = tuple()\n        for i in range(h):\n            row = tuple()\n            for j in range(w):\n                a_value = a[i][j]\n                value = a_value if a_value == b[i][j] else fallback\n                row = row + (value,)\n            resulting_grid = resulting_grid + (row, )\n        return resulting_grid\n\n\n    def replace(\n        grid: Grid,\n        replacee: Integer,\n        replacer: Integer\n    ) -> Grid:\n        \"\"\" color substitution \"\"\"\n        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)\n\n\n    def switch(\n        grid: Grid,\n        a: Integer,\n        b: Integer\n    ) -> Grid:\n        \"\"\" color switching \"\"\"\n        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)\n\n\n    def center(\n        patch: Patch\n    ) -> IntegerTuple:\n        \"\"\" center of the patch \"\"\"\n        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)\n\n\n    def position(\n        a: Patch,\n        b: Patch\n    ) -> IntegerTuple:\n        \"\"\" relative position between two patches \"\"\"\n        ia, ja = center(toindices(a))\n        ib, jb = center(toindices(b))\n        if ia == ib:\n            return (0, 1 if ja < jb else -1)\n        elif ja == jb:\n            return (1 if ia < ib else -1, 0)\n        elif ia < ib:\n            return (1, 1 if ja < jb else -1)\n        elif ia > ib:\n            return (-1, 1 if ja < jb else -1)\n\n\n    def index(\n        grid: Grid,\n        loc: IntegerTuple\n    ) -> Integer:\n        \"\"\" color at location \"\"\"\n        i, j = loc\n        h, w = len(grid), len(grid[0])\n        if not (0 <= i < h and 0 <= j < w):\n            return None\n        return grid[loc[0]][loc[1]] \n\n\n    def canvas(\n        value: Integer,\n        dimensions: IntegerTuple\n    ) -> Grid:\n        \"\"\" grid construction \"\"\"\n        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))\n\n\n    def corners(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices of corners \"\"\"\n        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})\n\n\n    def connect(\n        a: IntegerTuple,\n        b: IntegerTuple\n    ) -> Indices:\n        \"\"\" line between two points \"\"\"\n        ai, aj = a\n        bi, bj = b\n        si = min(ai, bi)\n        ei = max(ai, bi) + 1\n        sj = min(aj, bj)\n        ej = max(aj, bj) + 1\n        if ai == bi:\n            return frozenset((ai, j) for j in range(sj, ej))\n        elif aj == bj:\n            return frozenset((i, aj) for i in range(si, ei))\n        elif bi - ai == bj - aj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))\n        elif bi - ai == aj - bj:\n            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))\n        return frozenset()\n\n\n    def cover(\n        grid: Grid,\n        patch: Patch\n    ) -> Grid:\n        \"\"\" remove object from grid \"\"\"\n        return fill(grid, mostcolor(grid), toindices(patch))\n\n\n    def trim(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" trim border of grid \"\"\"\n        return tuple(r[1:-1] for r in grid[1:-1])\n\n\n    def move(\n        grid: Grid,\n        obj: Object,\n        offset: IntegerTuple\n    ) -> Grid:\n        \"\"\" move object on grid \"\"\"\n        return paint(cover(grid, obj), shift(obj, offset))\n\n\n    def tophalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" upper half of grid \"\"\"\n        return grid[:len(grid) // 2]\n\n\n    def bottomhalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" lower half of grid \"\"\"\n        return grid[len(grid) // 2 + len(grid) % 2:]\n\n\n    def lefthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" left half of grid \"\"\"\n        return rot270(tophalf(rot90(grid)))\n\n\n    def righthalf(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" right half of grid \"\"\"\n        return rot270(bottomhalf(rot90(grid)))\n\n\n    def vfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" vertical frontier \"\"\"\n        return frozenset((i, location[1]) for i in range(30))\n\n\n    def hfrontier(\n        location: IntegerTuple\n    ) -> Indices:\n        \"\"\" horizontal frontier \"\"\"\n        return frozenset((location[0], j) for j in range(30))\n\n\n    def backdrop(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        indices = toindices(patch)\n        si, sj = ulcorner(indices)\n        ei, ej = lrcorner(patch)\n        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))\n\n\n    def delta(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" indices in bounding box but not part of patch \"\"\"\n        if len(patch) == 0:\n            return frozenset({})\n        return backdrop(patch) - toindices(patch)\n\n\n    def gravitate(\n        source: Patch,\n        destination: Patch\n    ) -> IntegerTuple:\n        \"\"\" direction to move source until adjacent to destination \"\"\"\n        si, sj = center(source)\n        di, dj = center(destination)\n        i, j = 0, 0\n        if vmatching(source, destination):\n            i = 1 if si < di else -1\n        else:\n            j = 1 if sj < dj else -1\n        gi, gj = i, j\n        c = 0\n        while not adjacent(source, destination) and c < 42:\n            c += 1\n            gi += i\n            gj += j\n            source = shift(source, (i, j))\n        return (gi - i, gj - j)\n\n\n    def inbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" inbox for patch \"\"\"\n        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1\n        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def outbox(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outbox for patch \"\"\"\n        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1\n        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def box(\n        patch: Patch\n    ) -> Indices:\n        \"\"\" outline of patch \"\"\"\n        if len(patch) == 0:\n            return patch\n        ai, aj = ulcorner(patch)\n        bi, bj = lrcorner(patch)\n        si, sj = min(ai, bi), min(aj, bj)\n        ei, ej = max(ai, bi), max(aj, bj)\n        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}\n        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}\n        return frozenset(vlines | hlines)\n\n\n    def shoot(\n        start: IntegerTuple,\n        direction: IntegerTuple\n    ) -> Indices:\n        \"\"\" line from starting point and direction \"\"\"\n        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))\n\n\n    def occurrences(\n        grid: Grid,\n        obj: Object\n    ) -> Indices:\n        \"\"\" locations of occurrences of object in grid \"\"\"\n        occs = set()\n        normed = normalize(obj)\n        h, w = len(grid), len(grid[0])\n        oh, ow = shape(obj)\n        h2, w2 = h - oh + 1, w - ow + 1\n        for i in range(h2):\n            for j in range(w2):\n                occurs = True\n                for v, (a, b) in shift(normed, (i, j)):\n                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):\n                        occurs = False\n                        break\n                if occurs:\n                    occs.add((i, j))\n        return frozenset(occs)\n\n\n    def frontiers(\n        grid: Grid\n    ) -> Objects:\n        \"\"\" set of frontiers \"\"\"\n        h, w = len(grid), len(grid[0])\n        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})\n        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})\n        return hfrontiers | vfrontiers\n\n\n    def compress(\n        grid: Grid\n    ) -> Grid:\n        \"\"\" removes frontiers from grid \"\"\"\n        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)\n        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)\n        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)\n\n\n    def hperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" horizontal periodicity \"\"\"\n        normalized = normalize(obj)\n        w = width(normalized)\n        for p in range(1, w):\n            offsetted = shift(normalized, (0, -p))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return w\n\n\n    def vperiod(\n        obj: Object\n    ) -> Integer:\n        \"\"\" vertical periodicity \"\"\"\n        normalized = normalize(obj)\n        h = height(normalized)\n        for p in range(1, h):\n            offsetted = shift(normalized, (-p, 0))\n            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})\n            if pruned.issubset(normalized):\n                return p\n        return h"
        },
        {
            "role": "assistant",
            "content": "Below is an example ARC-style puzzle (maximum grid size 10×10) in which the goal is to swap the colors 0 and 3 across the entire grid. The puzzle provides three training input-output examples (train #1, #2, #3) and one test input-output pair (test #1). The “analogy” or pattern that solves these examples is simply: wherever you see a 0 in the input, it becomes 3 in the output, and wherever you see a 3 in the input, it becomes 0 in the output. Other colors remain untouched.\n\n━━━━━━━━━━━━━━━\nARC-Like Task\n━━━━━━━━━━━━━━━\n\n1) Training Examples\n\n────────────────────────────────────────────────────────────────────────────\nTrain #1\n────────────────────────────────────────────────────────────────────────────\nInput (3×3):\n[\n  [0, 0, 0],\n  [0, 3, 0],\n  [3, 0, 3]\n]\n\nOutput (3×3):\n[\n  [3, 3, 3],\n  [3, 0, 3],\n  [0, 3, 0]\n]\n\n────────────────────────────────────────────────────────────────────────────\nTrain #2\n────────────────────────────────────────────────────────────────────────────\nInput (3×3):\n[\n  [0, 2, 3],\n  [3, 1, 0],\n  [2, 2, 2]\n]\n\nOutput (3×3):\n[\n  [3, 2, 0],\n  [0, 1, 3],\n  [2, 2, 2]\n]\n\n────────────────────────────────────────────────────────────────────────────\nTrain #3\n────────────────────────────────────────────────────────────────────────────\nInput (3×3):\n[\n  [3, 1, 3],\n  [0, 3, 0],\n  [0, 0, 3]\n]\n\nOutput (3×3):\n[\n  [0, 1, 0],\n  [3, 0, 3],\n  [3, 3, 0]\n]\n\n2) Test Example\n\n────────────────────────────────────────────────────────────────────────────\nTest #1\n────────────────────────────────────────────────────────────────────────────\nInput (3×4):\n[\n  [0, 3, 2, 2],\n  [0, 3, 3, 0],\n  [1, 0, 3, 2]\n]\n\nOutput (3×4):\n[\n  [3, 0, 2, 2],\n  [3, 0, 0, 3],\n  [1, 3, 0, 2]\n]\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nAnalogy Description\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n“For every grid cell, if its color is 0, swap it to 3; if its color is 3, swap it to 0. All other colors remain unchanged.”\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nSolution Program with Hodel DSL\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nBelow is a minimal illustrative solution in Python using the DSL functions you provided. In particular, we use the “switch” function, which has the signature:\n\n    switch(grid: Grid, a: Integer, b: Integer) -> Grid\n\n…and we partially apply its parameters using “rbind” to fix the two integer arguments a=0 and b=3, then apply the resultant function to the grid.\n\n────────────────────────────────────────────────────────────────────────────\nfrom arc_types import *\n\ndef solve(grid: Grid) -> Grid:\n    \"\"\"\n    The puzzle requires swapping the colors 0 and 3 in the grid.\n    \"\"\"\n    # Step 1: Fix the second parameter of switch(...) to 0\n    #         so we get a partial function f(grid, b).\n    fix_second = rbind(switch, 0)\n    \n    # Step 2: Now fix the third parameter to 3, yielding a function g(grid).\n    fix_third = rbind(fix_second, 3)\n    \n    # Step 3: Apply that function to the input grid, returning the swapped result.\n    return fix_third(grid)\n────────────────────────────────────────────────────────────────────────────\n\nThis completes an ARC-like puzzle specification (with three training pairs and one test pair) together with a concise solution in the DSL that implements the analogy of swapping colors 0 and 3."
        }
    ]
}